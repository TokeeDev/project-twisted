"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/effect";
exports.ids = ["vendor-chunks/effect"];
exports.modules = {

/***/ "(ssr)/./node_modules/effect/dist/esm/Array.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Array.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   allocate: () => (/* binding */ allocate),\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendAll: () => (/* binding */ appendAll),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   cartesian: () => (/* binding */ cartesian),\n/* harmony export */   cartesianWith: () => (/* binding */ cartesianWith),\n/* harmony export */   chop: () => (/* binding */ chop),\n/* harmony export */   chunksOf: () => (/* binding */ chunksOf),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   containsWith: () => (/* binding */ containsWith),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   dedupe: () => (/* binding */ dedupe),\n/* harmony export */   dedupeAdjacent: () => (/* binding */ dedupeAdjacent),\n/* harmony export */   dedupeAdjacentWith: () => (/* binding */ dedupeAdjacentWith),\n/* harmony export */   dedupeWith: () => (/* binding */ dedupeWith),\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   differenceWith: () => (/* binding */ differenceWith),\n/* harmony export */   drop: () => (/* binding */ drop),\n/* harmony export */   dropRight: () => (/* binding */ dropRight),\n/* harmony export */   dropWhile: () => (/* binding */ dropWhile),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   ensure: () => (/* binding */ ensure),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   filterMapWhile: () => (/* binding */ filterMapWhile),\n/* harmony export */   findFirst: () => (/* binding */ findFirst),\n/* harmony export */   findFirstIndex: () => (/* binding */ findFirstIndex),\n/* harmony export */   findLast: () => (/* binding */ findLast),\n/* harmony export */   findLastIndex: () => (/* binding */ findLastIndex),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatMapNullable: () => (/* binding */ flatMapNullable),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   fromIterable: () => (/* binding */ fromIterable),\n/* harmony export */   fromNullable: () => (/* binding */ fromNullable),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   fromRecord: () => (/* binding */ fromRecord),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getLefts: () => (/* binding */ getLefts),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getRights: () => (/* binding */ getRights),\n/* harmony export */   getSomes: () => (/* binding */ getSomes),\n/* harmony export */   group: () => (/* binding */ group),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   groupWith: () => (/* binding */ groupWith),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   headNonEmpty: () => (/* binding */ headNonEmpty),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   initNonEmpty: () => (/* binding */ initNonEmpty),\n/* harmony export */   insertAt: () => (/* binding */ insertAt),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   intersectionWith: () => (/* binding */ intersectionWith),\n/* harmony export */   intersperse: () => (/* binding */ intersperse),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isEmptyArray: () => (/* binding */ isEmptyArray),\n/* harmony export */   isEmptyReadonlyArray: () => (/* binding */ isEmptyReadonlyArray),\n/* harmony export */   isNonEmptyArray: () => (/* binding */ isNonEmptyArray),\n/* harmony export */   isNonEmptyReadonlyArray: () => (/* binding */ isNonEmptyReadonlyArray),\n/* harmony export */   join: () => (/* binding */ join),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   lastNonEmpty: () => (/* binding */ lastNonEmpty),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   liftEither: () => (/* binding */ liftEither),\n/* harmony export */   liftNullable: () => (/* binding */ liftNullable),\n/* harmony export */   liftOption: () => (/* binding */ liftOption),\n/* harmony export */   liftPredicate: () => (/* binding */ liftPredicate),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   makeBy: () => (/* binding */ makeBy),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAccum: () => (/* binding */ mapAccum),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   matchLeft: () => (/* binding */ matchLeft),\n/* harmony export */   matchRight: () => (/* binding */ matchRight),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   modify: () => (/* binding */ modify),\n/* harmony export */   modifyNonEmptyHead: () => (/* binding */ modifyNonEmptyHead),\n/* harmony export */   modifyNonEmptyLast: () => (/* binding */ modifyNonEmptyLast),\n/* harmony export */   modifyOption: () => (/* binding */ modifyOption),\n/* harmony export */   of: () => (/* binding */ of),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   partition: () => (/* binding */ partition),\n/* harmony export */   partitionMap: () => (/* binding */ partitionMap),\n/* harmony export */   prepend: () => (/* binding */ prepend),\n/* harmony export */   prependAll: () => (/* binding */ prependAll),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   reduceRight: () => (/* binding */ reduceRight),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   replaceOption: () => (/* binding */ replaceOption),\n/* harmony export */   replicate: () => (/* binding */ replicate),\n/* harmony export */   reverse: () => (/* binding */ reverse),\n/* harmony export */   rotate: () => (/* binding */ rotate),\n/* harmony export */   scan: () => (/* binding */ scan),\n/* harmony export */   scanRight: () => (/* binding */ scanRight),\n/* harmony export */   separate: () => (/* binding */ separate),\n/* harmony export */   setNonEmptyHead: () => (/* binding */ setNonEmptyHead),\n/* harmony export */   setNonEmptyLast: () => (/* binding */ setNonEmptyLast),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   sort: () => (/* binding */ sort),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   sortWith: () => (/* binding */ sortWith),\n/* harmony export */   span: () => (/* binding */ span),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   splitAt: () => (/* binding */ splitAt),\n/* harmony export */   splitNonEmptyAt: () => (/* binding */ splitNonEmptyAt),\n/* harmony export */   splitWhere: () => (/* binding */ splitWhere),\n/* harmony export */   tail: () => (/* binding */ tail),\n/* harmony export */   tailNonEmpty: () => (/* binding */ tailNonEmpty),\n/* harmony export */   take: () => (/* binding */ take),\n/* harmony export */   takeRight: () => (/* binding */ takeRight),\n/* harmony export */   takeWhile: () => (/* binding */ takeWhile),\n/* harmony export */   unappend: () => (/* binding */ unappend),\n/* harmony export */   unfold: () => (/* binding */ unfold),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionWith: () => (/* binding */ unionWith),\n/* harmony export */   unprepend: () => (/* binding */ unprepend),\n/* harmony export */   unsafeGet: () => (/* binding */ unsafeGet),\n/* harmony export */   unzip: () => (/* binding */ unzip),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _internal_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/array.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/array.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _Iterable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Iterable.js */ \"(ssr)/./node_modules/effect/dist/esm/Iterable.js\");\n/* harmony import */ var _Option_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Option.js */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _Order_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Order.js */ \"(ssr)/./node_modules/effect/dist/esm/Order.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Record_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Record.js */ \"(ssr)/./node_modules/effect/dist/esm/Record.js\");\n/* harmony import */ var _Tuple_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Tuple.js */ \"(ssr)/./node_modules/effect/dist/esm/Tuple.js\");\n/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 2.0.0\n */ \n\n\n\n\n\n\n\n\n\n\n\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.make(1, 2, 3)\n * assert.deepStrictEqual(result, [1, 2, 3])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const make = (...elements)=>elements;\n/**\n * Creates a new `Array` of the specified length.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.allocate<number>(3)\n * assert.deepStrictEqual(result.length, 3)\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const allocate = (n)=>new Array(n);\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * ```ts\n * import { makeBy } from \"effect/Array\"\n *\n * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const makeBy = (n, f)=>{\n    const max = Math.max(1, Math.floor(n));\n    const out = new Array(max);\n    for(let i = 0; i < max; i++){\n        out[i] = f(i);\n    }\n    return out;\n};\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * ```ts\n * import { range } from \"effect/Array\"\n *\n * assert.deepStrictEqual(range(1, 3), [1, 2, 3])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const range = (start, end)=>start <= end ? makeBy(end - start + 1, (i)=>start + i) : [\n        start\n    ];\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * assert.deepStrictEqual(Array.replicate(\"a\", 3), [\"a\", \"a\", \"a\"])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const replicate = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (a, n)=>makeBy(n, ()=>a));\n/**\n * Creates a new `Array` from an iterable collection of values.\n * If the input is already an array, it returns the input as-is.\n * Otherwise, it converts the iterable collection to an array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const set = new Set([1, 2, 3])\n * const result = Array.fromIterable(set)\n * assert.deepStrictEqual(result, [1, 2, 3])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const fromIterable = (collection)=>Array.isArray(collection) ? collection : Array.from(collection);\n/**\n * Creates a new `Array` from a value that might not be an iterable.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * assert.deepStrictEqual(Array.ensure(\"a\"), [\"a\"])\n * assert.deepStrictEqual(Array.ensure([\"a\"]), [\"a\"])\n * assert.deepStrictEqual(Array.ensure([\"a\", \"b\", \"c\"]), [\"a\", \"b\", \"c\"])\n * ```\n *\n * @category constructors\n * @since 3.3.0\n */ const ensure = (self)=>Array.isArray(self) ? self : [\n        self\n    ];\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(Array.fromRecord(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const fromRecord = _Record_js__WEBPACK_IMPORTED_MODULE_1__.toEntries;\n/**\n * Converts an `Option` to an array.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Array.fromOption(Option.some(1)), [1])\n * assert.deepStrictEqual(Array.fromOption(Option.none()), [])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const fromOption = _Option_js__WEBPACK_IMPORTED_MODULE_2__.toArray;\n/**\n * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const match = Array.match({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n * })\n * assert.deepStrictEqual(match([]), \"empty\")\n * assert.deepStrictEqual(match([1, 2, 3]), \"head: 1, tail: 2\")\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */ const match = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, { onEmpty, onNonEmpty })=>isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());\n/**\n * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchLeft = Array.matchLeft({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n * })\n * assert.deepStrictEqual(matchLeft([]), \"empty\")\n * assert.deepStrictEqual(matchLeft([1, 2, 3]), \"head: 1, tail: 2\")\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */ const matchLeft = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, { onEmpty, onNonEmpty })=>isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());\n/**\n * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchRight = Array.matchRight({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n * })\n * assert.deepStrictEqual(matchRight([]), \"empty\")\n * assert.deepStrictEqual(matchRight([1, 2, 3]), \"init: 2, last: 3\")\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */ const matchRight = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, { onEmpty, onNonEmpty })=>isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const original = [2, 3, 4];\n * const result = Array.prepend(original, 1);\n * assert.deepStrictEqual(result, [1, 2, 3, 4]);\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */ const prepend = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, head)=>[\n        head,\n        ...self\n    ]);\n/**\n * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const prefix = [0, 1];\n * const array = [2, 3];\n * const result = Array.prependAll(array, prefix);\n * assert.deepStrictEqual(result, [0, 1, 2, 3]);\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */ const prependAll = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>fromIterable(that).concat(fromIterable(self)));\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const original = [1, 2, 3];\n * const result = Array.append(original, 4);\n * assert.deepStrictEqual(result, [1, 2, 3, 4]);\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */ const append = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, last)=>[\n        ...self,\n        last\n    ]);\n/**\n * Concatenates two arrays (or iterables), combining their elements.\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @category concatenating\n * @since 2.0.0\n */ const appendAll = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>fromIterable(self).concat(fromIterable(that)));\n/**\n * Accumulates values from an `Iterable` starting from the left, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\";\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.scan(numbers, 0, (acc, value) => acc + value)\n * assert.deepStrictEqual(result, [0, 1, 3, 6, 10])\n *\n * // Explanation:\n * // This function starts with the initial value (0 in this case)\n * // and adds each element of the array to this accumulator one by one,\n * // keeping track of the cumulative sum after each addition.\n * // Each of these sums is captured in the resulting array.\n * ```\n *\n * @category folding\n * @since 2.0.0\n */ const scan = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, b, f)=>{\n    const out = [\n        b\n    ];\n    let i = 0;\n    for (const a of self){\n        out[i + 1] = f(out[i], a);\n        i++;\n    }\n    return out;\n});\n/**\n * Accumulates values from an `Iterable` starting from the right, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\";\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.scanRight(numbers, 0, (acc, value) => acc + value)\n * assert.deepStrictEqual(result, [10, 9, 7, 4, 0])\n * ```\n *\n * @category folding\n * @since 2.0.0\n */ const scanRight = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, b, f)=>{\n    const input = fromIterable(self);\n    const out = new Array(input.length + 1);\n    out[input.length] = b;\n    for(let i = input.length - 1; i >= 0; i--){\n        out[i] = f(out[i + 1], input[i]);\n    }\n    return out;\n});\n/**\n * Determine if `unknown` is an Array.\n *\n * @param self - The value to check.\n *\n * @example\n * ```ts\n * import { isArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isArray(null), false);\n * assert.deepStrictEqual(isArray([1, 2, 3]), true);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isArray = Array.isArray;\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * ```ts\n * import { isEmptyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isEmptyArray([]), true);\n * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isEmptyArray = (self)=>self.length === 0;\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * ```ts\n * import { isEmptyReadonlyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);\n * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isEmptyReadonlyArray = isEmptyArray;\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * ```ts\n * import { isNonEmptyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isNonEmptyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNonEmptyArray = _internal_array_js__WEBPACK_IMPORTED_MODULE_3__.isNonEmptyArray;\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * ```ts\n * import { isNonEmptyReadonlyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNonEmptyReadonlyArray = _internal_array_js__WEBPACK_IMPORTED_MODULE_3__.isNonEmptyArray;\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */ const length = (self)=>self.length;\nconst isOutOfBound = (i, as)=>i < 0 || i >= as.length;\nconst clamp = (i, as)=>Math.floor(Math.min(Math.max(0, i), as.length));\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */ const get = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, index)=>{\n    const i = Math.floor(index);\n    return isOutOfBound(i, self) ? _Option_js__WEBPACK_IMPORTED_MODULE_2__.none() : _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(self[i]);\n});\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 2.0.0\n * @category unsafe\n */ const unsafeGet = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, index)=>{\n    const i = Math.floor(index);\n    if (isOutOfBound(i, self)) {\n        throw new Error(`Index ${i} out of bounds`);\n    }\n    return self[i];\n});\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unprepend([1, 2, 3, 4])\n * assert.deepStrictEqual(result, [1, [2, 3, 4]])\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */ const unprepend = (self)=>[\n        headNonEmpty(self),\n        tailNonEmpty(self)\n    ];\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unappend([1, 2, 3, 4])\n * assert.deepStrictEqual(result, [[1, 2, 3], 4])\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */ const unappend = (self)=>[\n        initNonEmpty(self),\n        lastNonEmpty(self)\n    ];\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */ const head = /*#__PURE__*/ get(0);\n/**\n * Get the first element of a non empty array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.headNonEmpty([1, 2, 3, 4])\n * assert.deepStrictEqual(result, 1)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const headNonEmpty = /*#__PURE__*/ unsafeGet(0);\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */ const last = (self)=>isNonEmptyReadonlyArray(self) ? _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(lastNonEmpty(self)) : _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n/**\n * Get the last element of a non empty array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.lastNonEmpty([1, 2, 3, 4])\n * assert.deepStrictEqual(result, 4)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const lastNonEmpty = (self)=>self[self.length - 1];\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */ const tail = (self)=>{\n    const input = fromIterable(self);\n    return isNonEmptyReadonlyArray(input) ? _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(tailNonEmpty(input)) : _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n};\n/**\n * Get all but the first element of a `NonEmptyReadonlyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.tailNonEmpty([1, 2, 3, 4])\n * assert.deepStrictEqual(result, [2, 3, 4])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const tailNonEmpty = (self)=>self.slice(1);\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */ const init = (self)=>{\n    const input = fromIterable(self);\n    return isNonEmptyReadonlyArray(input) ? _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(initNonEmpty(input)) : _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n};\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.initNonEmpty([1, 2, 3, 4])\n * assert.deepStrictEqual(result, [1, 2, 3])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const initNonEmpty = (self)=>self.slice(0, -1);\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.take(numbers, 3)\n * assert.deepStrictEqual(result, [1, 2, 3])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const take = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    return input.slice(0, clamp(n, input));\n});\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.takeRight(numbers, 3)\n * assert.deepStrictEqual(result, [3, 4, 5])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const takeRight = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    const i = clamp(n, input);\n    return i === 0 ? [] : input.slice(-i);\n});\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 3, 2, 4, 1, 2]\n * const result = Array.takeWhile(numbers, x => x < 4)\n * assert.deepStrictEqual(result, [1, 3, 2])\n *\n * // Explanation:\n * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n * // - The next element (`3`) is also less than `4`, so it adds `3`.\n * // - The next element (`2`) is again less than `4`, so it adds `2`.\n * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const takeWhile = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    let i = 0;\n    const out = [];\n    for (const a of self){\n        if (!predicate(a, i)) {\n            break;\n        }\n        out.push(a);\n        i++;\n    }\n    return out;\n});\nconst spanIndex = (self, predicate)=>{\n    let i = 0;\n    for (const a of self){\n        if (!predicate(a, i)) {\n            break;\n        }\n        i++;\n    }\n    return i;\n};\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category splitting\n * @since 2.0.0\n */ const span = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>splitAt(self, spanIndex(self, predicate)));\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.drop(numbers, 2)\n * assert.deepStrictEqual(result, [3, 4, 5])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const drop = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    return input.slice(clamp(n, input), input.length);\n});\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.dropRight(numbers, 2)\n * assert.deepStrictEqual(result, [1, 2, 3])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const dropRight = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    return input.slice(0, input.length - clamp(n, input));\n});\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.dropWhile(numbers, x => x < 4)\n * assert.deepStrictEqual(result, [4, 5])\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const dropWhile = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>fromIterable(self).slice(spanIndex(self, predicate)));\n/**\n * Return the first index for which a predicate holds.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [5, 3, 8, 9]\n * const result = Array.findFirstIndex(numbers, x => x > 5)\n * assert.deepStrictEqual(result, Option.some(2))\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const findFirstIndex = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    let i = 0;\n    for (const a of self){\n        if (predicate(a, i)) {\n            return _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(i);\n        }\n        i++;\n    }\n    return _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n});\n/**\n * Return the last index for which a predicate holds.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 3, 8, 9]\n * const result = Array.findLastIndex(numbers, x => x < 5)\n * assert.deepStrictEqual(result, Option.some(1))\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const findLastIndex = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    const input = fromIterable(self);\n    for(let i = input.length - 1; i >= 0; i--){\n        if (predicate(input[i], i)) {\n            return _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(i);\n        }\n    }\n    return _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n});\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.findFirst(numbers, x => x > 3)\n * assert.deepStrictEqual(result, Option.some(4))\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const findFirst = _Iterable_js__WEBPACK_IMPORTED_MODULE_4__.findFirst;\n/**\n * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.findLast(numbers, n => n % 2 === 0)\n * assert.deepStrictEqual(result, Option.some(4))\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const findLast = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const input = fromIterable(self);\n    for(let i = input.length - 1; i >= 0; i--){\n        const a = input[i];\n        const o = f(a, i);\n        if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_5__.isBoolean)(o)) {\n            if (o) {\n                return _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(a);\n            }\n        } else {\n            if (_Option_js__WEBPACK_IMPORTED_MODULE_2__.isSome(o)) {\n                return o;\n            }\n        }\n    }\n    return _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n});\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const letters = ['a', 'b', 'c', 'e']\n * const result = Array.insertAt(letters, 3, 'd')\n * assert.deepStrictEqual(result, Option.some(['a', 'b', 'c', 'd', 'e']))\n * ```\n *\n * @since 2.0.0\n */ const insertAt = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, i, b)=>{\n    const out = Array.from(self);\n    //             v--- `= self.length` is ok, it means inserting in last position\n    if (i < 0 || i > out.length) {\n        return _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n    }\n    out.splice(i, 0, b);\n    return _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(out);\n});\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const letters = ['a', 'b', 'c', 'd']\n * const result = Array.replace(letters, 1, 'z')\n * assert.deepStrictEqual(result, ['a', 'z', 'c', 'd'])\n * ```\n *\n * @since 2.0.0\n */ const replace = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, i, b)=>modify(self, i, ()=>b));\n/**\n * Replaces an element in an array with the given value, returning an option of the updated array.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.replaceOption(numbers, 1, 4)\n * assert.deepStrictEqual(result, Option.some([1, 4, 3]))\n * ```\n *\n * @since 2.0.0\n */ const replaceOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, i, b)=>modifyOption(self, i, ()=>b));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.modify(numbers, 2, (n) => n * 2)\n * assert.deepStrictEqual(result, [1, 2, 6, 4])\n * ```\n *\n * @since 2.0.0\n */ const modify = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, i, f)=>_Option_js__WEBPACK_IMPORTED_MODULE_2__.getOrElse(modifyOption(self, i, f), ()=>Array.from(self)));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.modifyOption(numbers, 2, (n) => n * 2)\n * assert.deepStrictEqual(result, Option.some([1, 2, 6, 4]))\n *\n * const outOfBoundsResult = Array.modifyOption(numbers, 5, (n) => n * 2)\n * assert.deepStrictEqual(outOfBoundsResult, Option.none())\n * ```\n *\n * @since 2.0.0\n */ const modifyOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, i, f)=>{\n    const out = Array.from(self);\n    if (isOutOfBound(i, out)) {\n        return _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n    }\n    const next = f(out[i]);\n    // @ts-expect-error\n    out[i] = next;\n    return _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(out);\n});\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.remove(numbers, 2)\n * assert.deepStrictEqual(result, [1, 2, 4])\n *\n * const outOfBoundsResult = Array.remove(numbers, 5)\n * assert.deepStrictEqual(outOfBoundsResult, [1, 2, 3, 4])\n * ```\n *\n * @since 2.0.0\n */ const remove = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, i)=>{\n    const out = Array.from(self);\n    if (isOutOfBound(i, out)) {\n        return out;\n    }\n    out.splice(i, 1);\n    return out;\n});\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.reverse(numbers)\n * assert.deepStrictEqual(result, [4, 3, 2, 1])\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const reverse = (self)=>Array.from(self).reverse();\n/**\n * Create a new array with elements sorted in increasing order based on the specified comparator.\n * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n *\n * @category sorting\n * @since 2.0.0\n */ const sort = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, O)=>{\n    const out = Array.from(self);\n    out.sort(O);\n    return out;\n});\n/**\n * Sorts an array based on a provided mapping function and order. The mapping\n * function transforms the elements into a value that can be compared, and the\n * order defines how those values should be sorted.\n *\n * @example\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const strings = [\"aaa\", \"b\", \"cc\"]\n * const result = Array.sortWith(strings, (s) => s.length, Order.number)\n * assert.deepStrictEqual(result, [\"b\", \"cc\", \"aaa\"])\n *\n * // Explanation:\n * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n * // converts each string into its length, and the `Order.number` specifies that the lengths should\n * // be sorted in ascending order.\n * ```\n *\n * @since 2.0.0\n * @category elements\n */ const sortWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, f, order)=>Array.from(self).map((a)=>[\n            a,\n            f(a)\n        ]).sort((a, b)=>order(a[1], b[1])).map((x)=>x[0]));\n/**\n * Sorts the elements of an `Iterable` in increasing order based on the provided\n * orders. The elements are compared using the first order in `orders`, then the\n * second order if the first comparison is equal, and so on.\n *\n * @example\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const users = [\n *   { name: \"Alice\", age: 30 },\n *   { name: \"Bob\", age: 25 },\n *   { name: \"Charlie\", age: 30 }\n * ]\n *\n * const result = Array.sortBy(\n *   Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n *   Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n * )(users)\n *\n * assert.deepStrictEqual(result, [\n *   { name: \"Bob\", age: 25 },\n *   { name: \"Alice\", age: 30 },\n *   { name: \"Charlie\", age: 30 }\n * ])\n *\n * // Explanation:\n * // The array of users is sorted first by age in ascending order. When ages are equal,\n * // the users are further sorted by name in ascending order.\n * ```\n *\n * @category sorting\n * @since 2.0.0\n */ const sortBy = (...orders)=>{\n    const sortByAll = sort(_Order_js__WEBPACK_IMPORTED_MODULE_6__.combineAll(orders));\n    return (self)=>{\n        const input = fromIterable(self);\n        if (isNonEmptyReadonlyArray(input)) {\n            return sortByAll(input);\n        }\n        return [];\n    };\n};\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = ['a', 'b']\n * const result = Array.zip(array1, array2)\n * assert.deepStrictEqual(result, [[1, 'a'], [2, 'b']])\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */ const zip = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>zipWith(self, that, _Tuple_js__WEBPACK_IMPORTED_MODULE_7__.make));\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [4, 5, 6]\n * const result = Array.zipWith(array1, array2, (a, b) => a + b)\n * assert.deepStrictEqual(result, [5, 7, 9])\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */ const zipWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, f)=>{\n    const as = fromIterable(self);\n    const bs = fromIterable(that);\n    if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {\n        const out = [\n            f(headNonEmpty(as), headNonEmpty(bs))\n        ];\n        const len = Math.min(as.length, bs.length);\n        for(let i = 1; i < len; i++){\n            out[i] = f(as[i], bs[i]);\n        }\n        return out;\n    }\n    return [];\n});\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\n * assert.deepStrictEqual(result, [[1, 2, 3], ['a', 'b', 'c']])\n * ```\n *\n * @since 2.0.0\n */ const unzip = (self)=>{\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n        const fa = [\n            input[0][0]\n        ];\n        const fb = [\n            input[0][1]\n        ];\n        for(let i = 1; i < input.length; i++){\n            fa[i] = input[i][0];\n            fb[i] = input[i][1];\n        }\n        return [\n            fa,\n            fb\n        ];\n    }\n    return [\n        [],\n        []\n    ];\n};\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.intersperse(numbers, 0)\n * assert.deepStrictEqual(result, [1, 0, 2, 0, 3])\n * ```\n *\n * @since 2.0.0\n */ const intersperse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, middle)=>{\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n        const out = [\n            headNonEmpty(input)\n        ];\n        const tail = tailNonEmpty(input);\n        for(let i = 0; i < tail.length; i++){\n            if (i < tail.length) {\n                out.push(middle);\n            }\n            out.push(tail[i]);\n        }\n        return out;\n    }\n    return [];\n});\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n * assert.deepStrictEqual(result, [10, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const modifyNonEmptyHead = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>[\n        f(headNonEmpty(self)),\n        ...tailNonEmpty(self)\n    ]);\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n * assert.deepStrictEqual(result, [10, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const setNonEmptyHead = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, b)=>modifyNonEmptyHead(self, ()=>b));\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n * assert.deepStrictEqual(result, [1, 2, 6])\n * ```\n *\n * @since 2.0.0\n */ const modifyNonEmptyLast = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>append(initNonEmpty(self), f(lastNonEmpty(self))));\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n * assert.deepStrictEqual(result, [1, 2, 4])\n * ```\n *\n * @since 2.0.0\n */ const setNonEmptyLast = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, b)=>modifyNonEmptyLast(self, ()=>b));\n/**\n * Rotate an `Iterable` by `n` steps.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const letters = ['a', 'b', 'c', 'd']\n * const result = Array.rotate(letters, 2)\n * assert.deepStrictEqual(result, ['c', 'd', 'a', 'b'])\n * ```\n *\n * @since 2.0.0\n */ const rotate = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n        const len = input.length;\n        const m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), input) || m === 0) {\n            return copy(input);\n        }\n        if (m < 0) {\n            const [f, s] = splitNonEmptyAt(input, -m);\n            return appendAll(s, f);\n        } else {\n            return rotate(self, m - len);\n        }\n    }\n    return [];\n});\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const isEquivalent = (a: number, b: number) => a === b\n * const containsNumber = Array.containsWith(isEquivalent)\n * const result = containsNumber(3)(numbers)\n * assert.deepStrictEqual(result, true)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const containsWith = (isEquivalent)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, a)=>{\n        for (const i of self){\n            if (isEquivalent(a, i)) {\n                return true;\n            }\n        }\n        return false;\n    });\nconst _equivalence = /*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_8__.equivalence();\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const letters = ['a', 'b', 'c', 'd']\n * const result = Array.contains('c')(letters)\n * assert.deepStrictEqual(result, true)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const contains = /*#__PURE__*/ containsWith(_equivalence);\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.chop(numbers, (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n * assert.deepStrictEqual(result, [2, 4, 6, 8, 10])\n *\n * // Explanation:\n * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n * // resulting in a new array `[2, 4, 6, 8, 10]`.\n * ```\n *\n * @since 2.0.0\n */ const chop = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n        const [b, rest] = f(input);\n        const out = [\n            b\n        ];\n        let next = rest;\n        while(_internal_array_js__WEBPACK_IMPORTED_MODULE_3__.isNonEmptyArray(next)){\n            const [b, rest] = f(next);\n            out.push(b);\n            next = rest;\n        }\n        return out;\n    }\n    return [];\n});\n/**\n * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` can be `0`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.splitAt(numbers, 3)\n * assert.deepStrictEqual(result, [[1, 2, 3], [4, 5]])\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */ const splitAt = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = Array.from(self);\n    const _n = Math.floor(n);\n    if (isNonEmptyReadonlyArray(input)) {\n        if (_n >= 1) {\n            return splitNonEmptyAt(input, _n);\n        }\n        return [\n            [],\n            input\n        ];\n    }\n    return [\n        input,\n        []\n    ];\n});\n/**\n * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n * assert.deepStrictEqual(result, [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]])\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */ const splitNonEmptyAt = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const _n = Math.max(1, Math.floor(n));\n    return _n >= self.length ? [\n        copy(self),\n        []\n    ] : [\n        prepend(self.slice(1, _n), headNonEmpty(self)),\n        self.slice(_n)\n    ];\n});\n/**\n * Splits this iterable into `n` equally sized arrays.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5, 6, 7, 8]\n * const result = Array.split(numbers, 3)\n * assert.deepStrictEqual(result, [[1, 2, 3], [4, 5, 6], [7, 8]])\n * ```\n *\n * @since 2.0.0\n * @category splitting\n */ const split = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    return chunksOf(input, Math.ceil(input.length / Math.floor(n)));\n});\n/**\n * Splits this iterable on the first element that matches this predicate.\n * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.splitWhere(numbers, n => n > 3)\n * assert.deepStrictEqual(result, [[1, 2, 3], [4, 5]])\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */ const splitWhere = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>span(self, (a, i)=>!predicate(a, i)));\n/**\n * Copies an array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const copy = Array.copy(numbers)\n * assert.deepStrictEqual(copy, [1, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const copy = (self)=>self.slice();\n/**\n * Pads an array.\n * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n * If `n` is less than or equal to 0, the returned array will be an empty array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const arr = [1, 2, 3]\n * const result = Array.pad(arr, 6, 0)\n * assert.deepStrictEqual(result, [1, 2, 3, 0, 0, 0])\n * ```\n *\n * @since 3.8.4\n */ const pad = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, n, fill)=>{\n    if (self.length >= n) {\n        return take(self, n);\n    }\n    return appendAll(self, makeBy(n - self.length, ()=>fill));\n});\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const result = Array.chunksOf(numbers, 2)\n * assert.deepStrictEqual(result, [[1, 2], [3, 4], [5]])\n *\n * // Explanation:\n * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n * // the last chunk contains the remaining elements.\n * // The result is `[[1, 2], [3, 4], [5]]`.\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */ const chunksOf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n        return chop(input, splitNonEmptyAt(n));\n    }\n    return [];\n});\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n * assert.deepStrictEqual(result, [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]])\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */ const groupWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, isEquivalent)=>chop(self, (as)=>{\n        const h = headNonEmpty(as);\n        const out = [\n            h\n        ];\n        let i = 1;\n        for(; i < as.length; i++){\n            const a = as[i];\n            if (isEquivalent(a, h)) {\n                out.push(a);\n            } else {\n                break;\n            }\n        }\n        return [\n            out,\n            as.slice(i)\n        ];\n    }));\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.group([1, 1, 2, 2, 2, 3, 1])\n * assert.deepStrictEqual(result, [[1, 1], [2, 2, 2], [3], [1]])\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */ const group = /*#__PURE__*/ groupWith(/*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_8__.equivalence());\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const people = [\n *   { name: \"Alice\", group: \"A\" },\n *   { name: \"Bob\", group: \"B\" },\n *   { name: \"Charlie\", group: \"A\" }\n * ]\n * const result = Array.groupBy(people, person => person.group)\n * assert.deepStrictEqual(result, {\n *   A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n *   B: [{ name: \"Bob\", group: \"B\" }]\n * })\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */ const groupBy = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = {};\n    for (const a of self){\n        const k = f(a);\n        if (Object.prototype.hasOwnProperty.call(out, k)) {\n            out[k].push(a);\n        } else {\n            out[k] = [\n                a\n            ];\n        }\n    }\n    return out;\n});\n/**\n * Calculates the union of two arrays using the provided equivalence relation.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2]\n * const array2 = [2, 3]\n * const union = Array.unionWith(array1, array2, (a, b) => a === b)\n * assert.deepStrictEqual(union, [1, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const unionWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, isEquivalent)=>{\n    const a = fromIterable(self);\n    const b = fromIterable(that);\n    if (isNonEmptyReadonlyArray(a)) {\n        if (isNonEmptyReadonlyArray(b)) {\n            const dedupe = dedupeWith(isEquivalent);\n            return dedupe(appendAll(a, b));\n        }\n        return a;\n    }\n    return b;\n});\n/**\n * Creates a union of two arrays, removing duplicates.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2]\n * const array2 = [2, 3]\n * const result = Array.union(array1, array2)\n * assert.deepStrictEqual(result, [1, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const union = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>unionWith(self, that, _equivalence));\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\n * const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\n * const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\n * const result = Array.intersectionWith(isEquivalent)(array2)(array1)\n * assert.deepStrictEqual(result, [{ id: 1 }, { id: 3 }])\n * ```\n *\n * @since 2.0.0\n */ const intersectionWith = (isEquivalent)=>{\n    const has = containsWith(isEquivalent);\n    return (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>fromIterable(self).filter((a)=>has(that, a)));\n};\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [3, 4, 1]\n * const result = Array.intersection(array1, array2)\n * assert.deepStrictEqual(result, [1, 3])\n * ```\n *\n * @since 2.0.0\n */ const intersection = /*#__PURE__*/ intersectionWith(_equivalence);\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [2, 3, 4]\n * const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\n * assert.deepStrictEqual(difference, [1])\n * ```\n *\n * @since 2.0.0\n */ const differenceWith = (isEquivalent)=>{\n    const has = containsWith(isEquivalent);\n    return (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>fromIterable(self).filter((a)=>!has(that, a)));\n};\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [2, 3, 4]\n * const difference = Array.difference(array1, array2)\n * assert.deepStrictEqual(difference, [1])\n * ```\n *\n * @since 2.0.0\n */ const difference = /*#__PURE__*/ differenceWith(_equivalence);\n/**\n * @category constructors\n * @since 2.0.0\n */ const empty = ()=>[];\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */ const of = (a)=>[\n        a\n    ];\n/**\n * @category mapping\n * @since 2.0.0\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>self.map(f));\n/**\n * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    if (isEmptyReadonlyArray(self)) {\n        return [];\n    }\n    const out = [];\n    for(let i = 0; i < self.length; i++){\n        const inner = f(self[i], i);\n        for(let j = 0; j < inner.length; j++){\n            out.push(inner[j]);\n        }\n    }\n    return out;\n});\n/**\n * Combines multiple arrays into a single array by concatenating all elements\n * from each nested array. This function ensures that the structure of nested\n * arrays is collapsed into a single, flat array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\";\n *\n * const nestedArrays = [[1, 2], [], [3, 4], [], [5, 6]]\n * const result = Array.flatten(nestedArrays)\n *\n * assert.deepStrictEqual(result, [1, 2, 3, 4, 5, 6]);\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatten = /*#__PURE__*/ flatMap(_Function_js__WEBPACK_IMPORTED_MODULE_0__.identity);\n/**\n * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\";\n *\n * const data = [1, 2, 3, 4, 5];\n * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none();\n * const result = Array.filterMap(data, evenSquares);\n *\n * assert.deepStrictEqual(result, [4, 16]);\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const filterMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const as = fromIterable(self);\n    const out = [];\n    for(let i = 0; i < as.length; i++){\n        const o = f(as[i], i);\n        if (_Option_js__WEBPACK_IMPORTED_MODULE_2__.isSome(o)) {\n            out.push(o.value);\n        }\n    }\n    return out;\n});\n/**\n * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\";\n *\n * const data = [2, 4, 5];\n * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none();\n * const result = Array.filterMapWhile(data, toSquareTillOdd);\n *\n * assert.deepStrictEqual(result, [4, 16]);\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const filterMapWhile = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    let i = 0;\n    const out = [];\n    for (const a of self){\n        const b = f(a, i);\n        if (_Option_js__WEBPACK_IMPORTED_MODULE_2__.isSome(b)) {\n            out.push(b.value);\n        } else {\n            break;\n        }\n        i++;\n    }\n    return out;\n});\n/**\n * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n * This function is particularly useful for operations where each element can result in two possible types,\n * and you want to separate these types into different collections. For instance, separating validation results\n * into successes and failures.\n *\n * @example\n * ```ts\n * import { Array, Either } from \"effect\";\n *\n * const data = [1, 2, 3, 4, 5]\n * const isEven = (x: number) => x % 2 === 0\n * const partitioned = Array.partitionMap(data, x =>\n *   isEven(x) ? Either.right(x) : Either.left(x)\n * )\n *\n * assert.deepStrictEqual(partitioned, [\n *   [1, 3, 5],\n *   [2, 4]\n * ])\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const partitionMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const left = [];\n    const right = [];\n    const as = fromIterable(self);\n    for(let i = 0; i < as.length; i++){\n        const e = f(as[i], i);\n        if (_Either_js__WEBPACK_IMPORTED_MODULE_9__.isLeft(e)) {\n            left.push(e.left);\n        } else {\n            right.push(e.right);\n        }\n    }\n    return [\n        left,\n        right\n    ];\n});\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n *\n * @example\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.getSomes([Option.some(1), Option.none(), Option.some(2)]),\n *   [1, 2]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getSomes = /*#__PURE__*/ filterMap(_Function_js__WEBPACK_IMPORTED_MODULE_0__.identity);\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * @example\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)]),\n *   [\"err\"]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getLefts = (self)=>{\n    const out = [];\n    for (const a of self){\n        if (_Either_js__WEBPACK_IMPORTED_MODULE_9__.isLeft(a)) {\n            out.push(a.left);\n        }\n    }\n    return out;\n};\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * @example\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)]),\n *   [1, 2]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getRights = (self)=>{\n    const out = [];\n    for (const a of self){\n        if (_Either_js__WEBPACK_IMPORTED_MODULE_9__.isRight(a)) {\n            out.push(a.right);\n        }\n    }\n    return out;\n};\n/**\n * @category filtering\n * @since 2.0.0\n */ const filter = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    const as = fromIterable(self);\n    const out = [];\n    for(let i = 0; i < as.length; i++){\n        if (predicate(as[i], i)) {\n            out.push(as[i]);\n        }\n    }\n    return out;\n});\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */ const partition = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    const left = [];\n    const right = [];\n    const as = fromIterable(self);\n    for(let i = 0; i < as.length; i++){\n        if (predicate(as[i], i)) {\n            right.push(as[i]);\n        } else {\n            left.push(as[i]);\n        }\n    }\n    return [\n        left,\n        right\n    ];\n});\n/**\n * Separates an `Iterable` into two arrays based on a predicate.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const result = Array.partition(numbers, n => n % 2 === 0)\n * assert.deepStrictEqual(result, [[1, 3], [2, 4]])\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const separate = /*#__PURE__*/ partitionMap(_Function_js__WEBPACK_IMPORTED_MODULE_0__.identity);\n/**\n * Reduces an array from the left.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.reduce(numbers, 0, (acc, n) => acc + n)\n * assert.deepStrictEqual(result, 6)\n * ```\n *\n * @category folding\n * @since 2.0.0\n */ const reduce = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, b, f)=>fromIterable(self).reduce((b, a, i)=>f(b, a, i), b));\n/**\n * Reduces an array from the right.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.reduceRight(numbers, 0, (acc, n) => acc + n)\n * assert.deepStrictEqual(result, 6)\n * ```\n *\n * @category folding\n * @since 2.0.0\n */ const reduceRight = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, b, f)=>fromIterable(self).reduceRight((b, a, i)=>f(b, a, i), b));\n/**\n * Lifts a predicate into an array.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n * const to = Array.liftPredicate(isEven)\n * assert.deepStrictEqual(to(1), [])\n * assert.deepStrictEqual(to(2), [2])\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */ const liftPredicate = (predicate)=>(b)=>predicate(b) ? [\n            b\n        ] : [];\n/**\n * @category lifting\n * @since 2.0.0\n */ const liftOption = (f)=>(...a)=>fromOption(f(...a));\n/**\n * @category conversions\n * @since 2.0.0\n */ const fromNullable = (a)=>a == null ? empty() : [\n        a\n    ];\n/**\n * @category lifting\n * @since 2.0.0\n */ const liftNullable = (f)=>(...a)=>fromNullable(f(...a));\n/**\n * Maps over an array and flattens the result, removing null and undefined values.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.flatMapNullable(numbers, n => (n % 2 === 0 ? null : n))\n * assert.deepStrictEqual(result, [1, 3])\n *\n * // Explanation:\n * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n * // to remove null values, resulting in [1, 3].\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatMapNullable = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>flatMap(self, (a)=>fromNullable(f(a))));\n/**\n * Lifts a function that returns an `Either` into a function that returns an array.\n * If the `Either` is a left, it returns an empty array.\n * If the `Either` is a right, it returns an array with the right value.\n *\n * @example\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const parseNumber = (s: string): Either.Either<number, Error> =>\n *   isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n *\n * const liftedParseNumber = Array.liftEither(parseNumber)\n *\n * const result1 = liftedParseNumber(\"42\")\n * assert.deepStrictEqual(result1, [42])\n *\n * const result2 = liftedParseNumber(\"not a number\")\n * assert.deepStrictEqual(result2, [])\n *\n * // Explanation:\n * // The function parseNumber is lifted to return an array.\n * // When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n * // When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array [].\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */ const liftEither = (f)=>(...a)=>{\n        const e = f(...a);\n        return _Either_js__WEBPACK_IMPORTED_MODULE_9__.isLeft(e) ? [] : [\n            e.right\n        ];\n    };\n/**\n * Check if a predicate holds true for every `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */ const every = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, refinement)=>self.every(refinement));\n/**\n * Check if a predicate holds true for some `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */ const some = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>self.some(predicate));\n/**\n * Extends an array with a function that maps each subarray to a value.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.extend(numbers, as => as.length)\n * assert.deepStrictEqual(result, [3, 2, 1])\n *\n * // Explanation:\n * // The function maps each subarray starting from each element to its length.\n * // The subarrays are: [1, 2, 3], [2, 3], [3].\n * // The lengths are: 3, 2, 1.\n * // Therefore, the result is [3, 2, 1].\n * ```\n *\n * @since 2.0.0\n */ const extend = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>self.map((_, i, as)=>f(as.slice(i))));\n/**\n * Finds the minimum element in an array based on a comparator.\n *\n * @example\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const min = Array.min([3, 1, 2], Order.number)\n * assert.deepStrictEqual(min, 1)\n * ```\n *\n * @since 2.0.0\n */ const min = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, O)=>self.reduce(_Order_js__WEBPACK_IMPORTED_MODULE_6__.min(O)));\n/**\n * Finds the maximum element in an array based on a comparator.\n *\n * @example\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const max = Array.max([3, 1, 2], Order.number)\n * assert.deepStrictEqual(max, 3)\n * ```\n *\n * @since 2.0.0\n */ const max = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, O)=>self.reduce(_Order_js__WEBPACK_IMPORTED_MODULE_6__.max(O)));\n/**\n * @category constructors\n * @since 2.0.0\n */ const unfold = (b, f)=>{\n    const out = [];\n    let next = b;\n    let o;\n    while(_Option_js__WEBPACK_IMPORTED_MODULE_2__.isSome(o = f(next))){\n        const [a, b] = o.value;\n        out.push(a);\n        next = b;\n    }\n    return out;\n};\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 2.0.0\n */ const getOrder = _Order_js__WEBPACK_IMPORTED_MODULE_6__.array;\n/**\n * Creates an equivalence relation for arrays.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers1 = [1, 2, 3]\n * const numbers2 = [1, 2, 3]\n * const eq = Array.getEquivalence<number>((a, b) => a === b)\n * assert.deepStrictEqual(eq(numbers1, numbers2), true)\n * ```\n *\n * @category instances\n * @since 2.0.0\n */ const getEquivalence = _Equivalence_js__WEBPACK_IMPORTED_MODULE_10__.array;\n/**\n * Performs a side-effect for each element of the `Iterable`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * Array.forEach(numbers, n => console.log(n)) // 1, 2, 3\n * ```\n *\n * @since 2.0.0\n */ const forEach = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>fromIterable(self).forEach((a, i)=>f(a, i)));\n/**\n * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n * preserving the order of the first occurrence of each element.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 2, 3, 3, 3]\n * const unique = Array.dedupeWith(numbers, (a, b) => a === b)\n * assert.deepStrictEqual(unique, [1, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const dedupeWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, isEquivalent)=>{\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n        const out = [\n            headNonEmpty(input)\n        ];\n        const rest = tailNonEmpty(input);\n        for (const r of rest){\n            if (out.every((a)=>!isEquivalent(r, a))) {\n                out.push(r);\n            }\n        }\n        return out;\n    }\n    return [];\n});\n/**\n * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\n * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.\n *\n * @since 2.0.0\n */ const dedupe = (self)=>dedupeWith(self, _Equal_js__WEBPACK_IMPORTED_MODULE_8__.equivalence());\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 1, 2, 2, 3, 3]\n * const unique = Array.dedupeAdjacentWith(numbers, (a, b) => a === b)\n * assert.deepStrictEqual(unique, [1, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const dedupeAdjacentWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, isEquivalent)=>{\n    const out = [];\n    let lastA = _Option_js__WEBPACK_IMPORTED_MODULE_2__.none();\n    for (const a of self){\n        if (_Option_js__WEBPACK_IMPORTED_MODULE_2__.isNone(lastA) || !isEquivalent(a, lastA.value)) {\n            out.push(a);\n            lastA = _Option_js__WEBPACK_IMPORTED_MODULE_2__.some(a);\n        }\n    }\n    return out;\n});\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 1, 2, 2, 3, 3]\n * const unique = Array.dedupeAdjacent(numbers)\n * assert.deepStrictEqual(unique, [1, 2, 3])\n * ```\n *\n * @since 2.0.0\n */ const dedupeAdjacent = /*#__PURE__*/ dedupeAdjacentWith(/*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_8__.equivalence());\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const strings = [\"a\", \"b\", \"c\"]\n * const joined = Array.join(strings, \"-\")\n * assert.deepStrictEqual(joined, \"a-b-c\")\n * ```\n *\n * @since 2.0.0\n * @category folding\n */ const join = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, sep)=>fromIterable(self).join(sep));\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const numbers = [1, 2, 3]\n * const result = Array.mapAccum(numbers, 0, (acc, n) => [acc + n, acc + n])\n * assert.deepStrictEqual(result, [6, [1, 3, 6]])\n * ```\n *\n * @since 2.0.0\n * @category folding\n */ const mapAccum = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, s, f)=>{\n    let i = 0;\n    let s1 = s;\n    const out = [];\n    for (const a of self){\n        const r = f(s1, a, i);\n        s1 = r[0];\n        out.push(r[1]);\n        i++;\n    }\n    return [\n        s1,\n        out\n    ];\n});\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2]\n * const array2 = [\"a\", \"b\"]\n * const product = Array.cartesianWith(array1, array2, (a, b) => `${a}-${b}`)\n * assert.deepStrictEqual(product, [\"1-a\", \"1-b\", \"2-a\", \"2-b\"])\n * ```\n *\n * @since 2.0.0\n * @category elements\n */ const cartesianWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, f)=>flatMap(self, (a)=>map(that, (b)=>f(a, b))));\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * @example\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2]\n * const array2 = [\"a\", \"b\"]\n * const product = Array.cartesian(array1, array2)\n * assert.deepStrictEqual(product, [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]])\n * ```\n *\n * @since 2.0.0\n * @category elements\n */ const cartesian = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>cartesianWith(self, that, (a, b)=>[\n            a,\n            b\n        ]));\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Array as Arr, pipe } from \"effect\"\n * const doResult = pipe(\n *   Arr.Do,\n *   Arr.bind(\"x\", () => [1, 3, 5]),\n *   Arr.bind(\"y\", () => [2, 4, 6]),\n *   Arr.filter(({ x, y }) => x < y), // condition\n *   Arr.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * assert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @category do notation\n * @since 3.2.0\n */ const Do = /*#__PURE__*/ of({});\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Array as Arr, pipe } from \"effect\"\n * const doResult = pipe(\n *   Arr.Do,\n *   Arr.bind(\"x\", () => [1, 3, 5]),\n *   Arr.bind(\"y\", () => [2, 4, 6]),\n *   Arr.filter(({ x, y }) => x < y), // condition\n *   Arr.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * assert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @category do notation\n * @since 3.2.0\n */ const bind = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__.bind(map, flatMap);\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Array as Arr, pipe } from \"effect\"\n * const doResult = pipe(\n *   Arr.Do,\n *   Arr.bind(\"x\", () => [1, 3, 5]),\n *   Arr.bind(\"y\", () => [2, 4, 6]),\n *   Arr.filter(({ x, y }) => x < y), // condition\n *   Arr.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * assert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @category do notation\n * @since 3.2.0\n */ const bindTo = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__.bindTo(map);\nconst let_ = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_11__.let_(map);\n //# sourceMappingURL=Array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNnQztBQUNHO0FBQ1k7QUFDRDtBQUNNO0FBQ0U7QUFDUDtBQUNmO0FBQ0c7QUFDTztBQUNMO0FBQ0Y7QUFDcEM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1hLE9BQU8sQ0FBQyxHQUFHQyxXQUFhQSxTQUFTO0FBQzlDOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNQyxXQUFXQyxDQUFBQSxJQUFLLElBQUlDLE1BQU1ELEdBQUc7QUFDMUM7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxNQUFNRSxTQUFTLENBQUNGLEdBQUdHO0lBQ3hCLE1BQU1DLE1BQU1DLEtBQUtELEdBQUcsQ0FBQyxHQUFHQyxLQUFLQyxLQUFLLENBQUNOO0lBQ25DLE1BQU1PLE1BQU0sSUFBSU4sTUFBTUc7SUFDdEIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlKLEtBQUtJLElBQUs7UUFDNUJELEdBQUcsQ0FBQ0MsRUFBRSxHQUFHTCxFQUFFSztJQUNiO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTUUsUUFBUSxDQUFDQyxPQUFPQyxNQUFRRCxTQUFTQyxNQUFNVCxPQUFPUyxNQUFNRCxRQUFRLEdBQUdGLENBQUFBLElBQUtFLFFBQVFGLEtBQUs7UUFBQ0U7S0FBTSxDQUFDO0FBQ3RHOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTUUsWUFBWSxXQUFXLEdBQUV6QixrREFBSUEsQ0FBQyxHQUFHLENBQUMwQixHQUFHYixJQUFNRSxPQUFPRixHQUFHLElB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0Q0MsR0FDTSxNQUFNZ0QsT0FBTyxXQUFXLEdBQUVyTiwwREFBZSxDQUFDeUcsS0FBSzZELFNBQVM7QUFDL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENDLEdBQ00sTUFBTWdELFNBQVMsV0FBVyxHQUFFdE4sNERBQWlCLENBQUN5RyxLQUFLO0FBQzFELE1BQU04RyxPQUFPLFdBQVcsR0FBRXZOLDBEQUFlLENBQUN5RztBQStDNUIsQ0FDZCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0FycmF5LmpzP2MwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIGFycmF5cyBpbiBUeXBlU2NyaXB0LlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgKiBhcyBFIGZyb20gXCIuL0VpdGhlci5qc1wiO1xuaW1wb3J0ICogYXMgRXF1YWwgZnJvbSBcIi4vRXF1YWwuanNcIjtcbmltcG9ydCAqIGFzIEVxdWl2YWxlbmNlIGZyb20gXCIuL0VxdWl2YWxlbmNlLmpzXCI7XG5pbXBvcnQgeyBkdWFsLCBpZGVudGl0eSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyByZWFkb25seUFycmF5IGZyb20gXCIuL2ludGVybmFsL2FycmF5LmpzXCI7XG5pbXBvcnQgKiBhcyBkb05vdGF0aW9uIGZyb20gXCIuL2ludGVybmFsL2RvTm90YXRpb24uanNcIjtcbmltcG9ydCAqIGFzIEVmZmVjdEl0ZXJhYmxlIGZyb20gXCIuL0l0ZXJhYmxlLmpzXCI7XG5pbXBvcnQgKiBhcyBPIGZyb20gXCIuL09wdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgT3JkZXIgZnJvbSBcIi4vT3JkZXIuanNcIjtcbmltcG9ydCB7IGlzQm9vbGVhbiB9IGZyb20gXCIuL1ByZWRpY2F0ZS5qc1wiO1xuaW1wb3J0ICogYXMgUmVjb3JkIGZyb20gXCIuL1JlY29yZC5qc1wiO1xuaW1wb3J0ICogYXMgVHVwbGUgZnJvbSBcIi4vVHVwbGUuanNcIjtcbi8qKlxuICogQnVpbGRzIGEgYE5vbkVtcHR5QXJyYXlgIGZyb20gYW4gbm9uLWVtcHR5IGNvbGxlY3Rpb24gb2YgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5Lm1ha2UoMSwgMiwgMylcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1ha2UgPSAoLi4uZWxlbWVudHMpID0+IGVsZW1lbnRzO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheWAgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmFsbG9jYXRlPG51bWJlcj4oMylcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0Lmxlbmd0aCwgMylcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWxsb2NhdGUgPSBuID0+IG5ldyBBcnJheShuKTtcbi8qKlxuICogUmV0dXJuIGEgYE5vbkVtcHR5QXJyYXlgIG9mIGxlbmd0aCBgbmAgd2l0aCBlbGVtZW50IGBpYCBpbml0aWFsaXplZCB3aXRoIGBmKGkpYC5cbiAqXG4gKiAqKk5vdGUqKi4gYG5gIGlzIG5vcm1hbGl6ZWQgdG8gYW4gaW50ZWdlciA+PSAxLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFrZUJ5IH0gZnJvbSBcImVmZmVjdC9BcnJheVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtYWtlQnkoNSwgbiA9PiBuICogMiksIFswLCAyLCA0LCA2LCA4XSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFrZUJ5ID0gKG4sIGYpID0+IHtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihuKSk7XG4gIGNvbnN0IG91dCA9IG5ldyBBcnJheShtYXgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgb3V0W2ldID0gZihpKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogUmV0dXJuIGEgYE5vbkVtcHR5QXJyYXlgIGNvbnRhaW5pbmcgYSByYW5nZSBvZiBpbnRlZ2VycywgaW5jbHVkaW5nIGJvdGggZW5kcG9pbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcmFuZ2UgfSBmcm9tIFwiZWZmZWN0L0FycmF5XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJhbmdlKDEsIDMpLCBbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHJhbmdlID0gKHN0YXJ0LCBlbmQpID0+IHN0YXJ0IDw9IGVuZCA/IG1ha2VCeShlbmQgLSBzdGFydCArIDEsIGkgPT4gc3RhcnQgKyBpKSA6IFtzdGFydF07XG4vKipcbiAqIFJldHVybiBhIGBOb25FbXB0eUFycmF5YCBjb250YWluaW5nIGEgdmFsdWUgcmVwZWF0ZWQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gKlxuICogKipOb3RlKiouIGBuYCBpcyBub3JtYWxpemVkIHRvIGFuIGludGVnZXIgPj0gMS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChBcnJheS5yZXBsaWNhdGUoXCJhXCIsIDMpLCBbXCJhXCIsIFwiYVwiLCBcImFcIl0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxpY2F0ZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChhLCBuKSA9PiBtYWtlQnkobiwgKCkgPT4gYSkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheWAgZnJvbSBhbiBpdGVyYWJsZSBjb2xsZWN0aW9uIG9mIHZhbHVlcy5cbiAqIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGFuIGFycmF5LCBpdCByZXR1cm5zIHRoZSBpbnB1dCBhcy1pcy5cbiAqIE90aGVyd2lzZSwgaXQgY29udmVydHMgdGhlIGl0ZXJhYmxlIGNvbGxlY3Rpb24gdG8gYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHNldCA9IG5ldyBTZXQoWzEsIDIsIDNdKVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuZnJvbUl0ZXJhYmxlKHNldClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21JdGVyYWJsZSA9IGNvbGxlY3Rpb24gPT4gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiBBcnJheS5mcm9tKGNvbGxlY3Rpb24pO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheWAgZnJvbSBhIHZhbHVlIHRoYXQgbWlnaHQgbm90IGJlIGFuIGl0ZXJhYmxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEFycmF5LmVuc3VyZShcImFcIiksIFtcImFcIl0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEFycmF5LmVuc3VyZShbXCJhXCJdKSwgW1wiYVwiXSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQXJyYXkuZW5zdXJlKFtcImFcIiwgXCJiXCIsIFwiY1wiXSksIFtcImFcIiwgXCJiXCIsIFwiY1wiXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAzLjMuMFxuICovXG5leHBvcnQgY29uc3QgZW5zdXJlID0gc2VsZiA9PiBBcnJheS5pc0FycmF5KHNlbGYpID8gc2VsZiA6IFtzZWxmXTtcbi8qKlxuICogVGFrZXMgYSByZWNvcmQgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdHVwbGVzIGNvbnRhaW5pbmcgaXRzIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gdHJhbnNmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCB4ID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQXJyYXkuZnJvbVJlY29yZCh4KSwgW1tcImFcIiwgMV0sIFtcImJcIiwgMl0sIFtcImNcIiwgM11dKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21SZWNvcmQgPSBSZWNvcmQudG9FbnRyaWVzO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBgT3B0aW9uYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEFycmF5LmZyb21PcHRpb24oT3B0aW9uLnNvbWUoMSkpLCBbMV0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEFycmF5LmZyb21PcHRpb24oT3B0aW9uLm5vbmUoKSksIFtdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21PcHRpb24gPSBPLnRvQXJyYXk7XG4vKipcbiAqIE1hdGNoZXMgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5LCBhcHBseWluZyBmdW5jdGlvbnMgdG8gY2FzZXMgb2YgZW1wdHkgYW5kIG5vbi1lbXB0eSBhcnJheXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG1hdGNoID0gQXJyYXkubWF0Y2goe1xuICogICBvbkVtcHR5OiAoKSA9PiBcImVtcHR5XCIsXG4gKiAgIG9uTm9uRW1wdHk6IChbaGVhZCwgLi4udGFpbF0pID0+IGBoZWFkOiAke2hlYWR9LCB0YWlsOiAke3RhaWwubGVuZ3RofWBcbiAqIH0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hdGNoKFtdKSwgXCJlbXB0eVwiKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtYXRjaChbMSwgMiwgM10pLCBcImhlYWQ6IDEsIHRhaWw6IDJcIilcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHtcbiAgb25FbXB0eSxcbiAgb25Ob25FbXB0eVxufSkgPT4gaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoc2VsZikgPyBvbk5vbkVtcHR5KHNlbGYpIDogb25FbXB0eSgpKTtcbi8qKlxuICogTWF0Y2hlcyB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgZnJvbSB0aGUgbGVmdCwgYXBwbHlpbmcgZnVuY3Rpb25zIHRvIGNhc2VzIG9mIGVtcHR5IGFuZCBub24tZW1wdHkgYXJyYXlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBtYXRjaExlZnQgPSBBcnJheS5tYXRjaExlZnQoe1xuICogICBvbkVtcHR5OiAoKSA9PiBcImVtcHR5XCIsXG4gKiAgIG9uTm9uRW1wdHk6IChoZWFkLCB0YWlsKSA9PiBgaGVhZDogJHtoZWFkfSwgdGFpbDogJHt0YWlsLmxlbmd0aH1gXG4gKiB9KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtYXRjaExlZnQoW10pLCBcImVtcHR5XCIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hdGNoTGVmdChbMSwgMiwgM10pLCBcImhlYWQ6IDEsIHRhaWw6IDJcIilcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoTGVmdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB7XG4gIG9uRW1wdHksXG4gIG9uTm9uRW1wdHlcbn0pID0+IGlzTm9uRW1wdHlSZWFkb25seUFycmF5KHNlbGYpID8gb25Ob25FbXB0eShoZWFkTm9uRW1wdHkoc2VsZiksIHRhaWxOb25FbXB0eShzZWxmKSkgOiBvbkVtcHR5KCkpO1xuLyoqXG4gKiBNYXRjaGVzIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBmcm9tIHRoZSByaWdodCwgYXBwbHlpbmcgZnVuY3Rpb25zIHRvIGNhc2VzIG9mIGVtcHR5IGFuZCBub24tZW1wdHkgYXJyYXlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBtYXRjaFJpZ2h0ID0gQXJyYXkubWF0Y2hSaWdodCh7XG4gKiAgIG9uRW1wdHk6ICgpID0+IFwiZW1wdHlcIixcbiAqICAgb25Ob25FbXB0eTogKGluaXQsIGxhc3QpID0+IGBpbml0OiAke2luaXQubGVuZ3RofSwgbGFzdDogJHtsYXN0fWBcbiAqIH0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hdGNoUmlnaHQoW10pLCBcImVtcHR5XCIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hdGNoUmlnaHQoWzEsIDIsIDNdKSwgXCJpbml0OiAyLCBsYXN0OiAzXCIpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgcGF0dGVybiBtYXRjaGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaFJpZ2h0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHtcbiAgb25FbXB0eSxcbiAgb25Ob25FbXB0eVxufSkgPT4gaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoc2VsZikgPyBvbk5vbkVtcHR5KGluaXROb25FbXB0eShzZWxmKSwgbGFzdE5vbkVtcHR5KHNlbGYpKSA6IG9uRW1wdHkoKSk7XG4vKipcbiAqIFByZXBlbmQgYW4gZWxlbWVudCB0byB0aGUgZnJvbnQgb2YgYW4gYEl0ZXJhYmxlYCwgY3JlYXRpbmcgYSBuZXcgYE5vbkVtcHR5QXJyYXlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBvcmlnaW5hbCA9IFsyLCAzLCA0XTtcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LnByZXBlbmQob3JpZ2luYWwsIDEpO1xuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAyLCAzLCA0XSk7XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uY2F0ZW5hdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcmVwZW5kID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGhlYWQpID0+IFtoZWFkLCAuLi5zZWxmXSk7XG4vKipcbiAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgcHJlZml4IGFycmF5IChvciBpdGVyYWJsZSkgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIGFycmF5IChvciBpdGVyYWJsZSkuXG4gKiBJZiBlaXRoZXIgYXJyYXkgaXMgbm9uLWVtcHR5LCB0aGUgcmVzdWx0IGlzIGFsc28gYSBub24tZW1wdHkgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHByZWZpeCA9IFswLCAxXTtcbiAqIGNvbnN0IGFycmF5ID0gWzIsIDNdO1xuICogY29uc3QgcmVzdWx0ID0gQXJyYXkucHJlcGVuZEFsbChhcnJheSwgcHJlZml4KTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMCwgMSwgMiwgM10pO1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbmNhdGVuYXRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcHJlcGVuZEFsbCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBmcm9tSXRlcmFibGUodGhhdCkuY29uY2F0KGZyb21JdGVyYWJsZShzZWxmKSkpO1xuLyoqXG4gKiBBcHBlbmQgYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIGFuIGBJdGVyYWJsZWAsIGNyZWF0aW5nIGEgbmV3IGBOb25FbXB0eUFycmF5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3Qgb3JpZ2luYWwgPSBbMSwgMiwgM107XG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5hcHBlbmQob3JpZ2luYWwsIDQpO1xuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAyLCAzLCA0XSk7XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uY2F0ZW5hdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbGFzdCkgPT4gWy4uLnNlbGYsIGxhc3RdKTtcbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byBhcnJheXMgKG9yIGl0ZXJhYmxlcyksIGNvbWJpbmluZyB0aGVpciBlbGVtZW50cy5cbiAqIElmIGVpdGhlciBhcnJheSBpcyBub24tZW1wdHksIHRoZSByZXN1bHQgaXMgYWxzbyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uY2F0ZW5hdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmRBbGwgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gZnJvbUl0ZXJhYmxlKHNlbGYpLmNvbmNhdChmcm9tSXRlcmFibGUodGhhdCkpKTtcbi8qKlxuICogQWNjdW11bGF0ZXMgdmFsdWVzIGZyb20gYW4gYEl0ZXJhYmxlYCBzdGFydGluZyBmcm9tIHRoZSBsZWZ0LCBzdG9yaW5nXG4gKiBlYWNoIGludGVybWVkaWF0ZSByZXN1bHQgaW4gYW4gYXJyYXkuIFVzZWZ1bCBmb3IgdHJhY2tpbmcgdGhlIHByb2dyZXNzaW9uIG9mXG4gKiBhIHZhbHVlIHRocm91Z2ggYSBzZXJpZXMgb2YgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCI7XG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuc2NhbihudW1iZXJzLCAwLCAoYWNjLCB2YWx1ZSkgPT4gYWNjICsgdmFsdWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzAsIDEsIDMsIDYsIDEwXSlcbiAqXG4gKiAvLyBFeHBsYW5hdGlvbjpcbiAqIC8vIFRoaXMgZnVuY3Rpb24gc3RhcnRzIHdpdGggdGhlIGluaXRpYWwgdmFsdWUgKDAgaW4gdGhpcyBjYXNlKVxuICogLy8gYW5kIGFkZHMgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSB0byB0aGlzIGFjY3VtdWxhdG9yIG9uZSBieSBvbmUsXG4gKiAvLyBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdW11bGF0aXZlIHN1bSBhZnRlciBlYWNoIGFkZGl0aW9uLlxuICogLy8gRWFjaCBvZiB0aGVzZSBzdW1zIGlzIGNhcHR1cmVkIGluIHRoZSByZXN1bHRpbmcgYXJyYXkuXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzY2FuID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGIsIGYpID0+IHtcbiAgY29uc3Qgb3V0ID0gW2JdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgb3V0W2kgKyAxXSA9IGYob3V0W2ldLCBhKTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBBY2N1bXVsYXRlcyB2YWx1ZXMgZnJvbSBhbiBgSXRlcmFibGVgIHN0YXJ0aW5nIGZyb20gdGhlIHJpZ2h0LCBzdG9yaW5nXG4gKiBlYWNoIGludGVybWVkaWF0ZSByZXN1bHQgaW4gYW4gYXJyYXkuIFVzZWZ1bCBmb3IgdHJhY2tpbmcgdGhlIHByb2dyZXNzaW9uIG9mXG4gKiBhIHZhbHVlIHRocm91Z2ggYSBzZXJpZXMgb2YgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCI7XG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuc2NhblJpZ2h0KG51bWJlcnMsIDAsIChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMTAsIDksIDcsIDQsIDBdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZvbGRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2NhblJpZ2h0ID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGIsIGYpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGNvbnN0IG91dCA9IG5ldyBBcnJheShpbnB1dC5sZW5ndGggKyAxKTtcbiAgb3V0W2lucHV0Lmxlbmd0aF0gPSBiO1xuICBmb3IgKGxldCBpID0gaW5wdXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBvdXRbaV0gPSBmKG91dFtpICsgMV0sIGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4vKipcbiAqIERldGVybWluZSBpZiBgdW5rbm93bmAgaXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSBcImVmZmVjdC9BcnJheVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0FycmF5KG51bGwpLCBmYWxzZSk7XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzQXJyYXkoWzEsIDIsIDNdKSwgdHJ1ZSk7XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYEFycmF5YCBpcyBlbXB0eSBuYXJyb3dpbmcgZG93biB0aGUgdHlwZSB0byBgW11gLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBBcnJheWAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc0VtcHR5QXJyYXkgfSBmcm9tIFwiZWZmZWN0L0FycmF5XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRW1wdHlBcnJheShbXSksIHRydWUpO1xuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0VtcHR5QXJyYXkoWzEsIDIsIDNdKSwgZmFsc2UpO1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5QXJyYXkgPSBzZWxmID0+IHNlbGYubGVuZ3RoID09PSAwO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBgUmVhZG9ubHlBcnJheWAgaXMgZW1wdHkgbmFycm93aW5nIGRvd24gdGhlIHR5cGUgdG8gYHJlYWRvbmx5IFtdYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgUmVhZG9ubHlBcnJheWAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc0VtcHR5UmVhZG9ubHlBcnJheSB9IGZyb20gXCJlZmZlY3QvQXJyYXlcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFbXB0eVJlYWRvbmx5QXJyYXkoW10pLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFbXB0eVJlYWRvbmx5QXJyYXkoWzEsIDIsIDNdKSwgZmFsc2UpO1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5UmVhZG9ubHlBcnJheSA9IGlzRW1wdHlBcnJheTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBBcnJheWAgaXMgbm9uIGVtcHR5IG5hcnJvd2luZyBkb3duIHRoZSB0eXBlIHRvIGBOb25FbXB0eUFycmF5YC5cbiAqXG4gKiBBbiBgQXJyYXlgIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBgTm9uRW1wdHlBcnJheWAgaWYgaXQgY29udGFpbnMgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEFycmF5YCB0byBjaGVjay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzTm9uRW1wdHlBcnJheSB9IGZyb20gXCJlZmZlY3QvQXJyYXlcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb25FbXB0eUFycmF5KFtdKSwgZmFsc2UpO1xuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vbkVtcHR5QXJyYXkoWzEsIDIsIDNdKSwgdHJ1ZSk7XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm9uRW1wdHlBcnJheSA9IHJlYWRvbmx5QXJyYXkuaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBgUmVhZG9ubHlBcnJheWAgaXMgbm9uIGVtcHR5IG5hcnJvd2luZyBkb3duIHRoZSB0eXBlIHRvIGBOb25FbXB0eVJlYWRvbmx5QXJyYXlgLlxuICpcbiAqIEEgYFJlYWRvbmx5QXJyYXlgIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBgTm9uRW1wdHlSZWFkb25seUFycmF5YCBpZiBpdCBjb250YWlucyBhdCBsZWFzdCBvbmUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgUmVhZG9ubHlBcnJheWAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc05vbkVtcHR5UmVhZG9ubHlBcnJheSB9IGZyb20gXCJlZmZlY3QvQXJyYXlcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoW10pLCBmYWxzZSk7XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTm9uRW1wdHlSZWFkb25seUFycmF5KFsxLCAyLCAzXSksIHRydWUpO1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc05vbkVtcHR5UmVhZG9ubHlBcnJheSA9IHJlYWRvbmx5QXJyYXkuaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGBSZWFkb25seUFycmF5YC5cbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBzZWxmID0+IHNlbGYubGVuZ3RoO1xuY29uc3QgaXNPdXRPZkJvdW5kID0gKGksIGFzKSA9PiBpIDwgMCB8fCBpID49IGFzLmxlbmd0aDtcbmNvbnN0IGNsYW1wID0gKGksIGFzKSA9PiBNYXRoLmZsb29yKE1hdGgubWluKE1hdGgubWF4KDAsIGkpLCBhcy5sZW5ndGgpKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIHNhZmUgd2F5IHRvIHJlYWQgYSB2YWx1ZSBhdCBhIHBhcnRpY3VsYXIgaW5kZXggZnJvbSBhIGBSZWFkb25seUFycmF5YC5cbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgaW5kZXgpID0+IHtcbiAgY29uc3QgaSA9IE1hdGguZmxvb3IoaW5kZXgpO1xuICByZXR1cm4gaXNPdXRPZkJvdW5kKGksIHNlbGYpID8gTy5ub25lKCkgOiBPLnNvbWUoc2VsZltpXSk7XG59KTtcbi8qKlxuICogR2V0cyBhbiBlbGVtZW50IHVuc2FmZWx5LCB3aWxsIHRocm93IG9uIG91dCBvZiBib3VuZHMuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgdW5zYWZlXG4gKi9cbmV4cG9ydCBjb25zdCB1bnNhZmVHZXQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgaW5kZXgpID0+IHtcbiAgY29uc3QgaSA9IE1hdGguZmxvb3IoaW5kZXgpO1xuICBpZiAoaXNPdXRPZkJvdW5kKGksIHNlbGYpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCAke2l9IG91dCBvZiBib3VuZHNgKTtcbiAgfVxuICByZXR1cm4gc2VsZltpXTtcbn0pO1xuLyoqXG4gKiBSZXR1cm4gYSB0dXBsZSBjb250YWluaW5nIHRoZSBmaXJzdCBlbGVtZW50LCBhbmQgYSBuZXcgYEFycmF5YCBvZiB0aGUgcmVtYWluaW5nIGVsZW1lbnRzLCBpZiBhbnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIjtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS51bnByZXBlbmQoWzEsIDIsIDMsIDRdKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCBbMiwgMywgNF1dKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IHNwbGl0dGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB1bnByZXBlbmQgPSBzZWxmID0+IFtoZWFkTm9uRW1wdHkoc2VsZiksIHRhaWxOb25FbXB0eShzZWxmKV07XG4vKipcbiAqIFJldHVybiBhIHR1cGxlIGNvbnRhaW5pbmcgYSBjb3B5IG9mIHRoZSBgTm9uRW1wdHlSZWFkb25seUFycmF5YCB3aXRob3V0IGl0cyBsYXN0IGVsZW1lbnQsIGFuZCB0aGF0IGxhc3QgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LnVuYXBwZW5kKFsxLCAyLCAzLCA0XSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbWzEsIDIsIDNdLCA0XSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBzcGxpdHRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdW5hcHBlbmQgPSBzZWxmID0+IFtpbml0Tm9uRW1wdHkoc2VsZiksIGxhc3ROb25FbXB0eShzZWxmKV07XG4vKipcbiAqIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIGBSZWFkb25seUFycmF5YCwgb3IgYE5vbmVgIGlmIHRoZSBgUmVhZG9ubHlBcnJheWAgaXMgZW1wdHkuXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaGVhZCA9IC8qI19fUFVSRV9fKi9nZXQoMCk7XG4vKipcbiAqIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIG5vbiBlbXB0eSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuaGVhZE5vbkVtcHR5KFsxLCAyLCAzLCA0XSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCAxKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaGVhZE5vbkVtcHR5ID0gLyojX19QVVJFX18qL3Vuc2FmZUdldCgwKTtcbi8qKlxuICogR2V0IHRoZSBsYXN0IGVsZW1lbnQgaW4gYSBgUmVhZG9ubHlBcnJheWAsIG9yIGBOb25lYCBpZiB0aGUgYFJlYWRvbmx5QXJyYXlgIGlzIGVtcHR5LlxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3QgPSBzZWxmID0+IGlzTm9uRW1wdHlSZWFkb25seUFycmF5KHNlbGYpID8gTy5zb21lKGxhc3ROb25FbXB0eShzZWxmKSkgOiBPLm5vbmUoKTtcbi8qKlxuICogR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYSBub24gZW1wdHkgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5Lmxhc3ROb25FbXB0eShbMSwgMiwgMywgNF0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgNClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3ROb25FbXB0eSA9IHNlbGYgPT4gc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuLyoqXG4gKiBHZXQgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBgSXRlcmFibGVgLCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLCBvciBgTm9uZWAgaWYgdGhlIGBJdGVyYWJsZWAgaXMgZW1wdHkuXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdGFpbCA9IHNlbGYgPT4ge1xuICBjb25zdCBpbnB1dCA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgcmV0dXJuIGlzTm9uRW1wdHlSZWFkb25seUFycmF5KGlucHV0KSA/IE8uc29tZSh0YWlsTm9uRW1wdHkoaW5wdXQpKSA6IE8ubm9uZSgpO1xufTtcbi8qKlxuICogR2V0IGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBgTm9uRW1wdHlSZWFkb25seUFycmF5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkudGFpbE5vbkVtcHR5KFsxLCAyLCAzLCA0XSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMiwgMywgNF0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0YWlsTm9uRW1wdHkgPSBzZWxmID0+IHNlbGYuc2xpY2UoMSk7XG4vKipcbiAqIEdldCBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYEl0ZXJhYmxlYCwgY3JlYXRpbmcgYSBuZXcgYEFycmF5YCwgb3IgYE5vbmVgIGlmIHRoZSBgSXRlcmFibGVgIGlzIGVtcHR5LlxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXQgPSBzZWxmID0+IHtcbiAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIHJldHVybiBpc05vbkVtcHR5UmVhZG9ubHlBcnJheShpbnB1dCkgPyBPLnNvbWUoaW5pdE5vbkVtcHR5KGlucHV0KSkgOiBPLm5vbmUoKTtcbn07XG4vKipcbiAqIEdldCBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYSBub24gZW1wdHkgYXJyYXksIGNyZWF0aW5nIGEgbmV3IGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5pbml0Tm9uRW1wdHkoWzEsIDIsIDMsIDRdKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXROb25FbXB0eSA9IHNlbGYgPT4gc2VsZi5zbGljZSgwLCAtMSk7XG4vKipcbiAqIEtlZXAgb25seSBhIG1heCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYW4gYEl0ZXJhYmxlYCwgY3JlYXRpbmcgYSBuZXcgYEFycmF5YC5cbiAqXG4gKiAqKk5vdGUqKi4gYG5gIGlzIG5vcm1hbGl6ZWQgdG8gYSBub24gbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkudGFrZShudW1iZXJzLCAzKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHRha2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbikgPT4ge1xuICBjb25zdCBpbnB1dCA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGNsYW1wKG4sIGlucHV0KSk7XG59KTtcbi8qKlxuICogS2VlcCBvbmx5IGEgbWF4IG51bWJlciBvZiBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgYW4gYEl0ZXJhYmxlYCwgY3JlYXRpbmcgYSBuZXcgYEFycmF5YC5cbiAqXG4gKiAqKk5vdGUqKi4gYG5gIGlzIG5vcm1hbGl6ZWQgdG8gYSBub24gbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkudGFrZVJpZ2h0KG51bWJlcnMsIDMpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzMsIDQsIDVdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdGFrZVJpZ2h0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG4pID0+IHtcbiAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGNvbnN0IGkgPSBjbGFtcChuLCBpbnB1dCk7XG4gIHJldHVybiBpID09PSAwID8gW10gOiBpbnB1dC5zbGljZSgtaSk7XG59KTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBsb25nZXN0IGluaXRpYWwgc3ViYXJyYXkgZm9yIHdoaWNoIGFsbCBlbGVtZW50IHNhdGlzZnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGNyZWF0aW5nIGEgbmV3IGBBcnJheWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMywgMiwgNCwgMSwgMl1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LnRha2VXaGlsZShudW1iZXJzLCB4ID0+IHggPCA0KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAzLCAyXSlcbiAqXG4gKiAvLyBFeHBsYW5hdGlvbjpcbiAqIC8vIC0gVGhlIGZ1bmN0aW9uIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IChgMWApLCB3aGljaCBpcyBsZXNzIHRoYW4gYDRgLCBzbyBpdCBhZGRzIGAxYCB0byB0aGUgcmVzdWx0LlxuICogLy8gLSBUaGUgbmV4dCBlbGVtZW50IChgM2ApIGlzIGFsc28gbGVzcyB0aGFuIGA0YCwgc28gaXQgYWRkcyBgM2AuXG4gKiAvLyAtIFRoZSBuZXh0IGVsZW1lbnQgKGAyYCkgaXMgYWdhaW4gbGVzcyB0aGFuIGA0YCwgc28gaXQgYWRkcyBgMmAuXG4gKiAvLyAtIFRoZSBmdW5jdGlvbiB0aGVuIGVuY291bnRlcnMgYDRgLCB3aGljaCBpcyBub3QgbGVzcyB0aGFuIGA0YC4gQXQgdGhpcyBwb2ludCwgaXQgc3RvcHMgY2hlY2tpbmcgZnVydGhlciBlbGVtZW50cyBhbmQgZmluYWxpemVzIHRoZSByZXN1bHQuXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0YWtlV2hpbGUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgcHJlZGljYXRlKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUoYSwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdXQucHVzaChhKTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuY29uc3Qgc3BhbkluZGV4ID0gKHNlbGYsIHByZWRpY2F0ZSkgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUoYSwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuLyoqXG4gKiBTcGxpdCBhbiBgSXRlcmFibGVgIGludG8gdHdvIHBhcnRzOlxuICpcbiAqIDEuIHRoZSBsb25nZXN0IGluaXRpYWwgc3ViYXJyYXkgZm9yIHdoaWNoIGFsbCBlbGVtZW50cyBzYXRpc2Z5IHRoZSBzcGVjaWZpZWQgcHJlZGljYXRlXG4gKiAyLiB0aGUgcmVtYWluaW5nIGVsZW1lbnRzXG4gKlxuICogQGNhdGVnb3J5IHNwbGl0dGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzcGFuID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHByZWRpY2F0ZSkgPT4gc3BsaXRBdChzZWxmLCBzcGFuSW5kZXgoc2VsZiwgcHJlZGljYXRlKSkpO1xuLyoqXG4gKiBEcm9wIGEgbWF4IG51bWJlciBvZiBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhbiBgSXRlcmFibGVgLCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLlxuICpcbiAqICoqTm90ZSoqLiBgbmAgaXMgbm9ybWFsaXplZCB0byBhIG5vbiBuZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5kcm9wKG51bWJlcnMsIDIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzMsIDQsIDVdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZHJvcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBuKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gZnJvbUl0ZXJhYmxlKHNlbGYpO1xuICByZXR1cm4gaW5wdXQuc2xpY2UoY2xhbXAobiwgaW5wdXQpLCBpbnB1dC5sZW5ndGgpO1xufSk7XG4vKipcbiAqIERyb3AgYSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiBhbiBgSXRlcmFibGVgLCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLlxuICpcbiAqICoqTm90ZSoqLiBgbmAgaXMgbm9ybWFsaXplZCB0byBhIG5vbiBuZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5kcm9wUmlnaHQobnVtYmVycywgMilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkcm9wUmlnaHQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbikgPT4ge1xuICBjb25zdCBpbnB1dCA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGlucHV0Lmxlbmd0aCAtIGNsYW1wKG4sIGlucHV0KSk7XG59KTtcbi8qKlxuICogUmVtb3ZlIHRoZSBsb25nZXN0IGluaXRpYWwgc3ViYXJyYXkgZm9yIHdoaWNoIGFsbCBlbGVtZW50IHNhdGlzZnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGNyZWF0aW5nIGEgbmV3IGBBcnJheWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmRyb3BXaGlsZShudW1iZXJzLCB4ID0+IHggPCA0KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFs0LCA1XSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRyb3BXaGlsZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IGZyb21JdGVyYWJsZShzZWxmKS5zbGljZShzcGFuSW5kZXgoc2VsZiwgcHJlZGljYXRlKSkpO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGZvciB3aGljaCBhIHByZWRpY2F0ZSBob2xkcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzUsIDMsIDgsIDldXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5maW5kRmlyc3RJbmRleChudW1iZXJzLCB4ID0+IHggPiA1KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIE9wdGlvbi5zb21lKDIpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRGaXJzdEluZGV4ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHByZWRpY2F0ZSkgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhLCBpKSkge1xuICAgICAgcmV0dXJuIE8uc29tZShpKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBPLm5vbmUoKTtcbn0pO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgaW5kZXggZm9yIHdoaWNoIGEgcHJlZGljYXRlIGhvbGRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMywgOCwgOV1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmZpbmRMYXN0SW5kZXgobnVtYmVycywgeCA9PiB4IDwgNSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBPcHRpb24uc29tZSgxKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kTGFzdEluZGV4ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCBpbnB1dCA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgZm9yIChsZXQgaSA9IGlucHV0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHByZWRpY2F0ZShpbnB1dFtpXSwgaSkpIHtcbiAgICAgIHJldHVybiBPLnNvbWUoaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPLm5vbmUoKTtcbn0pO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBzcGVjaWZpZWRcbiAqIHByZWRpY2F0ZSwgb3IgYE5vbmVgIGlmIG5vIHN1Y2ggZWxlbWVudCBleGlzdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuZmluZEZpcnN0KG51bWJlcnMsIHggPT4geCA+IDMpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgT3B0aW9uLnNvbWUoNCkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmluZEZpcnN0ID0gRWZmZWN0SXRlcmFibGUuZmluZEZpcnN0O1xuLyoqXG4gKiBGaW5kcyB0aGUgbGFzdCBlbGVtZW50IGluIGFuIGl0ZXJhYmxlIGNvbGxlY3Rpb24gdGhhdCBzYXRpc2ZpZXMgdGhlIGdpdmVuIHByZWRpY2F0ZSBvciByZWZpbmVtZW50LlxuICogUmV0dXJucyBhbiBgT3B0aW9uYCBjb250YWluaW5nIHRoZSBmb3VuZCBlbGVtZW50LCBvciBgT3B0aW9uLm5vbmVgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5maW5kTGFzdChudW1iZXJzLCBuID0+IG4gJSAyID09PSAwKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIE9wdGlvbi5zb21lKDQpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRMYXN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGZvciAobGV0IGkgPSBpbnB1dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGEgPSBpbnB1dFtpXTtcbiAgICBjb25zdCBvID0gZihhLCBpKTtcbiAgICBpZiAoaXNCb29sZWFuKG8pKSB7XG4gICAgICBpZiAobykge1xuICAgICAgICByZXR1cm4gTy5zb21lKGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoTy5pc1NvbWUobykpIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBPLm5vbmUoKTtcbn0pO1xuLyoqXG4gKiBJbnNlcnQgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBjcmVhdGluZyBhIG5ldyBgTm9uRW1wdHlBcnJheWAsXG4gKiBvciByZXR1cm4gYE5vbmVgIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGxldHRlcnMgPSBbJ2EnLCAnYicsICdjJywgJ2UnXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuaW5zZXJ0QXQobGV0dGVycywgMywgJ2QnKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIE9wdGlvbi5zb21lKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpbnNlcnRBdCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBpLCBiKSA9PiB7XG4gIGNvbnN0IG91dCA9IEFycmF5LmZyb20oc2VsZik7XG4gIC8vICAgICAgICAgICAgIHYtLS0gYD0gc2VsZi5sZW5ndGhgIGlzIG9rLCBpdCBtZWFucyBpbnNlcnRpbmcgaW4gbGFzdCBwb3NpdGlvblxuICBpZiAoaSA8IDAgfHwgaSA+IG91dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gTy5ub25lKCk7XG4gIH1cbiAgb3V0LnNwbGljZShpLCAwLCBiKTtcbiAgcmV0dXJuIE8uc29tZShvdXQpO1xufSk7XG4vKipcbiAqIENoYW5nZSB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLFxuICogb3IgcmV0dXJuIGEgY29weSBvZiB0aGUgaW5wdXQgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGxldHRlcnMgPSBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkucmVwbGFjZShsZXR0ZXJzLCAxLCAneicpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWydhJywgJ3onLCAnYycsICdkJ10pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2UgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgaSwgYikgPT4gbW9kaWZ5KHNlbGYsIGksICgpID0+IGIpKTtcbi8qKlxuICogUmVwbGFjZXMgYW4gZWxlbWVudCBpbiBhbiBhcnJheSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSwgcmV0dXJuaW5nIGFuIG9wdGlvbiBvZiB0aGUgdXBkYXRlZCBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDNdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5yZXBsYWNlT3B0aW9uKG51bWJlcnMsIDEsIDQpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgT3B0aW9uLnNvbWUoWzEsIDQsIDNdKSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZU9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBpLCBiKSA9PiBtb2RpZnlPcHRpb24oc2VsZiwgaSwgKCkgPT4gYikpO1xuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIGNyZWF0aW5nIGEgbmV3IGBBcnJheWAsXG4gKiBvciByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnB1dCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkubW9kaWZ5KG51bWJlcnMsIDIsIChuKSA9PiBuICogMilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgNiwgNF0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1vZGlmeSA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBpLCBmKSA9PiBPLmdldE9yRWxzZShtb2RpZnlPcHRpb24oc2VsZiwgaSwgZiksICgpID0+IEFycmF5LmZyb20oc2VsZikpKTtcbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiB0byB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLFxuICogb3IgcmV0dXJuIGBOb25lYCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDRdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5tb2RpZnlPcHRpb24obnVtYmVycywgMiwgKG4pID0+IG4gKiAyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIE9wdGlvbi5zb21lKFsxLCAyLCA2LCA0XSkpXG4gKlxuICogY29uc3Qgb3V0T2ZCb3VuZHNSZXN1bHQgPSBBcnJheS5tb2RpZnlPcHRpb24obnVtYmVycywgNSwgKG4pID0+IG4gKiAyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChvdXRPZkJvdW5kc1Jlc3VsdCwgT3B0aW9uLm5vbmUoKSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5T3B0aW9uID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGksIGYpID0+IHtcbiAgY29uc3Qgb3V0ID0gQXJyYXkuZnJvbShzZWxmKTtcbiAgaWYgKGlzT3V0T2ZCb3VuZChpLCBvdXQpKSB7XG4gICAgcmV0dXJuIE8ubm9uZSgpO1xuICB9XG4gIGNvbnN0IG5leHQgPSBmKG91dFtpXSk7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgb3V0W2ldID0gbmV4dDtcbiAgcmV0dXJuIE8uc29tZShvdXQpO1xufSk7XG4vKipcbiAqIERlbGV0ZSB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLFxuICogb3IgcmV0dXJuIGEgY29weSBvZiB0aGUgaW5wdXQgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNF1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LnJlbW92ZShudW1iZXJzLCAyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAyLCA0XSlcbiAqXG4gKiBjb25zdCBvdXRPZkJvdW5kc1Jlc3VsdCA9IEFycmF5LnJlbW92ZShudW1iZXJzLCA1KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChvdXRPZkJvdW5kc1Jlc3VsdCwgWzEsIDIsIDMsIDRdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgaSkgPT4ge1xuICBjb25zdCBvdXQgPSBBcnJheS5mcm9tKHNlbGYpO1xuICBpZiAoaXNPdXRPZkJvdW5kKGksIG91dCkpIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIG91dC5zcGxpY2UoaSwgMSk7XG4gIHJldHVybiBvdXQ7XG59KTtcbi8qKlxuICogUmV2ZXJzZSBhbiBgSXRlcmFibGVgLCBjcmVhdGluZyBhIG5ldyBgQXJyYXlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDRdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5yZXZlcnNlKG51bWJlcnMpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzQsIDMsIDIsIDFdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHJldmVyc2UgPSBzZWxmID0+IEFycmF5LmZyb20oc2VsZikucmV2ZXJzZSgpO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYXJyYXkgd2l0aCBlbGVtZW50cyBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbXBhcmF0b3IuXG4gKiBJZiB0aGUgaW5wdXQgaXMgYSBgTm9uRW1wdHlSZWFkb25seUFycmF5YCwgdGhlIG91dHB1dCB3aWxsIGFsc28gYmUgYSBgTm9uRW1wdHlSZWFkb25seUFycmF5YC5cbiAqXG4gKiBAY2F0ZWdvcnkgc29ydGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzb3J0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIE8pID0+IHtcbiAgY29uc3Qgb3V0ID0gQXJyYXkuZnJvbShzZWxmKTtcbiAgb3V0LnNvcnQoTyk7XG4gIHJldHVybiBvdXQ7XG59KTtcbi8qKlxuICogU29ydHMgYW4gYXJyYXkgYmFzZWQgb24gYSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uIGFuZCBvcmRlci4gVGhlIG1hcHBpbmdcbiAqIGZ1bmN0aW9uIHRyYW5zZm9ybXMgdGhlIGVsZW1lbnRzIGludG8gYSB2YWx1ZSB0aGF0IGNhbiBiZSBjb21wYXJlZCwgYW5kIHRoZVxuICogb3JkZXIgZGVmaW5lcyBob3cgdGhvc2UgdmFsdWVzIHNob3VsZCBiZSBzb3J0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSwgT3JkZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBzdHJpbmdzID0gW1wiYWFhXCIsIFwiYlwiLCBcImNjXCJdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5zb3J0V2l0aChzdHJpbmdzLCAocykgPT4gcy5sZW5ndGgsIE9yZGVyLm51bWJlcilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbXCJiXCIsIFwiY2NcIiwgXCJhYWFcIl0pXG4gKlxuICogLy8gRXhwbGFuYXRpb246XG4gKiAvLyBUaGUgYXJyYXkgb2Ygc3RyaW5ncyBpcyBzb3J0ZWQgYmFzZWQgb24gdGhlaXIgbGVuZ3Rocy4gVGhlIG1hcHBpbmcgZnVuY3Rpb24gYChzKSA9PiBzLmxlbmd0aGBcbiAqIC8vIGNvbnZlcnRzIGVhY2ggc3RyaW5nIGludG8gaXRzIGxlbmd0aCwgYW5kIHRoZSBgT3JkZXIubnVtYmVyYCBzcGVjaWZpZXMgdGhhdCB0aGUgbGVuZ3RocyBzaG91bGRcbiAqIC8vIGJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICovXG5leHBvcnQgY29uc3Qgc29ydFdpdGggPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgZiwgb3JkZXIpID0+IEFycmF5LmZyb20oc2VsZikubWFwKGEgPT4gW2EsIGYoYSldKS5zb3J0KChhLCBiKSA9PiBvcmRlcihhWzFdLCBiWzFdKSkubWFwKHggPT4geFswXSkpO1xuLyoqXG4gKiBTb3J0cyB0aGUgZWxlbWVudHMgb2YgYW4gYEl0ZXJhYmxlYCBpbiBpbmNyZWFzaW5nIG9yZGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICogb3JkZXJzLiBUaGUgZWxlbWVudHMgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZSBmaXJzdCBvcmRlciBpbiBgb3JkZXJzYCwgdGhlbiB0aGVcbiAqIHNlY29uZCBvcmRlciBpZiB0aGUgZmlyc3QgY29tcGFyaXNvbiBpcyBlcXVhbCwgYW5kIHNvIG9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIE9yZGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgdXNlcnMgPSBbXG4gKiAgIHsgbmFtZTogXCJBbGljZVwiLCBhZ2U6IDMwIH0sXG4gKiAgIHsgbmFtZTogXCJCb2JcIiwgYWdlOiAyNSB9LFxuICogICB7IG5hbWU6IFwiQ2hhcmxpZVwiLCBhZ2U6IDMwIH1cbiAqIF1cbiAqXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5zb3J0QnkoXG4gKiAgIE9yZGVyLm1hcElucHV0KE9yZGVyLm51bWJlciwgKHVzZXI6ICh0eXBlb2YgdXNlcnMpW251bWJlcl0pID0+IHVzZXIuYWdlKSxcbiAqICAgT3JkZXIubWFwSW5wdXQoT3JkZXIuc3RyaW5nLCAodXNlcjogKHR5cGVvZiB1c2VycylbbnVtYmVyXSkgPT4gdXNlci5uYW1lKVxuICogKSh1c2VycylcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgW1xuICogICB7IG5hbWU6IFwiQm9iXCIsIGFnZTogMjUgfSxcbiAqICAgeyBuYW1lOiBcIkFsaWNlXCIsIGFnZTogMzAgfSxcbiAqICAgeyBuYW1lOiBcIkNoYXJsaWVcIiwgYWdlOiAzMCB9XG4gKiBdKVxuICpcbiAqIC8vIEV4cGxhbmF0aW9uOlxuICogLy8gVGhlIGFycmF5IG9mIHVzZXJzIGlzIHNvcnRlZCBmaXJzdCBieSBhZ2UgaW4gYXNjZW5kaW5nIG9yZGVyLiBXaGVuIGFnZXMgYXJlIGVxdWFsLFxuICogLy8gdGhlIHVzZXJzIGFyZSBmdXJ0aGVyIHNvcnRlZCBieSBuYW1lIGluIGFzY2VuZGluZyBvcmRlci5cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBzb3J0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNvcnRCeSA9ICguLi5vcmRlcnMpID0+IHtcbiAgY29uc3Qgc29ydEJ5QWxsID0gc29ydChPcmRlci5jb21iaW5lQWxsKG9yZGVycykpO1xuICByZXR1cm4gc2VsZiA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gICAgaWYgKGlzTm9uRW1wdHlSZWFkb25seUFycmF5KGlucHV0KSkge1xuICAgICAgcmV0dXJuIHNvcnRCeUFsbChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcbn07XG4vKipcbiAqIFRha2VzIHR3byBgSXRlcmFibGVgcyBhbmQgcmV0dXJucyBhbiBgQXJyYXlgIG9mIGNvcnJlc3BvbmRpbmcgcGFpcnMuXG4gKiBJZiBvbmUgaW5wdXQgYEl0ZXJhYmxlYCBpcyBzaG9ydCwgZXhjZXNzIGVsZW1lbnRzIG9mIHRoZVxuICogbG9uZ2VyIGBJdGVyYWJsZWAgYXJlIGRpc2NhcmRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgYXJyYXkxID0gWzEsIDIsIDNdXG4gKiBjb25zdCBhcnJheTIgPSBbJ2EnLCAnYiddXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS56aXAoYXJyYXkxLCBhcnJheTIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgW1sxLCAnYSddLCBbMiwgJ2InXV0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgemlwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB6aXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gemlwV2l0aChzZWxmLCB0aGF0LCBUdXBsZS5tYWtlKSk7XG4vKipcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gcGFpcnMgb2YgZWxlbWVudHMgYXQgdGhlIHNhbWUgaW5kZXggaW4gdHdvIGBJdGVyYWJsZWBzLCBjb2xsZWN0aW5nIHRoZSByZXN1bHRzIGluIGEgbmV3IGBBcnJheWAuIElmIG9uZVxuICogaW5wdXQgYEl0ZXJhYmxlYCBpcyBzaG9ydCwgZXhjZXNzIGVsZW1lbnRzIG9mIHRoZSBsb25nZXIgYEl0ZXJhYmxlYCBhcmUgZGlzY2FyZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBhcnJheTEgPSBbMSwgMiwgM11cbiAqIGNvbnN0IGFycmF5MiA9IFs0LCA1LCA2XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuemlwV2l0aChhcnJheTEsIGFycmF5MiwgKGEsIGIpID0+IGEgKyBiKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFs1LCA3LCA5XSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSB6aXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHppcFdpdGggPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGhhdCwgZikgPT4ge1xuICBjb25zdCBhcyA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgY29uc3QgYnMgPSBmcm9tSXRlcmFibGUodGhhdCk7XG4gIGlmIChpc05vbkVtcHR5UmVhZG9ubHlBcnJheShhcykgJiYgaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoYnMpKSB7XG4gICAgY29uc3Qgb3V0ID0gW2YoaGVhZE5vbkVtcHR5KGFzKSwgaGVhZE5vbkVtcHR5KGJzKSldO1xuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKGFzLmxlbmd0aCwgYnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBmKGFzW2ldLCBic1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgcmV0dXJuIFtdO1xufSk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGludmVyc2Ugb2YgYHppcGAuIFRha2VzIGFuIGBJdGVyYWJsZWAgb2YgcGFpcnMgYW5kIHJldHVybiB0d28gY29ycmVzcG9uZGluZyBgQXJyYXlgcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkudW56aXAoW1sxLCBcImFcIl0sIFsyLCBcImJcIl0sIFszLCBcImNcIl1dKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFtbMSwgMiwgM10sIFsnYScsICdiJywgJ2MnXV0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHVuemlwID0gc2VsZiA9PiB7XG4gIGNvbnN0IGlucHV0ID0gZnJvbUl0ZXJhYmxlKHNlbGYpO1xuICBpZiAoaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoaW5wdXQpKSB7XG4gICAgY29uc3QgZmEgPSBbaW5wdXRbMF1bMF1dO1xuICAgIGNvbnN0IGZiID0gW2lucHV0WzBdWzFdXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBmYVtpXSA9IGlucHV0W2ldWzBdO1xuICAgICAgZmJbaV0gPSBpbnB1dFtpXVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIFtmYSwgZmJdO1xuICB9XG4gIHJldHVybiBbW10sIFtdXTtcbn07XG4vKipcbiAqIFBsYWNlcyBhbiBlbGVtZW50IGluIGJldHdlZW4gbWVtYmVycyBvZiBhbiBgSXRlcmFibGVgLlxuICogSWYgdGhlIGlucHV0IGlzIGEgbm9uLWVtcHR5IGFycmF5LCB0aGUgcmVzdWx0IGlzIGFsc28gYSBub24tZW1wdHkgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgM11cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmludGVyc3BlcnNlKG51bWJlcnMsIDApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzEsIDAsIDIsIDAsIDNdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnNwZXJzZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBtaWRkbGUpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGlmIChpc05vbkVtcHR5UmVhZG9ubHlBcnJheShpbnB1dCkpIHtcbiAgICBjb25zdCBvdXQgPSBbaGVhZE5vbkVtcHR5KGlucHV0KV07XG4gICAgY29uc3QgdGFpbCA9IHRhaWxOb25FbXB0eShpbnB1dCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IHRhaWwubGVuZ3RoKSB7XG4gICAgICAgIG91dC5wdXNoKG1pZGRsZSk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaCh0YWlsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICByZXR1cm4gW107XG59KTtcbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiB0byB0aGUgaGVhZCwgY3JlYXRpbmcgYSBuZXcgYE5vbkVtcHR5UmVhZG9ubHlBcnJheWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5Lm1vZGlmeU5vbkVtcHR5SGVhZChbMSwgMiwgM10sIG4gPT4gbiAqIDEwKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxMCwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1vZGlmeU5vbkVtcHR5SGVhZCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBbZihoZWFkTm9uRW1wdHkoc2VsZikpLCAuLi50YWlsTm9uRW1wdHkoc2VsZildKTtcbi8qKlxuICogQ2hhbmdlIHRoZSBoZWFkLCBjcmVhdGluZyBhIG5ldyBgTm9uRW1wdHlSZWFkb25seUFycmF5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuc2V0Tm9uRW1wdHlIZWFkKFsxLCAyLCAzXSwgMTApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzEwLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2V0Tm9uRW1wdHlIZWFkID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGIpID0+IG1vZGlmeU5vbkVtcHR5SGVhZChzZWxmLCAoKSA9PiBiKSk7XG4vKipcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gdGhlIGxhc3QgZWxlbWVudCwgY3JlYXRpbmcgYSBuZXcgYE5vbkVtcHR5UmVhZG9ubHlBcnJheWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5Lm1vZGlmeU5vbkVtcHR5TGFzdChbMSwgMiwgM10sIG4gPT4gbiAqIDIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzEsIDIsIDZdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtb2RpZnlOb25FbXB0eUxhc3QgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gYXBwZW5kKGluaXROb25FbXB0eShzZWxmKSwgZihsYXN0Tm9uRW1wdHkoc2VsZikpKSk7XG4vKipcbiAqIENoYW5nZSB0aGUgbGFzdCBlbGVtZW50LCBjcmVhdGluZyBhIG5ldyBgTm9uRW1wdHlSZWFkb25seUFycmF5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuc2V0Tm9uRW1wdHlMYXN0KFsxLCAyLCAzXSwgNClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgNF0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNldE5vbkVtcHR5TGFzdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBiKSA9PiBtb2RpZnlOb25FbXB0eUxhc3Qoc2VsZiwgKCkgPT4gYikpO1xuLyoqXG4gKiBSb3RhdGUgYW4gYEl0ZXJhYmxlYCBieSBgbmAgc3RlcHMuXG4gKiBJZiB0aGUgaW5wdXQgaXMgYSBub24tZW1wdHkgYXJyYXksIHRoZSByZXN1bHQgaXMgYWxzbyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbGV0dGVycyA9IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5yb3RhdGUobGV0dGVycywgMilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbJ2MnLCAnZCcsICdhJywgJ2InXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgcm90YXRlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG4pID0+IHtcbiAgY29uc3QgaW5wdXQgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGlmIChpc05vbkVtcHR5UmVhZG9ubHlBcnJheShpbnB1dCkpIHtcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgY29uc3QgbSA9IE1hdGgucm91bmQobikgJSBsZW47XG4gICAgaWYgKGlzT3V0T2ZCb3VuZChNYXRoLmFicyhtKSwgaW5wdXQpIHx8IG0gPT09IDApIHtcbiAgICAgIHJldHVybiBjb3B5KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKG0gPCAwKSB7XG4gICAgICBjb25zdCBbZiwgc10gPSBzcGxpdE5vbkVtcHR5QXQoaW5wdXQsIC1tKTtcbiAgICAgIHJldHVybiBhcHBlbmRBbGwocywgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3RhdGUoc2VsZiwgbSAtIGxlbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn0pO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBgUmVhZG9ubHlBcnJheWAgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSB1c2luZyBhIHByb3ZpZGVkIGBpc0VxdWl2YWxlbnRgIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDRdXG4gKiBjb25zdCBpc0VxdWl2YWxlbnQgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IGEgPT09IGJcbiAqIGNvbnN0IGNvbnRhaW5zTnVtYmVyID0gQXJyYXkuY29udGFpbnNXaXRoKGlzRXF1aXZhbGVudClcbiAqIGNvbnN0IHJlc3VsdCA9IGNvbnRhaW5zTnVtYmVyKDMpKG51bWJlcnMpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgdHJ1ZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb250YWluc1dpdGggPSBpc0VxdWl2YWxlbnQgPT4gZHVhbCgyLCAoc2VsZiwgYSkgPT4ge1xuICBmb3IgKGNvbnN0IGkgb2Ygc2VsZikge1xuICAgIGlmIChpc0VxdWl2YWxlbnQoYSwgaSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KTtcbmNvbnN0IF9lcXVpdmFsZW5jZSA9IC8qI19fUFVSRV9fKi9FcXVhbC5lcXVpdmFsZW5jZSgpO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBgUmVhZG9ubHlBcnJheWAgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSB1c2luZyB0aGUgZGVmYXVsdCBgRXF1aXZhbGVuY2VgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBsZXR0ZXJzID0gWydhJywgJ2InLCAnYycsICdkJ11cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmNvbnRhaW5zKCdjJykobGV0dGVycylcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCB0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRhaW5zID0gLyojX19QVVJFX18qL2NvbnRhaW5zV2l0aChfZXF1aXZhbGVuY2UpO1xuLyoqXG4gKiBBIHVzZWZ1bCByZWN1cnNpb24gcGF0dGVybiBmb3IgcHJvY2Vzc2luZyBhbiBgSXRlcmFibGVgIHRvIHByb2R1Y2UgYSBuZXcgYEFycmF5YCwgb2Z0ZW4gdXNlZCBmb3IgXCJjaG9wcGluZ1wiIHVwIHRoZSBpbnB1dFxuICogYEl0ZXJhYmxlYC4gVHlwaWNhbGx5IGNob3AgaXMgY2FsbGVkIHdpdGggc29tZSBmdW5jdGlvbiB0aGF0IHdpbGwgY29uc3VtZSBhbiBpbml0aWFsIHByZWZpeCBvZiB0aGUgYEl0ZXJhYmxlYCBhbmQgcHJvZHVjZSBhXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIGBBcnJheWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmNob3AobnVtYmVycywgKGFzKTogW251bWJlciwgQXJyYXk8bnVtYmVyPl0gPT4gW2FzWzBdICogMiwgYXMuc2xpY2UoMSldKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsyLCA0LCA2LCA4LCAxMF0pXG4gKlxuICogLy8gRXhwbGFuYXRpb246XG4gKiAvLyBUaGUgYGNob3BGdW5jdGlvbmAgdGFrZXMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LCBkb3VibGVzIGl0LCBhbmQgdGhlbiByZXR1cm5zIGl0IGFsb25nIHdpdGggdGhlIHJlc3Qgb2YgdGhlIGFycmF5LlxuICogLy8gVGhlIGBjaG9wYCBmdW5jdGlvbiBhcHBsaWVzIHRoaXMgYGNob3BGdW5jdGlvbmAgcmVjdXJzaXZlbHkgdG8gdGhlIGlucHV0IGFycmF5IGBbMSwgMiwgMywgNCwgNV1gLFxuICogLy8gcmVzdWx0aW5nIGluIGEgbmV3IGFycmF5IGBbMiwgNCwgNiwgOCwgMTBdYC5cbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY2hvcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gZnJvbUl0ZXJhYmxlKHNlbGYpO1xuICBpZiAoaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoaW5wdXQpKSB7XG4gICAgY29uc3QgW2IsIHJlc3RdID0gZihpbnB1dCk7XG4gICAgY29uc3Qgb3V0ID0gW2JdO1xuICAgIGxldCBuZXh0ID0gcmVzdDtcbiAgICB3aGlsZSAocmVhZG9ubHlBcnJheS5pc05vbkVtcHR5QXJyYXkobmV4dCkpIHtcbiAgICAgIGNvbnN0IFtiLCByZXN0XSA9IGYobmV4dCk7XG4gICAgICBvdXQucHVzaChiKTtcbiAgICAgIG5leHQgPSByZXN0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHJldHVybiBbXTtcbn0pO1xuLyoqXG4gKiBTcGxpdHMgYW4gYEl0ZXJhYmxlYCBpbnRvIHR3byBzZWdtZW50cywgd2l0aCB0aGUgZmlyc3Qgc2VnbWVudCBjb250YWluaW5nIGEgbWF4aW11bSBvZiBgbmAgZWxlbWVudHMuXG4gKiBUaGUgdmFsdWUgb2YgYG5gIGNhbiBiZSBgMGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LnNwbGl0QXQobnVtYmVycywgMylcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbWzEsIDIsIDNdLCBbNCwgNV1dKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IHNwbGl0dGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzcGxpdEF0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG4pID0+IHtcbiAgY29uc3QgaW5wdXQgPSBBcnJheS5mcm9tKHNlbGYpO1xuICBjb25zdCBfbiA9IE1hdGguZmxvb3Iobik7XG4gIGlmIChpc05vbkVtcHR5UmVhZG9ubHlBcnJheShpbnB1dCkpIHtcbiAgICBpZiAoX24gPj0gMSkge1xuICAgICAgcmV0dXJuIHNwbGl0Tm9uRW1wdHlBdChpbnB1dCwgX24pO1xuICAgIH1cbiAgICByZXR1cm4gW1tdLCBpbnB1dF07XG4gIH1cbiAgcmV0dXJuIFtpbnB1dCwgW11dO1xufSk7XG4vKipcbiAqIFNwbGl0cyBhIGBOb25FbXB0eVJlYWRvbmx5QXJyYXlgIGludG8gdHdvIHNlZ21lbnRzLCB3aXRoIHRoZSBmaXJzdCBzZWdtZW50IGNvbnRhaW5pbmcgYSBtYXhpbXVtIG9mIGBuYCBlbGVtZW50cy5cbiAqIFRoZSB2YWx1ZSBvZiBgbmAgbXVzdCBiZSBgPj0gMWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LnNwbGl0Tm9uRW1wdHlBdChbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiXSwgMylcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbW1wiYVwiLCBcImJcIiwgXCJjXCJdLCBbXCJkXCIsIFwiZVwiXV0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgc3BsaXR0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNwbGl0Tm9uRW1wdHlBdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBuKSA9PiB7XG4gIGNvbnN0IF9uID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihuKSk7XG4gIHJldHVybiBfbiA+PSBzZWxmLmxlbmd0aCA/IFtjb3B5KHNlbGYpLCBbXV0gOiBbcHJlcGVuZChzZWxmLnNsaWNlKDEsIF9uKSwgaGVhZE5vbkVtcHR5KHNlbGYpKSwgc2VsZi5zbGljZShfbildO1xufSk7XG4vKipcbiAqIFNwbGl0cyB0aGlzIGl0ZXJhYmxlIGludG8gYG5gIGVxdWFsbHkgc2l6ZWQgYXJyYXlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5zcGxpdChudW1iZXJzLCAzKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFtbMSwgMiwgM10sIFs0LCA1LCA2XSwgWzcsIDhdXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHNwbGl0dGluZ1xuICovXG5leHBvcnQgY29uc3Qgc3BsaXQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbikgPT4ge1xuICBjb25zdCBpbnB1dCA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgcmV0dXJuIGNodW5rc09mKGlucHV0LCBNYXRoLmNlaWwoaW5wdXQubGVuZ3RoIC8gTWF0aC5mbG9vcihuKSkpO1xufSk7XG4vKipcbiAqIFNwbGl0cyB0aGlzIGl0ZXJhYmxlIG9uIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGlzIHByZWRpY2F0ZS5cbiAqIFJldHVybnMgYSB0dXBsZSBjb250YWluaW5nIHR3byBhcnJheXM6IHRoZSBmaXJzdCBvbmUgaXMgYmVmb3JlIHRoZSBtYXRjaCwgYW5kIHRoZSBzZWNvbmQgb25lIGlzIGZyb20gdGhlIG1hdGNoIG9ud2FyZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuc3BsaXRXaGVyZShudW1iZXJzLCBuID0+IG4gPiAzKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFtbMSwgMiwgM10sIFs0LCA1XV0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgc3BsaXR0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNwbGl0V2hlcmUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgcHJlZGljYXRlKSA9PiBzcGFuKHNlbGYsIChhLCBpKSA9PiAhcHJlZGljYXRlKGEsIGkpKSk7XG4vKipcbiAqIENvcGllcyBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzXVxuICogY29uc3QgY29weSA9IEFycmF5LmNvcHkobnVtYmVycylcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoY29weSwgWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gc2VsZiA9PiBzZWxmLnNsaWNlKCk7XG4vKipcbiAqIFBhZHMgYW4gYXJyYXkuXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGxlbmd0aCBgbmAgd2l0aCB0aGUgZWxlbWVudHMgb2YgYGFycmF5YCBmb2xsb3dlZCBieSBgZmlsbGAgZWxlbWVudHMgaWYgYGFycmF5YCBpcyBzaG9ydGVyIHRoYW4gYG5gLlxuICogSWYgYGFycmF5YCBpcyBsb25nZXIgdGhhbiBgbmAsIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGEgc2xpY2Ugb2YgYGFycmF5YCBjb250YWluaW5nIHRoZSBgbmAgZmlyc3QgZWxlbWVudHMgb2YgYGFycmF5YC5cbiAqIElmIGBuYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMCwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgYmUgYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGFyciA9IFsxLCAyLCAzXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkucGFkKGFyciwgNiwgMClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgMywgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMy44LjRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhZCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBuLCBmaWxsKSA9PiB7XG4gIGlmIChzZWxmLmxlbmd0aCA+PSBuKSB7XG4gICAgcmV0dXJuIHRha2Uoc2VsZiwgbik7XG4gIH1cbiAgcmV0dXJuIGFwcGVuZEFsbChzZWxmLCBtYWtlQnkobiAtIHNlbGYubGVuZ3RoLCAoKSA9PiBmaWxsKSk7XG59KTtcbi8qKlxuICogU3BsaXRzIGFuIGBJdGVyYWJsZWAgaW50byBsZW5ndGgtYG5gIHBpZWNlcy4gVGhlIGxhc3QgcGllY2Ugd2lsbCBiZSBzaG9ydGVyIGlmIGBuYCBkb2VzIG5vdCBldmVubHkgZGl2aWRlIHRoZSBsZW5ndGggb2ZcbiAqIHRoZSBgSXRlcmFibGVgLiBOb3RlIHRoYXQgYGNodW5rc09mKG4pKFtdKWAgaXMgYFtdYCwgbm90IGBbW11dYC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgYW5kIGlzIGNvbnNpc3RlbnQgd2l0aCBhIHJlY3Vyc2l2ZVxuICogZGVmaW5pdGlvbiBvZiBgY2h1bmtzT2ZgOyBpdCBzYXRpc2ZpZXMgdGhlIHByb3BlcnR5IHRoYXRcbiAqXG4gKiBgYGB0c1xuICogY2h1bmtzT2YobikoeHMpLmNvbmNhdChjaHVua3NPZihuKSh5cykpID09IGNodW5rc09mKG4pKHhzLmNvbmNhdCh5cykpKVxuICogYGBgXG4gKlxuICogd2hlbmV2ZXIgYG5gIGV2ZW5seSBkaXZpZGVzIHRoZSBsZW5ndGggb2YgYHNlbGZgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5jaHVua3NPZihudW1iZXJzLCAyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFtbMSwgMl0sIFszLCA0XSwgWzVdXSlcbiAqXG4gKiAvLyBFeHBsYW5hdGlvbjpcbiAqIC8vIFRoZSBgY2h1bmtzT2ZgIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIG51bWJlcnMgYFsxLCAyLCAzLCA0LCA1XWAgYW5kIGEgbnVtYmVyIGAyYC5cbiAqIC8vIEl0IHNwbGl0cyB0aGUgYXJyYXkgaW50byBjaHVua3Mgb2YgbGVuZ3RoIDIuIFNpbmNlIHRoZSBhcnJheSBsZW5ndGggaXMgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgMixcbiAqIC8vIHRoZSBsYXN0IGNodW5rIGNvbnRhaW5zIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gKiAvLyBUaGUgcmVzdWx0IGlzIGBbWzEsIDJdLCBbMywgNF0sIFs1XV1gLlxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IHNwbGl0dGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjaHVua3NPZiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBuKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gZnJvbUl0ZXJhYmxlKHNlbGYpO1xuICBpZiAoaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGNob3AoaW5wdXQsIHNwbGl0Tm9uRW1wdHlBdChuKSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufSk7XG4vKipcbiAqIEdyb3VwIGVxdWFsLCBjb25zZWN1dGl2ZSBlbGVtZW50cyBvZiBhIGBOb25FbXB0eVJlYWRvbmx5QXJyYXlgIGludG8gYE5vbkVtcHR5QXJyYXlgcyB1c2luZyB0aGUgcHJvdmlkZWQgYGlzRXF1aXZhbGVudGAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5Lmdyb3VwV2l0aChbXCJhXCIsIFwiYVwiLCBcImJcIiwgXCJiXCIsIFwiYlwiLCBcImNcIiwgXCJhXCJdLCAoeCwgeSkgPT4geCA9PT0geSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbW1wiYVwiLCBcImFcIl0sIFtcImJcIiwgXCJiXCIsIFwiYlwiXSwgW1wiY1wiXSwgW1wiYVwiXV0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3JvdXBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ3JvdXBXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGlzRXF1aXZhbGVudCkgPT4gY2hvcChzZWxmLCBhcyA9PiB7XG4gIGNvbnN0IGggPSBoZWFkTm9uRW1wdHkoYXMpO1xuICBjb25zdCBvdXQgPSBbaF07XG4gIGxldCBpID0gMTtcbiAgZm9yICg7IGkgPCBhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBhc1tpXTtcbiAgICBpZiAoaXNFcXVpdmFsZW50KGEsIGgpKSB7XG4gICAgICBvdXQucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBbb3V0LCBhcy5zbGljZShpKV07XG59KSk7XG4vKipcbiAqIEdyb3VwIGVxdWFsLCBjb25zZWN1dGl2ZSBlbGVtZW50cyBvZiBhIGBOb25FbXB0eVJlYWRvbmx5QXJyYXlgIGludG8gYE5vbkVtcHR5QXJyYXlgcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuZ3JvdXAoWzEsIDEsIDIsIDIsIDIsIDMsIDFdKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFtbMSwgMV0sIFsyLCAyLCAyXSwgWzNdLCBbMV1dKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdyb3VwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwID0gLyojX19QVVJFX18qL2dyb3VwV2l0aCggLyojX19QVVJFX18qL0VxdWFsLmVxdWl2YWxlbmNlKCkpO1xuLyoqXG4gKiBTcGxpdHMgYW4gYEl0ZXJhYmxlYCBpbnRvIHN1Yi1ub24tZW1wdHktYXJyYXlzIHN0b3JlZCBpbiBhbiBvYmplY3QsIGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIGBzdHJpbmdgLXJldHVybmluZ1xuICogZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50LCBhbmQgZ3JvdXBpbmcgdGhlIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHZhbHVlcyByZXR1cm5lZFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBwZW9wbGUgPSBbXG4gKiAgIHsgbmFtZTogXCJBbGljZVwiLCBncm91cDogXCJBXCIgfSxcbiAqICAgeyBuYW1lOiBcIkJvYlwiLCBncm91cDogXCJCXCIgfSxcbiAqICAgeyBuYW1lOiBcIkNoYXJsaWVcIiwgZ3JvdXA6IFwiQVwiIH1cbiAqIF1cbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5Lmdyb3VwQnkocGVvcGxlLCBwZXJzb24gPT4gcGVyc29uLmdyb3VwKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIHtcbiAqICAgQTogW3sgbmFtZTogXCJBbGljZVwiLCBncm91cDogXCJBXCIgfSwgeyBuYW1lOiBcIkNoYXJsaWVcIiwgZ3JvdXA6IFwiQVwiIH1dLFxuICogICBCOiBbeyBuYW1lOiBcIkJvYlwiLCBncm91cDogXCJCXCIgfV1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3JvdXBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ3JvdXBCeSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGEgb2Ygc2VsZikge1xuICAgIGNvbnN0IGsgPSBmKGEpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0LCBrKSkge1xuICAgICAgb3V0W2tdLnB1c2goYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtrXSA9IFthXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB1bmlvbiBvZiB0d28gYXJyYXlzIHVzaW5nIHRoZSBwcm92aWRlZCBlcXVpdmFsZW5jZSByZWxhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgYXJyYXkxID0gWzEsIDJdXG4gKiBjb25zdCBhcnJheTIgPSBbMiwgM11cbiAqIGNvbnN0IHVuaW9uID0gQXJyYXkudW5pb25XaXRoKGFycmF5MSwgYXJyYXkyLCAoYSwgYikgPT4gYSA9PT0gYilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwodW5pb24sIFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdW5pb25XaXRoID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRoYXQsIGlzRXF1aXZhbGVudCkgPT4ge1xuICBjb25zdCBhID0gZnJvbUl0ZXJhYmxlKHNlbGYpO1xuICBjb25zdCBiID0gZnJvbUl0ZXJhYmxlKHRoYXQpO1xuICBpZiAoaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoYSkpIHtcbiAgICBpZiAoaXNOb25FbXB0eVJlYWRvbmx5QXJyYXkoYikpIHtcbiAgICAgIGNvbnN0IGRlZHVwZSA9IGRlZHVwZVdpdGgoaXNFcXVpdmFsZW50KTtcbiAgICAgIHJldHVybiBkZWR1cGUoYXBwZW5kQWxsKGEsIGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuIGI7XG59KTtcbi8qKlxuICogQ3JlYXRlcyBhIHVuaW9uIG9mIHR3byBhcnJheXMsIHJlbW92aW5nIGR1cGxpY2F0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGFycmF5MSA9IFsxLCAyXVxuICogY29uc3QgYXJyYXkyID0gWzIsIDNdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS51bmlvbihhcnJheTEsIGFycmF5MilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHVuaW9uID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IHVuaW9uV2l0aChzZWxmLCB0aGF0LCBfZXF1aXZhbGVuY2UpKTtcbi8qKlxuICogQ3JlYXRlcyBhbiBgQXJyYXlgIG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGBJdGVyYWJsZWBzIHVzaW5nIHRoZSBwcm92aWRlZCBgaXNFcXVpdmFsZW50YCBmdW5jdGlvbi5cbiAqIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBgSXRlcmFibGVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBhcnJheTEgPSBbeyBpZDogMSB9LCB7IGlkOiAyIH0sIHsgaWQ6IDMgfV1cbiAqIGNvbnN0IGFycmF5MiA9IFt7IGlkOiAzIH0sIHsgaWQ6IDQgfSwgeyBpZDogMSB9XVxuICogY29uc3QgaXNFcXVpdmFsZW50ID0gKGE6IHsgaWQ6IG51bWJlciB9LCBiOiB7IGlkOiBudW1iZXIgfSkgPT4gYS5pZCA9PT0gYi5pZFxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuaW50ZXJzZWN0aW9uV2l0aChpc0VxdWl2YWxlbnQpKGFycmF5MikoYXJyYXkxKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFt7IGlkOiAxIH0sIHsgaWQ6IDMgfV0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVyc2VjdGlvbldpdGggPSBpc0VxdWl2YWxlbnQgPT4ge1xuICBjb25zdCBoYXMgPSBjb250YWluc1dpdGgoaXNFcXVpdmFsZW50KTtcbiAgcmV0dXJuIGR1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGZyb21JdGVyYWJsZShzZWxmKS5maWx0ZXIoYSA9PiBoYXModGhhdCwgYSkpKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYW4gYEFycmF5YCBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBgSXRlcmFibGVgcy5cbiAqIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBgSXRlcmFibGVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBhcnJheTEgPSBbMSwgMiwgM11cbiAqIGNvbnN0IGFycmF5MiA9IFszLCA0LCAxXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuaW50ZXJzZWN0aW9uKGFycmF5MSwgYXJyYXkyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaW50ZXJzZWN0aW9uID0gLyojX19QVVJFX18qL2ludGVyc2VjdGlvbldpdGgoX2VxdWl2YWxlbmNlKTtcbi8qKlxuICogQ3JlYXRlcyBhIGBBcnJheWAgb2YgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYEl0ZXJhYmxlYCB1c2luZyB0aGUgcHJvdmlkZWQgYGlzRXF1aXZhbGVudGAgZnVuY3Rpb24uXG4gKiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYEl0ZXJhYmxlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgYXJyYXkxID0gWzEsIDIsIDNdXG4gKiBjb25zdCBhcnJheTIgPSBbMiwgMywgNF1cbiAqIGNvbnN0IGRpZmZlcmVuY2UgPSBBcnJheS5kaWZmZXJlbmNlV2l0aDxudW1iZXI+KChhLCBiKSA9PiBhID09PSBiKShhcnJheTEsIGFycmF5MilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZGlmZmVyZW5jZSwgWzFdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkaWZmZXJlbmNlV2l0aCA9IGlzRXF1aXZhbGVudCA9PiB7XG4gIGNvbnN0IGhhcyA9IGNvbnRhaW5zV2l0aChpc0VxdWl2YWxlbnQpO1xuICByZXR1cm4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gZnJvbUl0ZXJhYmxlKHNlbGYpLmZpbHRlcihhID0+ICFoYXModGhhdCwgYSkpKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBgQXJyYXlgIG9mIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGBJdGVyYWJsZWAuXG4gKiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYEl0ZXJhYmxlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgYXJyYXkxID0gWzEsIDIsIDNdXG4gKiBjb25zdCBhcnJheTIgPSBbMiwgMywgNF1cbiAqIGNvbnN0IGRpZmZlcmVuY2UgPSBBcnJheS5kaWZmZXJlbmNlKGFycmF5MSwgYXJyYXkyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChkaWZmZXJlbmNlLCBbMV0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRpZmZlcmVuY2UgPSAvKiNfX1BVUkVfXyovZGlmZmVyZW5jZVdpdGgoX2VxdWl2YWxlbmNlKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBlbXB0eSA9ICgpID0+IFtdO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBOb25FbXB0eUFycmF5PEE+YCBmcm9tIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBvZiA9IGEgPT4gW2FdO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gc2VsZi5tYXAoZikpO1xuLyoqXG4gKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IGluIGFuIGFycmF5IGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCBtYXBwZWQgZWxlbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGlmIChpc0VtcHR5UmVhZG9ubHlBcnJheShzZWxmKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBvdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5uZXIgPSBmKHNlbGZbaV0sIGkpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5uZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG91dC5wdXNoKGlubmVyW2pdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBhcnJheXMgaW50byBhIHNpbmdsZSBhcnJheSBieSBjb25jYXRlbmF0aW5nIGFsbCBlbGVtZW50c1xuICogZnJvbSBlYWNoIG5lc3RlZCBhcnJheS4gVGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgdGhlIHN0cnVjdHVyZSBvZiBuZXN0ZWRcbiAqIGFycmF5cyBpcyBjb2xsYXBzZWQgaW50byBhIHNpbmdsZSwgZmxhdCBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiO1xuICpcbiAqIGNvbnN0IG5lc3RlZEFycmF5cyA9IFtbMSwgMl0sIFtdLCBbMywgNF0sIFtdLCBbNSwgNl1dXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5mbGF0dGVuKG5lc3RlZEFycmF5cylcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW4gPSAvKiNfX1BVUkVfXyovZmxhdE1hcChpZGVudGl0eSk7XG4vKipcbiAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIGBJdGVyYWJsZWAgYW5kIGZpbHRlcnMgYmFzZWQgb24gdGhlIHJlc3VsdCwga2VlcGluZyB0aGUgdHJhbnNmb3JtZWQgdmFsdWVzIHdoZXJlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBTb21lYC5cbiAqIFRoaXMgbWV0aG9kIGNvbWJpbmVzIGZpbHRlcmluZyBhbmQgbWFwcGluZyBmdW5jdGlvbmFsaXRpZXMsIGFsbG93aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgZmlsdGVyaW5nIG9mIGVsZW1lbnRzIGJhc2VkIG9uIGEgc2luZ2xlIGZ1bmN0aW9uIHBhc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiO1xuICpcbiAqIGNvbnN0IGRhdGEgPSBbMSwgMiwgMywgNCwgNV07XG4gKiBjb25zdCBldmVuU3F1YXJlcyA9ICh4OiBudW1iZXIpID0+IHggJSAyID09PSAwID8gT3B0aW9uLnNvbWUoeCAqIHgpIDogT3B0aW9uLm5vbmUoKTtcbiAqIGNvbnN0IHJlc3VsdCA9IEFycmF5LmZpbHRlck1hcChkYXRhLCBldmVuU3F1YXJlcyk7XG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFs0LCAxNl0pO1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXJNYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4ge1xuICBjb25zdCBhcyA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvID0gZihhc1tpXSwgaSk7XG4gICAgaWYgKE8uaXNTb21lKG8pKSB7XG4gICAgICBvdXQucHVzaChvLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBhbmQgZmlsdGVycyBiYXNlZCBvbiB0aGUgcmVzdWx0LCBzdG9wcGluZyB3aGVuIGEgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIG1ldGhvZCBjb21iaW5lcyBmaWx0ZXJpbmcgYW5kIG1hcHBpbmcgaW4gYSBzaW5nbGUgcGFzcywgYW5kIHNob3J0LWNpcmN1aXRzLCBpLmUuLCBzdG9wcyBwcm9jZXNzaW5nLCBhcyBzb29uIGFzIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBOb25lYC5cbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gdHJhbnNmb3JtIGFuIGFycmF5IGJ1dCBvbmx5IHVwIHRvIHRoZSBwb2ludCB3aGVyZSBhIGNlcnRhaW4gY29uZGl0aW9uIGhvbGRzIHRydWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiO1xuICpcbiAqIGNvbnN0IGRhdGEgPSBbMiwgNCwgNV07XG4gKiBjb25zdCB0b1NxdWFyZVRpbGxPZGQgPSAoeDogbnVtYmVyKSA9PiB4ICUgMiA9PT0gMCA/IE9wdGlvbi5zb21lKHggKiB4KSA6IE9wdGlvbi5ub25lKCk7XG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5maWx0ZXJNYXBXaGlsZShkYXRhLCB0b1NxdWFyZVRpbGxPZGQpO1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbNCwgMTZdKTtcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyTWFwV2hpbGUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBmb3IgKGNvbnN0IGEgb2Ygc2VsZikge1xuICAgIGNvbnN0IGIgPSBmKGEsIGkpO1xuICAgIGlmIChPLmlzU29tZShiKSkge1xuICAgICAgb3V0LnB1c2goYi52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBgSXRlcmFibGVgLCBjYXRlZ29yaXppbmcgdGhlIHJlc3VsdHMgaW50byB0d28gc2VwYXJhdGUgYXJyYXlzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBvcGVyYXRpb25zIHdoZXJlIGVhY2ggZWxlbWVudCBjYW4gcmVzdWx0IGluIHR3byBwb3NzaWJsZSB0eXBlcyxcbiAqIGFuZCB5b3Ugd2FudCB0byBzZXBhcmF0ZSB0aGVzZSB0eXBlcyBpbnRvIGRpZmZlcmVudCBjb2xsZWN0aW9ucy4gRm9yIGluc3RhbmNlLCBzZXBhcmF0aW5nIHZhbGlkYXRpb24gcmVzdWx0c1xuICogaW50byBzdWNjZXNzZXMgYW5kIGZhaWx1cmVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIjtcbiAqXG4gKiBjb25zdCBkYXRhID0gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zdCBpc0V2ZW4gPSAoeDogbnVtYmVyKSA9PiB4ICUgMiA9PT0gMFxuICogY29uc3QgcGFydGl0aW9uZWQgPSBBcnJheS5wYXJ0aXRpb25NYXAoZGF0YSwgeCA9PlxuICogICBpc0V2ZW4oeCkgPyBFaXRoZXIucmlnaHQoeCkgOiBFaXRoZXIubGVmdCh4KVxuICogKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGFydGl0aW9uZWQsIFtcbiAqICAgWzEsIDMsIDVdLFxuICogICBbMiwgNF1cbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnRpdGlvbk1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBbXTtcbiAgY29uc3QgcmlnaHQgPSBbXTtcbiAgY29uc3QgYXMgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlID0gZihhc1tpXSwgaSk7XG4gICAgaWYgKEUuaXNMZWZ0KGUpKSB7XG4gICAgICBsZWZ0LnB1c2goZS5sZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQucHVzaChlLnJpZ2h0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG59KTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBgU29tZWAgdmFsdWVzIGZyb20gYW4gYEl0ZXJhYmxlYCBvZiBgT3B0aW9uYHMsIGNvbGxlY3RpbmcgdGhlbSBpbnRvIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIEFycmF5LmdldFNvbWVzKFtPcHRpb24uc29tZSgxKSwgT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMildKSxcbiAqICAgWzEsIDJdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNvbWVzID0gLyojX19QVVJFX18qL2ZpbHRlck1hcChpZGVudGl0eSk7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgYExlZnRgIHZhbHVlcyBmcm9tIGFuIGBJdGVyYWJsZWAgb2YgYEVpdGhlcmBzLCBjb2xsZWN0aW5nIHRoZW0gaW50byBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5LCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBBcnJheS5nZXRMZWZ0cyhbRWl0aGVyLnJpZ2h0KDEpLCBFaXRoZXIubGVmdChcImVyclwiKSwgRWl0aGVyLnJpZ2h0KDIpXSksXG4gKiAgIFtcImVyclwiXVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMZWZ0cyA9IHNlbGYgPT4ge1xuICBjb25zdCBvdXQgPSBbXTtcbiAgZm9yIChjb25zdCBhIG9mIHNlbGYpIHtcbiAgICBpZiAoRS5pc0xlZnQoYSkpIHtcbiAgICAgIG91dC5wdXNoKGEubGVmdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGBSaWdodGAgdmFsdWVzIGZyb20gYW4gYEl0ZXJhYmxlYCBvZiBgRWl0aGVyYHMsIGNvbGxlY3RpbmcgdGhlbSBpbnRvIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIEFycmF5LmdldFJpZ2h0cyhbRWl0aGVyLnJpZ2h0KDEpLCBFaXRoZXIubGVmdChcImVyclwiKSwgRWl0aGVyLnJpZ2h0KDIpXSksXG4gKiAgIFsxLCAyXVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRSaWdodHMgPSBzZWxmID0+IHtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgaWYgKEUuaXNSaWdodChhKSkge1xuICAgICAgb3V0LnB1c2goYS5yaWdodCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgYXMgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhc1tpXSwgaSkpIHtcbiAgICAgIG91dC5wdXNoKGFzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBTZXBhcmF0ZSBlbGVtZW50cyBiYXNlZCBvbiBhIHByZWRpY2F0ZSB0aGF0IGFsc28gZXhwb3NlcyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJ0aXRpb24gPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgcHJlZGljYXRlKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBbXTtcbiAgY29uc3QgcmlnaHQgPSBbXTtcbiAgY29uc3QgYXMgPSBmcm9tSXRlcmFibGUoc2VsZik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFzW2ldLCBpKSkge1xuICAgICAgcmlnaHQucHVzaChhc1tpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQucHVzaChhc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufSk7XG4vKipcbiAqIFNlcGFyYXRlcyBhbiBgSXRlcmFibGVgIGludG8gdHdvIGFycmF5cyBiYXNlZCBvbiBhIHByZWRpY2F0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0XVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkucGFydGl0aW9uKG51bWJlcnMsIG4gPT4gbiAlIDIgPT09IDApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgW1sxLCAzXSwgWzIsIDRdXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2VwYXJhdGUgPSAvKiNfX1BVUkVfXyovcGFydGl0aW9uTWFwKGlkZW50aXR5KTtcbi8qKlxuICogUmVkdWNlcyBhbiBhcnJheSBmcm9tIHRoZSBsZWZ0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDIsIDNdXG4gKiBjb25zdCByZXN1bHQgPSBBcnJheS5yZWR1Y2UobnVtYmVycywgMCwgKGFjYywgbikgPT4gYWNjICsgbilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCA2KVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZvbGRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmVkdWNlID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGIsIGYpID0+IGZyb21JdGVyYWJsZShzZWxmKS5yZWR1Y2UoKGIsIGEsIGkpID0+IGYoYiwgYSwgaSksIGIpKTtcbi8qKlxuICogUmVkdWNlcyBhbiBhcnJheSBmcm9tIHRoZSByaWdodC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkucmVkdWNlUmlnaHQobnVtYmVycywgMCwgKGFjYywgbikgPT4gYWNjICsgbilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCA2KVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZvbGRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmVkdWNlUmlnaHQgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgYiwgZikgPT4gZnJvbUl0ZXJhYmxlKHNlbGYpLnJlZHVjZVJpZ2h0KChiLCBhLCBpKSA9PiBmKGIsIGEsIGkpLCBiKSk7XG4vKipcbiAqIExpZnRzIGEgcHJlZGljYXRlIGludG8gYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGlzRXZlbiA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwXG4gKiBjb25zdCB0byA9IEFycmF5LmxpZnRQcmVkaWNhdGUoaXNFdmVuKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh0bygxKSwgW10pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHRvKDIpLCBbMl0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgbGlmdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0UHJlZGljYXRlID0gcHJlZGljYXRlID0+IGIgPT4gcHJlZGljYXRlKGIpID8gW2JdIDogW107XG4vKipcbiAqIEBjYXRlZ29yeSBsaWZ0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxpZnRPcHRpb24gPSBmID0+ICguLi5hKSA9PiBmcm9tT3B0aW9uKGYoLi4uYSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZnJvbU51bGxhYmxlID0gYSA9PiBhID09IG51bGwgPyBlbXB0eSgpIDogW2FdO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbGlmdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsaWZ0TnVsbGFibGUgPSBmID0+ICguLi5hKSA9PiBmcm9tTnVsbGFibGUoZiguLi5hKSk7XG4vKipcbiAqIE1hcHMgb3ZlciBhbiBhcnJheSBhbmQgZmxhdHRlbnMgdGhlIHJlc3VsdCwgcmVtb3ZpbmcgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuZmxhdE1hcE51bGxhYmxlKG51bWJlcnMsIG4gPT4gKG4gJSAyID09PSAwID8gbnVsbCA6IG4pKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFsxLCAzXSlcbiAqXG4gKiAvLyBFeHBsYW5hdGlvbjpcbiAqIC8vIFRoZSBhcnJheSBvZiBudW1iZXJzIFsxLCAyLCAzXSBpcyBtYXBwZWQgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBudWxsIGZvciBldmVuIG51bWJlcnNcbiAqIC8vIGFuZCB0aGUgbnVtYmVyIGl0c2VsZiBmb3Igb2RkIG51bWJlcnMuIFRoZSByZXN1bHRpbmcgYXJyYXkgWzEsIG51bGwsIDNdIGlzIHRoZW4gZmxhdHRlbmVkXG4gKiAvLyB0byByZW1vdmUgbnVsbCB2YWx1ZXMsIHJlc3VsdGluZyBpbiBbMSwgM10uXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0TWFwTnVsbGFibGUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gZmxhdE1hcChzZWxmLCBhID0+IGZyb21OdWxsYWJsZShmKGEpKSkpO1xuLyoqXG4gKiBMaWZ0cyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBgRWl0aGVyYCBpbnRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5LlxuICogSWYgdGhlIGBFaXRoZXJgIGlzIGEgbGVmdCwgaXQgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cbiAqIElmIHRoZSBgRWl0aGVyYCBpcyBhIHJpZ2h0LCBpdCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHJpZ2h0IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHBhcnNlTnVtYmVyID0gKHM6IHN0cmluZyk6IEVpdGhlci5FaXRoZXI8bnVtYmVyLCBFcnJvcj4gPT5cbiAqICAgaXNOYU4oTnVtYmVyKHMpKSA/IEVpdGhlci5sZWZ0KG5ldyBFcnJvcihcIk5vdCBhIG51bWJlclwiKSkgOiBFaXRoZXIucmlnaHQoTnVtYmVyKHMpKVxuICpcbiAqIGNvbnN0IGxpZnRlZFBhcnNlTnVtYmVyID0gQXJyYXkubGlmdEVpdGhlcihwYXJzZU51bWJlcilcbiAqXG4gKiBjb25zdCByZXN1bHQxID0gbGlmdGVkUGFyc2VOdW1iZXIoXCI0MlwiKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQxLCBbNDJdKVxuICpcbiAqIGNvbnN0IHJlc3VsdDIgPSBsaWZ0ZWRQYXJzZU51bWJlcihcIm5vdCBhIG51bWJlclwiKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQyLCBbXSlcbiAqXG4gKiAvLyBFeHBsYW5hdGlvbjpcbiAqIC8vIFRoZSBmdW5jdGlvbiBwYXJzZU51bWJlciBpcyBsaWZ0ZWQgdG8gcmV0dXJuIGFuIGFycmF5LlxuICogLy8gV2hlbiBwYXJzaW5nIFwiNDJcIiwgaXQgcmV0dXJucyBhbiBFaXRoZXIubGVmdCB3aXRoIHRoZSBudW1iZXIgNDIsIHJlc3VsdGluZyBpbiBbNDJdLlxuICogLy8gV2hlbiBwYXJzaW5nIFwibm90IGEgbnVtYmVyXCIsIGl0IHJldHVybnMgYW4gRWl0aGVyLnJpZ2h0IHdpdGggYW4gZXJyb3IsIHJlc3VsdGluZyBpbiBhbiBlbXB0eSBhcnJheSBbXS5cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBsaWZ0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxpZnRFaXRoZXIgPSBmID0+ICguLi5hKSA9PiB7XG4gIGNvbnN0IGUgPSBmKC4uLmEpO1xuICByZXR1cm4gRS5pc0xlZnQoZSkgPyBbXSA6IFtlLnJpZ2h0XTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgcHJlZGljYXRlIGhvbGRzIHRydWUgZm9yIGV2ZXJ5IGBSZWFkb25seUFycmF5YCBlbGVtZW50LlxuICpcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBldmVyeSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCByZWZpbmVtZW50KSA9PiBzZWxmLmV2ZXJ5KHJlZmluZW1lbnQpKTtcbi8qKlxuICogQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaG9sZHMgdHJ1ZSBmb3Igc29tZSBgUmVhZG9ubHlBcnJheWAgZWxlbWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc29tZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IHNlbGYuc29tZShwcmVkaWNhdGUpKTtcbi8qKlxuICogRXh0ZW5kcyBhbiBhcnJheSB3aXRoIGEgZnVuY3Rpb24gdGhhdCBtYXBzIGVhY2ggc3ViYXJyYXkgdG8gYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkuZXh0ZW5kKG51bWJlcnMsIGFzID0+IGFzLmxlbmd0aClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBbMywgMiwgMV0pXG4gKlxuICogLy8gRXhwbGFuYXRpb246XG4gKiAvLyBUaGUgZnVuY3Rpb24gbWFwcyBlYWNoIHN1YmFycmF5IHN0YXJ0aW5nIGZyb20gZWFjaCBlbGVtZW50IHRvIGl0cyBsZW5ndGguXG4gKiAvLyBUaGUgc3ViYXJyYXlzIGFyZTogWzEsIDIsIDNdLCBbMiwgM10sIFszXS5cbiAqIC8vIFRoZSBsZW5ndGhzIGFyZTogMywgMiwgMS5cbiAqIC8vIFRoZXJlZm9yZSwgdGhlIHJlc3VsdCBpcyBbMywgMiwgMV0uXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGV4dGVuZCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBzZWxmLm1hcCgoXywgaSwgYXMpID0+IGYoYXMuc2xpY2UoaSkpKSk7XG4vKipcbiAqIEZpbmRzIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gYW4gYXJyYXkgYmFzZWQgb24gYSBjb21wYXJhdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXksIE9yZGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbWluID0gQXJyYXkubWluKFszLCAxLCAyXSwgT3JkZXIubnVtYmVyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW4sIDEpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBPKSA9PiBzZWxmLnJlZHVjZShPcmRlci5taW4oTykpKTtcbi8qKlxuICogRmluZHMgdGhlIG1heGltdW0gZWxlbWVudCBpbiBhbiBhcnJheSBiYXNlZCBvbiBhIGNvbXBhcmF0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSwgT3JkZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBtYXggPSBBcnJheS5tYXgoWzMsIDEsIDJdLCBPcmRlci5udW1iZXIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1heCwgMylcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWF4ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIE8pID0+IHNlbGYucmVkdWNlKE9yZGVyLm1heChPKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHVuZm9sZCA9IChiLCBmKSA9PiB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBsZXQgbmV4dCA9IGI7XG4gIGxldCBvO1xuICB3aGlsZSAoTy5pc1NvbWUobyA9IGYobmV4dCkpKSB7XG4gICAgY29uc3QgW2EsIGJdID0gby52YWx1ZTtcbiAgICBvdXQucHVzaChhKTtcbiAgICBuZXh0ID0gYjtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBPcmRlcmAgZm9yIGFuIGFycmF5IG9mIHZhbHVlcyBiYXNlZCBvbiBhIGdpdmVuIGBPcmRlcmAgZm9yIHRoZSBlbGVtZW50cyBvZiB0aGUgYXJyYXkuXG4gKiBUaGUgcmV0dXJuZWQgYE9yZGVyYCBjb21wYXJlcyB0d28gYXJyYXlzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBgT3JkZXJgIHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlzLlxuICogSWYgYWxsIGVsZW1lbnRzIGFyZSBlcXVhbCwgdGhlIGFycmF5cyBhcmUgdGhlbiBjb21wYXJlZCBiYXNlZCBvbiB0aGVpciBsZW5ndGguXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBjb21wYXJlIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgeW91IGhhdmUgYSBzcGVjaWZpYyB3YXkgb2YgY29tcGFyaW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPcmRlciA9IE9yZGVyLmFycmF5O1xuLyoqXG4gKiBDcmVhdGVzIGFuIGVxdWl2YWxlbmNlIHJlbGF0aW9uIGZvciBhcnJheXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMxID0gWzEsIDIsIDNdXG4gKiBjb25zdCBudW1iZXJzMiA9IFsxLCAyLCAzXVxuICogY29uc3QgZXEgPSBBcnJheS5nZXRFcXVpdmFsZW5jZTxudW1iZXI+KChhLCBiKSA9PiBhID09PSBiKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChlcShudW1iZXJzMSwgbnVtYmVyczIpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFcXVpdmFsZW5jZSA9IEVxdWl2YWxlbmNlLmFycmF5O1xuLyoqXG4gKiBQZXJmb3JtcyBhIHNpZGUtZWZmZWN0IGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIGBJdGVyYWJsZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgM11cbiAqIEFycmF5LmZvckVhY2gobnVtYmVycywgbiA9PiBjb25zb2xlLmxvZyhuKSkgLy8gMSwgMiwgM1xuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGZyb21JdGVyYWJsZShzZWxmKS5mb3JFYWNoKChhLCBpKSA9PiBmKGEsIGkpKSk7XG4vKipcbiAqIFJlbW92ZSBkdXBsaWNhdGVzIGZyb20gYW4gYEl0ZXJhYmxlYCB1c2luZyB0aGUgcHJvdmlkZWQgYGlzRXF1aXZhbGVudGAgZnVuY3Rpb24sXG4gKiBwcmVzZXJ2aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMiwgMywgMywgM11cbiAqIGNvbnN0IHVuaXF1ZSA9IEFycmF5LmRlZHVwZVdpdGgobnVtYmVycywgKGEsIGIpID0+IGEgPT09IGIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHVuaXF1ZSwgWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWR1cGVXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGlzRXF1aXZhbGVudCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IGZyb21JdGVyYWJsZShzZWxmKTtcbiAgaWYgKGlzTm9uRW1wdHlSZWFkb25seUFycmF5KGlucHV0KSkge1xuICAgIGNvbnN0IG91dCA9IFtoZWFkTm9uRW1wdHkoaW5wdXQpXTtcbiAgICBjb25zdCByZXN0ID0gdGFpbE5vbkVtcHR5KGlucHV0KTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdCkge1xuICAgICAgaWYgKG91dC5ldmVyeShhID0+ICFpc0VxdWl2YWxlbnQociwgYSkpKSB7XG4gICAgICAgIG91dC5wdXNoKHIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHJldHVybiBbXTtcbn0pO1xuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlcyBmcm9tIGFuIGBJdGVyYWJsZWAsIHByZXNlcnZpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBlcXVpdmFsZW5jZSB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgaXMgcHJvdmlkZWQgYnkgYEVxdWFsLmVxdWl2YWxlbmNlKClgIGZyb20gdGhlIGBFcXVhbGAgbW9kdWxlLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZGVkdXBlID0gc2VsZiA9PiBkZWR1cGVXaXRoKHNlbGYsIEVxdWFsLmVxdWl2YWxlbmNlKCkpO1xuLyoqXG4gKiBEZWR1cGxpY2F0ZXMgYWRqYWNlbnQgZWxlbWVudHMgdGhhdCBhcmUgaWRlbnRpY2FsIHVzaW5nIHRoZSBwcm92aWRlZCBgaXNFcXVpdmFsZW50YCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAxLCAyLCAyLCAzLCAzXVxuICogY29uc3QgdW5pcXVlID0gQXJyYXkuZGVkdXBlQWRqYWNlbnRXaXRoKG51bWJlcnMsIChhLCBiKSA9PiBhID09PSBiKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh1bmlxdWUsIFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZGVkdXBlQWRqYWNlbnRXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGlzRXF1aXZhbGVudCkgPT4ge1xuICBjb25zdCBvdXQgPSBbXTtcbiAgbGV0IGxhc3RBID0gTy5ub25lKCk7XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgaWYgKE8uaXNOb25lKGxhc3RBKSB8fCAhaXNFcXVpdmFsZW50KGEsIGxhc3RBLnZhbHVlKSkge1xuICAgICAgb3V0LnB1c2goYSk7XG4gICAgICBsYXN0QSA9IE8uc29tZShhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBEZWR1cGxpY2F0ZXMgYWRqYWNlbnQgZWxlbWVudHMgdGhhdCBhcmUgaWRlbnRpY2FsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gWzEsIDEsIDIsIDIsIDMsIDNdXG4gKiBjb25zdCB1bmlxdWUgPSBBcnJheS5kZWR1cGVBZGphY2VudChudW1iZXJzKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh1bmlxdWUsIFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZGVkdXBlQWRqYWNlbnQgPSAvKiNfX1BVUkVfXyovZGVkdXBlQWRqYWNlbnRXaXRoKCAvKiNfX1BVUkVfXyovRXF1YWwuZXF1aXZhbGVuY2UoKSk7XG4vKipcbiAqIEpvaW5zIHRoZSBlbGVtZW50cyB0b2dldGhlciB3aXRoIFwic2VwXCIgaW4gdGhlIG1pZGRsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3Qgc3RyaW5ncyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXVxuICogY29uc3Qgam9pbmVkID0gQXJyYXkuam9pbihzdHJpbmdzLCBcIi1cIilcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoam9pbmVkLCBcImEtYi1jXCIpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBmb2xkaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBqb2luID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHNlcCkgPT4gZnJvbUl0ZXJhYmxlKHNlbGYpLmpvaW4oc2VwKSk7XG4vKipcbiAqIFN0YXRlZnVsbHkgbWFwcyBvdmVyIHRoZSBjaHVuaywgcHJvZHVjaW5nIG5ldyBlbGVtZW50cyBvZiB0eXBlIGBCYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzXVxuICogY29uc3QgcmVzdWx0ID0gQXJyYXkubWFwQWNjdW0obnVtYmVycywgMCwgKGFjYywgbikgPT4gW2FjYyArIG4sIGFjYyArIG5dKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIFs2LCBbMSwgMywgNl1dKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICovXG5leHBvcnQgY29uc3QgbWFwQWNjdW0gPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgcywgZikgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGxldCBzMSA9IHM7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBmb3IgKGNvbnN0IGEgb2Ygc2VsZikge1xuICAgIGNvbnN0IHIgPSBmKHMxLCBhLCBpKTtcbiAgICBzMSA9IHJbMF07XG4gICAgb3V0LnB1c2goclsxXSk7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBbczEsIG91dF07XG59KTtcbi8qKlxuICogWmlwcyB0aGlzIGNodW5rIGNyb3Nzd2lzZSB3aXRoIHRoZSBzcGVjaWZpZWQgY2h1bmsgdXNpbmcgdGhlIHNwZWNpZmllZCBjb21iaW5lci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgYXJyYXkxID0gWzEsIDJdXG4gKiBjb25zdCBhcnJheTIgPSBbXCJhXCIsIFwiYlwiXVxuICogY29uc3QgcHJvZHVjdCA9IEFycmF5LmNhcnRlc2lhbldpdGgoYXJyYXkxLCBhcnJheTIsIChhLCBiKSA9PiBgJHthfS0ke2J9YClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocHJvZHVjdCwgW1wiMS1hXCIsIFwiMS1iXCIsIFwiMi1hXCIsIFwiMi1iXCJdKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcnRlc2lhbldpdGggPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGhhdCwgZikgPT4gZmxhdE1hcChzZWxmLCBhID0+IG1hcCh0aGF0LCBiID0+IGYoYSwgYikpKSk7XG4vKipcbiAqIFppcHMgdGhpcyBjaHVuayBjcm9zc3dpc2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGNodW5rLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBhcnJheTEgPSBbMSwgMl1cbiAqIGNvbnN0IGFycmF5MiA9IFtcImFcIiwgXCJiXCJdXG4gKiBjb25zdCBwcm9kdWN0ID0gQXJyYXkuY2FydGVzaWFuKGFycmF5MSwgYXJyYXkyKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwcm9kdWN0LCBbWzEsIFwiYVwiXSwgWzEsIFwiYlwiXSwgWzIsIFwiYVwiXSwgWzIsIFwiYlwiXV0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICovXG5leHBvcnQgY29uc3QgY2FydGVzaWFuID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGNhcnRlc2lhbldpdGgoc2VsZiwgdGhhdCwgKGEsIGIpID0+IFthLCBiXSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZG8gbm90YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogVGhlIFwiZG8gc2ltdWxhdGlvblwiIGZvciBhcnJheSBhbGxvd3MgeW91IHRvIHNlcXVlbnRpYWxseSBhcHBseSBvcGVyYXRpb25zIHRvIHRoZSBlbGVtZW50cyBvZiBhcnJheXMsIGp1c3QgYXMgbmVzdGVkIGxvb3BzIGFsbG93IHlvdSB0byBnbyB0aHJvdWdoIGFsbCBjb21iaW5hdGlvbnMgb2YgZWxlbWVudHMgaW4gYW4gYXJyYXlzLlxuICpcbiAqIEl0IGNhbiBiZSB1c2VkIHRvIHNpbXVsYXRlIFwiYXJyYXkgY29tcHJlaGVuc2lvblwiLlxuICogSXQncyBhIHRlY2huaXF1ZSB0aGF0IGFsbG93cyB5b3UgdG8gY3JlYXRlIG5ldyBhcnJheXMgYnkgaXRlcmF0aW5nIG92ZXIgZXhpc3Rpbmcgb25lcyBhbmQgYXBwbHlpbmcgc3BlY2lmaWMgKipjb25kaXRpb25zKiogb3IgKip0cmFuc2Zvcm1hdGlvbnMqKiB0byB0aGUgZWxlbWVudHMuIEl0J3MgbGlrZSBhc3NlbWJsaW5nIGEgbmV3IGNvbGxlY3Rpb24gZnJvbSBwaWVjZXMgb2Ygb3RoZXIgY29sbGVjdGlvbnMgYmFzZWQgb24gY2VydGFpbiBydWxlcy5cbiAqXG4gKiBIZXJlJ3MgaG93IHRoZSBkbyBzaW11bGF0aW9uIHdvcmtzOlxuICpcbiAqIDEuIFN0YXJ0IHRoZSBkbyBzaW11bGF0aW9uIHVzaW5nIHRoZSBgRG9gIHZhbHVlXG4gKiAyLiBXaXRoaW4gdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gdXNlIHRoZSBgYmluZGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIGBBcnJheWAgdmFsdWVzXG4gKiAzLiBZb3UgY2FuIGFjY3VtdWxhdGUgbXVsdGlwbGUgYGJpbmRgIHN0YXRlbWVudHMgdG8gZGVmaW5lIG11bHRpcGxlIHZhcmlhYmxlcyB3aXRoaW4gdGhlIHNjb3BlXG4gKiA0LiBJbnNpZGUgdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBsZXRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBzaW1wbGUgdmFsdWVzXG4gKiA1LiBSZWd1bGFyIGBPcHRpb25gIGZ1bmN0aW9ucyBsaWtlIGBtYXBgIGFuZCBgZmlsdGVyYCBjYW4gc3RpbGwgYmUgdXNlZCB3aXRoaW4gdGhlIGRvIHNpbXVsYXRpb24uIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIHJlY2VpdmUgdGhlIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhcyBhcmd1bWVudHMgd2l0aGluIHRoZSBzY29wZVxuICpcbiAqIEBzZWUge0BsaW5rIGJpbmRUb31cbiAqIEBzZWUge0BsaW5rIGJpbmR9XG4gKiBAc2VlIHtAbGluayBsZXRfIGxldH1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFycmF5IGFzIEFyciwgcGlwZSB9IGZyb20gXCJlZmZlY3RcIlxuICogY29uc3QgZG9SZXN1bHQgPSBwaXBlKFxuICogICBBcnIuRG8sXG4gKiAgIEFyci5iaW5kKFwieFwiLCAoKSA9PiBbMSwgMywgNV0pLFxuICogICBBcnIuYmluZChcInlcIiwgKCkgPT4gWzIsIDQsIDZdKSxcbiAqICAgQXJyLmZpbHRlcigoeyB4LCB5IH0pID0+IHggPCB5KSwgLy8gY29uZGl0aW9uXG4gKiAgIEFyci5tYXAoKHsgeCwgeSB9KSA9PiBbeCwgeV0gYXMgY29uc3QpIC8vIHRyYW5zZm9ybWF0aW9uXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGRvUmVzdWx0LCBbWzEsIDJdLCBbMSwgNF0sIFsxLCA2XSwgWzMsIDRdLCBbMywgNl0sIFs1LCA2XV0pXG4gKlxuICogLy8gZXF1aXZhbGVudFxuICogY29uc3QgeCA9IFsxLCAzLCA1XSxcbiAqICAgICAgIHkgPSBbMiwgNCwgNl0sXG4gKiAgICAgICByZXN1bHQgPSBbXTtcbiAqIGZvcihsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gKiAgIGZvcihsZXQgaiA9IDA7IGogPCB5Lmxlbmd0aDsgaisrKSB7XG4gKiAgICAgY29uc3QgX3ggPSB4W2ldLCBfeSA9IHlbal07XG4gKiAgICAgaWYoX3ggPCBfeSkgcmVzdWx0LnB1c2goW194LCBfeV0gYXMgY29uc3QpXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDMuMi4wXG4gKi9cbmV4cG9ydCBjb25zdCBEbyA9IC8qI19fUFVSRV9fKi9vZih7fSk7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBmb3IgYXJyYXkgYWxsb3dzIHlvdSB0byBzZXF1ZW50aWFsbHkgYXBwbHkgb3BlcmF0aW9ucyB0byB0aGUgZWxlbWVudHMgb2YgYXJyYXlzLCBqdXN0IGFzIG5lc3RlZCBsb29wcyBhbGxvdyB5b3UgdG8gZ28gdGhyb3VnaCBhbGwgY29tYmluYXRpb25zIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5cy5cbiAqXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBcImFycmF5IGNvbXByZWhlbnNpb25cIi5cbiAqIEl0J3MgYSB0ZWNobmlxdWUgdGhhdCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgYXJyYXlzIGJ5IGl0ZXJhdGluZyBvdmVyIGV4aXN0aW5nIG9uZXMgYW5kIGFwcGx5aW5nIHNwZWNpZmljICoqY29uZGl0aW9ucyoqIG9yICoqdHJhbnNmb3JtYXRpb25zKiogdG8gdGhlIGVsZW1lbnRzLiBJdCdzIGxpa2UgYXNzZW1ibGluZyBhIG5ldyBjb2xsZWN0aW9uIGZyb20gcGllY2VzIG9mIG90aGVyIGNvbGxlY3Rpb25zIGJhc2VkIG9uIGNlcnRhaW4gcnVsZXMuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgQXJyYXlgIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICogNS4gUmVndWxhciBgT3B0aW9uYCBmdW5jdGlvbnMgbGlrZSBgbWFwYCBhbmQgYGZpbHRlcmAgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aGluIHRoZSBkbyBzaW11bGF0aW9uLiBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYXMgYXJndW1lbnRzIHdpdGhpbiB0aGUgc2NvcGVcbiAqXG4gKiBAc2VlIHtAbGluayBiaW5kVG99XG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgYXMgQXJyLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKiBjb25zdCBkb1Jlc3VsdCA9IHBpcGUoXG4gKiAgIEFyci5EbyxcbiAqICAgQXJyLmJpbmQoXCJ4XCIsICgpID0+IFsxLCAzLCA1XSksXG4gKiAgIEFyci5iaW5kKFwieVwiLCAoKSA9PiBbMiwgNCwgNl0pLFxuICogICBBcnIuZmlsdGVyKCh7IHgsIHkgfSkgPT4geCA8IHkpLCAvLyBjb25kaXRpb25cbiAqICAgQXJyLm1hcCgoeyB4LCB5IH0pID0+IFt4LCB5XSBhcyBjb25zdCkgLy8gdHJhbnNmb3JtYXRpb25cbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZG9SZXN1bHQsIFtbMSwgMl0sIFsxLCA0XSwgWzEsIDZdLCBbMywgNF0sIFszLCA2XSwgWzUsIDZdXSlcbiAqXG4gKiAvLyBlcXVpdmFsZW50XG4gKiBjb25zdCB4ID0gWzEsIDMsIDVdLFxuICogICAgICAgeSA9IFsyLCA0LCA2XSxcbiAqICAgICAgIHJlc3VsdCA9IFtdO1xuICogZm9yKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAqICAgZm9yKGxldCBqID0gMDsgaiA8IHkubGVuZ3RoOyBqKyspIHtcbiAqICAgICBjb25zdCBfeCA9IHhbaV0sIF95ID0geVtqXTtcbiAqICAgICBpZihfeCA8IF95KSByZXN1bHQucHVzaChbX3gsIF95XSBhcyBjb25zdClcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmQgPSAvKiNfX1BVUkVfXyovZG9Ob3RhdGlvbi5iaW5kKG1hcCwgZmxhdE1hcCk7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBmb3IgYXJyYXkgYWxsb3dzIHlvdSB0byBzZXF1ZW50aWFsbHkgYXBwbHkgb3BlcmF0aW9ucyB0byB0aGUgZWxlbWVudHMgb2YgYXJyYXlzLCBqdXN0IGFzIG5lc3RlZCBsb29wcyBhbGxvdyB5b3UgdG8gZ28gdGhyb3VnaCBhbGwgY29tYmluYXRpb25zIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5cy5cbiAqXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBcImFycmF5IGNvbXByZWhlbnNpb25cIi5cbiAqIEl0J3MgYSB0ZWNobmlxdWUgdGhhdCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgYXJyYXlzIGJ5IGl0ZXJhdGluZyBvdmVyIGV4aXN0aW5nIG9uZXMgYW5kIGFwcGx5aW5nIHNwZWNpZmljICoqY29uZGl0aW9ucyoqIG9yICoqdHJhbnNmb3JtYXRpb25zKiogdG8gdGhlIGVsZW1lbnRzLiBJdCdzIGxpa2UgYXNzZW1ibGluZyBhIG5ldyBjb2xsZWN0aW9uIGZyb20gcGllY2VzIG9mIG90aGVyIGNvbGxlY3Rpb25zIGJhc2VkIG9uIGNlcnRhaW4gcnVsZXMuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgQXJyYXlgIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICogNS4gUmVndWxhciBgT3B0aW9uYCBmdW5jdGlvbnMgbGlrZSBgbWFwYCBhbmQgYGZpbHRlcmAgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aGluIHRoZSBkbyBzaW11bGF0aW9uLiBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYXMgYXJndW1lbnRzIHdpdGhpbiB0aGUgc2NvcGVcbiAqXG4gKiBAc2VlIHtAbGluayBiaW5kVG99XG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXJyYXkgYXMgQXJyLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKiBjb25zdCBkb1Jlc3VsdCA9IHBpcGUoXG4gKiAgIEFyci5EbyxcbiAqICAgQXJyLmJpbmQoXCJ4XCIsICgpID0+IFsxLCAzLCA1XSksXG4gKiAgIEFyci5iaW5kKFwieVwiLCAoKSA9PiBbMiwgNCwgNl0pLFxuICogICBBcnIuZmlsdGVyKCh7IHgsIHkgfSkgPT4geCA8IHkpLCAvLyBjb25kaXRpb25cbiAqICAgQXJyLm1hcCgoeyB4LCB5IH0pID0+IFt4LCB5XSBhcyBjb25zdCkgLy8gdHJhbnNmb3JtYXRpb25cbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZG9SZXN1bHQsIFtbMSwgMl0sIFsxLCA0XSwgWzEsIDZdLCBbMywgNF0sIFszLCA2XSwgWzUsIDZdXSlcbiAqXG4gKiAvLyBlcXVpdmFsZW50XG4gKiBjb25zdCB4ID0gWzEsIDMsIDVdLFxuICogICAgICAgeSA9IFsyLCA0LCA2XSxcbiAqICAgICAgIHJlc3VsdCA9IFtdO1xuICogZm9yKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAqICAgZm9yKGxldCBqID0gMDsgaiA8IHkubGVuZ3RoOyBqKyspIHtcbiAqICAgICBjb25zdCBfeCA9IHhbaV0sIF95ID0geVtqXTtcbiAqICAgICBpZihfeCA8IF95KSByZXN1bHQucHVzaChbX3gsIF95XSBhcyBjb25zdClcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRUbyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmJpbmRUbyhtYXApO1xuY29uc3QgbGV0XyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmxldF8obWFwKTtcbmV4cG9ydCB7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBmb3IgYXJyYXkgYWxsb3dzIHlvdSB0byBzZXF1ZW50aWFsbHkgYXBwbHkgb3BlcmF0aW9ucyB0byB0aGUgZWxlbWVudHMgb2YgYXJyYXlzLCBqdXN0IGFzIG5lc3RlZCBsb29wcyBhbGxvdyB5b3UgdG8gZ28gdGhyb3VnaCBhbGwgY29tYmluYXRpb25zIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5cy5cbiAqXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBcImFycmF5IGNvbXByZWhlbnNpb25cIi5cbiAqIEl0J3MgYSB0ZWNobmlxdWUgdGhhdCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgYXJyYXlzIGJ5IGl0ZXJhdGluZyBvdmVyIGV4aXN0aW5nIG9uZXMgYW5kIGFwcGx5aW5nIHNwZWNpZmljICoqY29uZGl0aW9ucyoqIG9yICoqdHJhbnNmb3JtYXRpb25zKiogdG8gdGhlIGVsZW1lbnRzLiBJdCdzIGxpa2UgYXNzZW1ibGluZyBhIG5ldyBjb2xsZWN0aW9uIGZyb20gcGllY2VzIG9mIG90aGVyIGNvbGxlY3Rpb25zIGJhc2VkIG9uIGNlcnRhaW4gcnVsZXMuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgQXJyYXlgIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICogNS4gUmVndWxhciBgT3B0aW9uYCBmdW5jdGlvbnMgbGlrZSBgbWFwYCBhbmQgYGZpbHRlcmAgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aGluIHRoZSBkbyBzaW11bGF0aW9uLiBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYXMgYXJndW1lbnRzIHdpdGhpbiB0aGUgc2NvcGVcbiAqXG4gKiBAc2VlIHtAbGluayBiaW5kVG99XG4gKiBAc2VlIHtAbGluayBiaW5kfVxuICogQHNlZSB7QGxpbmsgRG99XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBcnJheSBhcyBBcnIsIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqIGNvbnN0IGRvUmVzdWx0ID0gcGlwZShcbiAqICAgQXJyLkRvLFxuICogICBBcnIuYmluZChcInhcIiwgKCkgPT4gWzEsIDMsIDVdKSxcbiAqICAgQXJyLmJpbmQoXCJ5XCIsICgpID0+IFsyLCA0LCA2XSksXG4gKiAgIEFyci5maWx0ZXIoKHsgeCwgeSB9KSA9PiB4IDwgeSksIC8vIGNvbmRpdGlvblxuICogICBBcnIubWFwKCh7IHgsIHkgfSkgPT4gW3gsIHldIGFzIGNvbnN0KSAvLyB0cmFuc2Zvcm1hdGlvblxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChkb1Jlc3VsdCwgW1sxLCAyXSwgWzEsIDRdLCBbMSwgNl0sIFszLCA0XSwgWzMsIDZdLCBbNSwgNl1dKVxuICpcbiAqIC8vIGVxdWl2YWxlbnRcbiAqIGNvbnN0IHggPSBbMSwgMywgNV0sXG4gKiAgICAgICB5ID0gWzIsIDQsIDZdLFxuICogICAgICAgcmVzdWx0ID0gW107XG4gKiBmb3IobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICogICBmb3IobGV0IGogPSAwOyBqIDwgeS5sZW5ndGg7IGorKykge1xuICogICAgIGNvbnN0IF94ID0geFtpXSwgX3kgPSB5W2pdO1xuICogICAgIGlmKF94IDwgX3kpIHJlc3VsdC5wdXNoKFtfeCwgX3ldIGFzIGNvbnN0KVxuICogICB9XG4gKiB9XG4gKlxuICogYGBgXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAzLjIuMFxuICovXG5sZXRfIGFzIGxldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXkuanMubWFwIl0sIm5hbWVzIjpbIkUiLCJFcXVhbCIsIkVxdWl2YWxlbmNlIiwiZHVhbCIsImlkZW50aXR5IiwicmVhZG9ubHlBcnJheSIsImRvTm90YXRpb24iLCJFZmZlY3RJdGVyYWJsZSIsIk8iLCJPcmRlciIsImlzQm9vbGVhbiIsIlJlY29yZCIsIlR1cGxlIiwibWFrZSIsImVsZW1lbnRzIiwiYWxsb2NhdGUiLCJuIiwiQXJyYXkiLCJtYWtlQnkiLCJmIiwibWF4IiwiTWF0aCIsImZsb29yIiwib3V0IiwiaSIsInJhbmdlIiwic3RhcnQiLCJlbmQiLCJyZXBsaWNhdGUiLCJhIiwiZnJvbUl0ZXJhYmxlIiwiY29sbGVjdGlvbiIsImlzQXJyYXkiLCJmcm9tIiwiZW5zdXJlIiwic2VsZiIsImZyb21SZWNvcmQiLCJ0b0VudHJpZXMiLCJmcm9tT3B0aW9uIiwidG9BcnJheSIsIm1hdGNoIiwib25FbXB0eSIsIm9uTm9uRW1wdHkiLCJpc05vbkVtcHR5UmVhZG9ubHlBcnJheSIsIm1hdGNoTGVmdCIsImhlYWROb25FbXB0eSIsInRhaWxOb25FbXB0eSIsIm1hdGNoUmlnaHQiLCJpbml0Tm9uRW1wdHkiLCJsYXN0Tm9uRW1wdHkiLCJwcmVwZW5kIiwiaGVhZCIsInByZXBlbmRBbGwiLCJ0aGF0IiwiY29uY2F0IiwiYXBwZW5kIiwibGFzdCIsImFwcGVuZEFsbCIsInNjYW4iLCJiIiwic2NhblJpZ2h0IiwiaW5wdXQiLCJsZW5ndGgiLCJpc0VtcHR5QXJyYXkiLCJpc0VtcHR5UmVhZG9ubHlBcnJheSIsImlzTm9uRW1wdHlBcnJheSIsImlzT3V0T2ZCb3VuZCIsImFzIiwiY2xhbXAiLCJtaW4iLCJnZXQiLCJpbmRleCIsIm5vbmUiLCJzb21lIiwidW5zYWZlR2V0IiwiRXJyb3IiLCJ1bnByZXBlbmQiLCJ1bmFwcGVuZCIsInRhaWwiLCJzbGljZSIsImluaXQiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVdoaWxlIiwicHJlZGljYXRlIiwicHVzaCIsInNwYW5JbmRleCIsInNwYW4iLCJzcGxpdEF0IiwiZHJvcCIsImRyb3BSaWdodCIsImRyb3BXaGlsZSIsImZpbmRGaXJzdEluZGV4IiwiZmluZExhc3RJbmRleCIsImZpbmRGaXJzdCIsImZpbmRMYXN0IiwibyIsImlzU29tZSIsImluc2VydEF0Iiwic3BsaWNlIiwicmVwbGFjZSIsIm1vZGlmeSIsInJlcGxhY2VPcHRpb24iLCJtb2RpZnlPcHRpb24iLCJnZXRPckVsc2UiLCJuZXh0IiwicmVtb3ZlIiwicmV2ZXJzZSIsInNvcnQiLCJzb3J0V2l0aCIsIm9yZGVyIiwibWFwIiwieCIsInNvcnRCeSIsIm9yZGVycyIsInNvcnRCeUFsbCIsImNvbWJpbmVBbGwiLCJ6aXAiLCJ6aXBXaXRoIiwiYnMiLCJsZW4iLCJ1bnppcCIsImZhIiwiZmIiLCJpbnRlcnNwZXJzZSIsIm1pZGRsZSIsIm1vZGlmeU5vbkVtcHR5SGVhZCIsInNldE5vbkVtcHR5SGVhZCIsIm1vZGlmeU5vbkVtcHR5TGFzdCIsInNldE5vbkVtcHR5TGFzdCIsInJvdGF0ZSIsIm0iLCJyb3VuZCIsImFicyIsImNvcHkiLCJzIiwic3BsaXROb25FbXB0eUF0IiwiY29udGFpbnNXaXRoIiwiaXNFcXVpdmFsZW50IiwiX2VxdWl2YWxlbmNlIiwiZXF1aXZhbGVuY2UiLCJjb250YWlucyIsImNob3AiLCJyZXN0IiwiX24iLCJzcGxpdCIsImNodW5rc09mIiwiY2VpbCIsInNwbGl0V2hlcmUiLCJwYWQiLCJmaWxsIiwiZ3JvdXBXaXRoIiwiaCIsImdyb3VwIiwiZ3JvdXBCeSIsImsiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ1bmlvbldpdGgiLCJkZWR1cGUiLCJkZWR1cGVXaXRoIiwidW5pb24iLCJpbnRlcnNlY3Rpb25XaXRoIiwiaGFzIiwiZmlsdGVyIiwiaW50ZXJzZWN0aW9uIiwiZGlmZmVyZW5jZVdpdGgiLCJkaWZmZXJlbmNlIiwiZW1wdHkiLCJvZiIsImZsYXRNYXAiLCJpbm5lciIsImoiLCJmbGF0dGVuIiwiZmlsdGVyTWFwIiwidmFsdWUiLCJmaWx0ZXJNYXBXaGlsZSIsInBhcnRpdGlvbk1hcCIsImxlZnQiLCJyaWdodCIsImUiLCJpc0xlZnQiLCJnZXRTb21lcyIsImdldExlZnRzIiwiZ2V0UmlnaHRzIiwiaXNSaWdodCIsInBhcnRpdGlvbiIsInNlcGFyYXRlIiwicmVkdWNlIiwicmVkdWNlUmlnaHQiLCJsaWZ0UHJlZGljYXRlIiwibGlmdE9wdGlvbiIsImZyb21OdWxsYWJsZSIsImxpZnROdWxsYWJsZSIsImZsYXRNYXBOdWxsYWJsZSIsImxpZnRFaXRoZXIiLCJldmVyeSIsInJlZmluZW1lbnQiLCJleHRlbmQiLCJfIiwidW5mb2xkIiwiZ2V0T3JkZXIiLCJhcnJheSIsImdldEVxdWl2YWxlbmNlIiwiZm9yRWFjaCIsInIiLCJkZWR1cGVBZGphY2VudFdpdGgiLCJsYXN0QSIsImlzTm9uZSIsImRlZHVwZUFkamFjZW50Iiwiam9pbiIsInNlcCIsIm1hcEFjY3VtIiwiczEiLCJjYXJ0ZXNpYW5XaXRoIiwiY2FydGVzaWFuIiwiRG8iLCJiaW5kIiwiYmluZFRvIiwibGV0XyIsImxldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Context.js":
/*!*************************************************!*\
  !*** ./node_modules/effect/dist/esm/Context.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenericTag: () => (/* binding */ GenericTag),\n/* harmony export */   Reference: () => (/* binding */ Reference),\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getOption: () => (/* binding */ getOption),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   isContext: () => (/* binding */ isContext),\n/* harmony export */   isReference: () => (/* binding */ isReference),\n/* harmony export */   isTag: () => (/* binding */ isTag),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeAll: () => (/* binding */ mergeAll),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   unsafeGet: () => (/* binding */ unsafeGet),\n/* harmony export */   unsafeMake: () => (/* binding */ unsafeMake)\n/* harmony export */ });\n/* harmony import */ var _internal_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/context.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/context.js\");\n\nconst TagTypeId = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.TagTypeId;\nconst ReferenceTypeId = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.ReferenceTypeId;\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * @param key - A key that will be used to compare tags.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */ const GenericTag = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.makeGenericTag;\nconst TypeId = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.TypeId;\n/**\n * @since 2.0.0\n * @category constructors\n */ const unsafeMake = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.makeContext;\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @param input - The value to be checked if it is a `Context`.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n * ```\n *\n * @since 2.0.0\n * @category guards\n */ const isContext = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.isContext;\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @param input - The value to be checked if it is a `Tag`.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n * ```\n *\n * @since 2.0.0\n * @category guards\n */ const isTag = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.isTag;\n/**\n * Checks if the provided argument is a `Reference`.\n *\n * @param input - The value to be checked if it is a `Reference`.\n * @since 3.11.0\n * @category guards\n * @experimental\n */ const isReference = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.isReference;\n/**\n * Returns an empty `Context`.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */ const empty = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.empty;\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */ const make = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.make;\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * ```ts\n * import { Context, pipe } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n */ const add = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.add;\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * ```ts\n * import { pipe, Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n * @category getters\n */ const get = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.get;\n/**\n * Get a service from the context that corresponds to the given tag, or\n * use the fallback value.\n *\n * @since 3.7.0\n * @category getters\n */ const getOrElse = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.getOrElse;\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n * ```\n *\n * @since 2.0.0\n * @category unsafe\n */ const unsafeGet = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.unsafeGet;\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * ```ts\n * import { Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category getters\n */ const getOption = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.getOption;\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @param self - The first `Context` to merge.\n * @param that - The second `Context` to merge.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n */ const merge = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.merge;\n/**\n * Merges any number of `Context`s, returning a new `Context` containing the services of all.\n *\n * @param ctxs - The `Context`s to merge.\n *\n * @example\n * ```ts\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n * const Host = Context.GenericTag<{ HOST: string }>(\"Host\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n * const thirdContext = Context.make(Host, { HOST: \"localhost\" })\n *\n * const Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * assert.deepStrictEqual(Context.get(Services, Host), { HOST: \"localhost\" })\n * ```\n *\n * @since 3.12.0\n */ const mergeAll = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.mergeAll;\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @param self - The `Context` to prune services from.\n * @param tags - The list of `Tag`s to be included in the new `Context`.\n *\n * @example\n * ```ts\n * import { pipe, Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n * ```\n *\n * @since 2.0.0\n */ const pick = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.pick;\n/**\n * @since 2.0.0\n */ const omit = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.omit;\n/**\n * @example\n * ```ts\n * import { Context, Layer } from \"effect\"\n *\n * class MyTag extends Context.Tag(\"MyTag\")<\n *  MyTag,\n *  { readonly myNum: number }\n * >() {\n *  static Live = Layer.succeed(this, { myNum: 108 })\n * }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */ const Tag = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.Tag;\n/**\n * Creates a context tag with a default value.\n *\n * **Details**\n *\n * `Context.Reference` allows you to create a tag that can hold a value. You can\n * provide a default value for the service, which will automatically be used\n * when the context is accessed, or override it with a custom implementation\n * when needed.\n *\n * @example\n * ```ts\n * // Title: Declaring a Tag with a default value\n * import { Context, Effect } from \"effect\"\n *\n * class SpecialNumber extends Context.Reference<SpecialNumber>()(\n *   \"SpecialNumber\",\n *   { defaultValue: () => 2048 }\n * ) {}\n *\n * //       Effect<void, never, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const specialNumber = yield* SpecialNumber\n *   console.log(`The special number is ${specialNumber}`)\n * })\n *\n * // No need to provide the SpecialNumber implementation\n * Effect.runPromise(program)\n * // Output: The special number is 2048\n * ```\n *\n * @example\n * ```ts\n * // Title: Overriding the default value\n * import { Context, Effect } from \"effect\"\n *\n * class SpecialNumber extends Context.Reference<SpecialNumber>()(\n *   \"SpecialNumber\",\n *   { defaultValue: () => 2048 }\n * ) {}\n *\n * const program = Effect.gen(function* () {\n *   const specialNumber = yield* SpecialNumber\n *   console.log(`The special number is ${specialNumber}`)\n * })\n *\n * Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n * // Output: The special number is -1\n * ```\n *\n * @since 3.11.0\n * @category constructors\n * @experimental\n */ const Reference = _internal_context_js__WEBPACK_IMPORTED_MODULE_0__.Reference; //# sourceMappingURL=Context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRDtBQUNsRCxNQUFNQyxZQUFZRCwyREFBa0I7QUFDcEMsTUFBTUUsa0JBQWtCRixpRUFBd0I7QUFDaEQ7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxNQUFNRyxhQUFhSCxnRUFBdUIsQ0FBQztBQUNsRCxNQUFNSyxTQUFTTCx3REFBZTtBQUM5Qjs7O0NBR0MsR0FDTSxNQUFNTSxhQUFhTiw2REFBb0IsQ0FBQztBQUMvQzs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLE1BQU1RLFlBQVlSLDJEQUFrQixDQUFDO0FBQzVDOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTVMsUUFBUVQsdURBQWMsQ0FBQztBQUNwQzs7Ozs7OztDQU9DLEdBQ00sTUFBTVUsY0FBY1YsNkRBQW9CLENBQUM7QUFDaEQ7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTVcsUUFBUVgsdURBQWMsQ0FBQztBQUNwQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1ZLE9BQU9aLHNEQUFhLENBQUM7QUFDbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxNQUFNYSxNQUFNYixxREFBWSxDQUFDO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNNLE1BQU1jLE1BQU1kLHFEQUFZLENBQUM7QUFDaEM7Ozs7OztDQU1DLEdBQ00sTUFBTWUsWUFBWWYsMkRBQWtCLENBQUM7QUFDNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNNLE1BQU1nQixZQUFZaEIsMkRBQWtCLENBQUM7QUFDNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxNQUFNaUIsWUFBWWpCLDJEQUFrQixDQUFDO0FBQzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNNLE1BQU1rQixRQUFRbEIsdURBQWMsQ0FBQztBQUNwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNNLE1BQU1tQixXQUFXbkIsMERBQWlCLENBQUM7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxNQUFNb0IsT0FBT3BCLHNEQUFhLENBQUM7QUFDbEM7O0NBRUMsR0FDTSxNQUFNcUIsT0FBT3JCLHNEQUFhLENBQUM7QUFDbEM7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTXNCLE1BQU10QixxREFBWSxDQUFDO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzREMsR0FDTSxNQUFNdUIsWUFBWXZCLDJEQUFrQixDQUFDLENBQzVDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vQ29udGV4dC5qcz83OGZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGludGVybmFsIGZyb20gXCIuL2ludGVybmFsL2NvbnRleHQuanNcIjtcbmNvbnN0IFRhZ1R5cGVJZCA9IGludGVybmFsLlRhZ1R5cGVJZDtcbmNvbnN0IFJlZmVyZW5jZVR5cGVJZCA9IGludGVybmFsLlJlZmVyZW5jZVR5cGVJZDtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgVGFnYCBpbnN0YW5jZSB3aXRoIGFuIG9wdGlvbmFsIGtleSBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIGtleSAtIEEga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbXBhcmUgdGFncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoQ29udGV4dC5HZW5lcmljVGFnKFwiUE9SVFwiKS5rZXkgPT09IENvbnRleHQuR2VuZXJpY1RhZyhcIlBPUlRcIikua2V5LCB0cnVlKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBHZW5lcmljVGFnID0gaW50ZXJuYWwubWFrZUdlbmVyaWNUYWc7XG5jb25zdCBUeXBlSWQgPSBpbnRlcm5hbC5UeXBlSWQ7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgdW5zYWZlTWFrZSA9IGludGVybmFsLm1ha2VDb250ZXh0O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGlzIGEgYENvbnRleHRgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkIGlmIGl0IGlzIGEgYENvbnRleHRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChDb250ZXh0LmlzQ29udGV4dChDb250ZXh0LmVtcHR5KCkpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0NvbnRleHQgPSBpbnRlcm5hbC5pc0NvbnRleHQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnQgaXMgYSBgVGFnYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZCBpZiBpdCBpcyBhIGBUYWdgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChDb250ZXh0LmlzVGFnKENvbnRleHQuR2VuZXJpY1RhZyhcIlRhZ1wiKSksIHRydWUpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGFnID0gaW50ZXJuYWwuaXNUYWc7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnQgaXMgYSBgUmVmZXJlbmNlYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZCBpZiBpdCBpcyBhIGBSZWZlcmVuY2VgLlxuICogQHNpbmNlIDMuMTEuMFxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY29uc3QgaXNSZWZlcmVuY2UgPSBpbnRlcm5hbC5pc1JlZmVyZW5jZTtcbi8qKlxuICogUmV0dXJucyBhbiBlbXB0eSBgQ29udGV4dGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKENvbnRleHQuaXNDb250ZXh0KENvbnRleHQuZW1wdHkoKSksIHRydWUpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5ID0gaW50ZXJuYWwuZW1wdHk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYENvbnRleHRgIHdpdGggYSBzaW5nbGUgc2VydmljZSBhc3NvY2lhdGVkIHRvIHRoZSB0YWcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqXG4gKiBjb25zdCBTZXJ2aWNlcyA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IG1ha2UgPSBpbnRlcm5hbC5tYWtlO1xuLyoqXG4gKiBBZGRzIGEgc2VydmljZSB0byBhIGdpdmVuIGBDb250ZXh0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbnRleHQsIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBQb3J0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgUE9SVDogbnVtYmVyIH0+KFwiUG9ydFwiKVxuICogY29uc3QgVGltZW91dCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFRJTUVPVVQ6IG51bWJlciB9PihcIlRpbWVvdXRcIilcbiAqXG4gKiBjb25zdCBzb21lQ29udGV4dCA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqXG4gKiBjb25zdCBTZXJ2aWNlcyA9IHBpcGUoXG4gKiAgIHNvbWVDb250ZXh0LFxuICogICBDb250ZXh0LmFkZChUaW1lb3V0LCB7IFRJTUVPVVQ6IDUwMDAgfSlcbiAqIClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBUaW1lb3V0KSwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IGludGVybmFsLmFkZDtcbi8qKlxuICogR2V0IGEgc2VydmljZSBmcm9tIHRoZSBjb250ZXh0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIHRhZy5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgQ29udGV4dGAgdG8gc2VhcmNoIGZvciB0aGUgc2VydmljZS5cbiAqIEBwYXJhbSB0YWcgLSBUaGUgYFRhZ2Agb2YgdGhlIHNlcnZpY2UgdG8gcmV0cmlldmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqIGNvbnN0IFRpbWVvdXQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBUSU1FT1VUOiBudW1iZXIgfT4oXCJUaW1lb3V0XCIpXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBwaXBlKFxuICogICBDb250ZXh0Lm1ha2UoUG9ydCwgeyBQT1JUOiA4MDgwIH0pLFxuICogICBDb250ZXh0LmFkZChUaW1lb3V0LCB7IFRJTUVPVVQ6IDUwMDAgfSlcbiAqIClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBUaW1lb3V0KSwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXQgPSBpbnRlcm5hbC5nZXQ7XG4vKipcbiAqIEdldCBhIHNlcnZpY2UgZnJvbSB0aGUgY29udGV4dCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiB0YWcsIG9yXG4gKiB1c2UgdGhlIGZhbGxiYWNrIHZhbHVlLlxuICpcbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yRWxzZSA9IGludGVybmFsLmdldE9yRWxzZTtcbi8qKlxuICogR2V0IGEgc2VydmljZSBmcm9tIHRoZSBjb250ZXh0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIHRhZy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdW5zYWZlIGJlY2F1c2UgaWYgdGhlIHRhZyBpcyBub3QgcHJlc2VudCBpbiB0aGUgY29udGV4dCwgYSBydW50aW1lIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEZvciBhIHNhZmVyIHZlcnNpb24gc2VlIHtAbGluayBnZXRPcHRpb259LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBDb250ZXh0YCB0byBzZWFyY2ggZm9yIHRoZSBzZXJ2aWNlLlxuICogQHBhcmFtIHRhZyAtIFRoZSBgVGFnYCBvZiB0aGUgc2VydmljZSB0byByZXRyaWV2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBQb3J0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgUE9SVDogbnVtYmVyIH0+KFwiUG9ydFwiKVxuICogY29uc3QgVGltZW91dCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFRJTUVPVVQ6IG51bWJlciB9PihcIlRpbWVvdXRcIilcbiAqXG4gKiBjb25zdCBTZXJ2aWNlcyA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQudW5zYWZlR2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBhc3NlcnQudGhyb3dzKCgpID0+IENvbnRleHQudW5zYWZlR2V0KFNlcnZpY2VzLCBUaW1lb3V0KSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHVuc2FmZVxuICovXG5leHBvcnQgY29uc3QgdW5zYWZlR2V0ID0gaW50ZXJuYWwudW5zYWZlR2V0O1xuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBmcm9tIHRoZSBjb250ZXh0IHdyYXBwZWQgaW4gYW4gYE9wdGlvbmAgb2JqZWN0LiBJZiB0aGUgdGFnIGlzIG5vdFxuICogZm91bmQsIHRoZSBgT3B0aW9uYCBvYmplY3Qgd2lsbCBiZSBgTm9uZWAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYENvbnRleHRgIHRvIHNlYXJjaCBmb3IgdGhlIHNlcnZpY2UuXG4gKiBAcGFyYW0gdGFnIC0gVGhlIGBUYWdgIG9mIHRoZSBzZXJ2aWNlIHRvIHJldHJpZXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29udGV4dCwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqIGNvbnN0IFRpbWVvdXQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBUSU1FT1VUOiBudW1iZXIgfT4oXCJUaW1lb3V0XCIpXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBDb250ZXh0Lm1ha2UoUG9ydCwgeyBQT1JUOiA4MDgwIH0pXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChDb250ZXh0LmdldE9wdGlvbihTZXJ2aWNlcywgUG9ydCksIE9wdGlvbi5zb21lKHsgUE9SVDogODA4MCB9KSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXRPcHRpb24oU2VydmljZXMsIFRpbWVvdXQpLCBPcHRpb24ubm9uZSgpKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICovXG5leHBvcnQgY29uc3QgZ2V0T3B0aW9uID0gaW50ZXJuYWwuZ2V0T3B0aW9uO1xuLyoqXG4gKiBNZXJnZXMgdHdvIGBDb250ZXh0YHMsIHJldHVybmluZyBhIG5ldyBgQ29udGV4dGAgY29udGFpbmluZyB0aGUgc2VydmljZXMgb2YgYm90aC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBmaXJzdCBgQ29udGV4dGAgdG8gbWVyZ2UuXG4gKiBAcGFyYW0gdGhhdCAtIFRoZSBzZWNvbmQgYENvbnRleHRgIHRvIG1lcmdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IFBvcnQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBQT1JUOiBudW1iZXIgfT4oXCJQb3J0XCIpXG4gKiBjb25zdCBUaW1lb3V0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgVElNRU9VVDogbnVtYmVyIH0+KFwiVGltZW91dFwiKVxuICpcbiAqIGNvbnN0IGZpcnN0Q29udGV4dCA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqIGNvbnN0IHNlY29uZENvbnRleHQgPSBDb250ZXh0Lm1ha2UoVGltZW91dCwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBDb250ZXh0Lm1lcmdlKGZpcnN0Q29udGV4dCwgc2Vjb25kQ29udGV4dClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBQb3J0KSwgeyBQT1JUOiA4MDgwIH0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0KFNlcnZpY2VzLCBUaW1lb3V0KSwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlID0gaW50ZXJuYWwubWVyZ2U7XG4vKipcbiAqIE1lcmdlcyBhbnkgbnVtYmVyIG9mIGBDb250ZXh0YHMsIHJldHVybmluZyBhIG5ldyBgQ29udGV4dGAgY29udGFpbmluZyB0aGUgc2VydmljZXMgb2YgYWxsLlxuICpcbiAqIEBwYXJhbSBjdHhzIC0gVGhlIGBDb250ZXh0YHMgdG8gbWVyZ2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgUG9ydCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFBPUlQ6IG51bWJlciB9PihcIlBvcnRcIilcbiAqIGNvbnN0IFRpbWVvdXQgPSBDb250ZXh0LkdlbmVyaWNUYWc8eyBUSU1FT1VUOiBudW1iZXIgfT4oXCJUaW1lb3V0XCIpXG4gKiBjb25zdCBIb3N0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgSE9TVDogc3RyaW5nIH0+KFwiSG9zdFwiKVxuICpcbiAqIGNvbnN0IGZpcnN0Q29udGV4dCA9IENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSlcbiAqIGNvbnN0IHNlY29uZENvbnRleHQgPSBDb250ZXh0Lm1ha2UoVGltZW91dCwgeyBUSU1FT1VUOiA1MDAwIH0pXG4gKiBjb25zdCB0aGlyZENvbnRleHQgPSBDb250ZXh0Lm1ha2UoSG9zdCwgeyBIT1NUOiBcImxvY2FsaG9zdFwiIH0pXG4gKlxuICogY29uc3QgU2VydmljZXMgPSBDb250ZXh0Lm1lcmdlQWxsKGZpcnN0Q29udGV4dCwgc2Vjb25kQ29udGV4dCwgdGhpcmRDb250ZXh0KVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXQoU2VydmljZXMsIFBvcnQpLCB7IFBPUlQ6IDgwODAgfSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXQoU2VydmljZXMsIFRpbWVvdXQpLCB7IFRJTUVPVVQ6IDUwMDAgfSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXQoU2VydmljZXMsIEhvc3QpLCB7IEhPU1Q6IFwibG9jYWxob3N0XCIgfSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAzLjEyLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlQWxsID0gaW50ZXJuYWwubWVyZ2VBbGw7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgYENvbnRleHRgIHRoYXQgY29udGFpbnMgb25seSB0aGUgc3BlY2lmaWVkIHNlcnZpY2VzLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBDb250ZXh0YCB0byBwcnVuZSBzZXJ2aWNlcyBmcm9tLlxuICogQHBhcmFtIHRhZ3MgLSBUaGUgbGlzdCBvZiBgVGFnYHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBgQ29udGV4dGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBDb250ZXh0LCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBQb3J0ID0gQ29udGV4dC5HZW5lcmljVGFnPHsgUE9SVDogbnVtYmVyIH0+KFwiUG9ydFwiKVxuICogY29uc3QgVGltZW91dCA9IENvbnRleHQuR2VuZXJpY1RhZzx7IFRJTUVPVVQ6IG51bWJlciB9PihcIlRpbWVvdXRcIilcbiAqXG4gKiBjb25zdCBzb21lQ29udGV4dCA9IHBpcGUoXG4gKiAgIENvbnRleHQubWFrZShQb3J0LCB7IFBPUlQ6IDgwODAgfSksXG4gKiAgIENvbnRleHQuYWRkKFRpbWVvdXQsIHsgVElNRU9VVDogNTAwMCB9KVxuICogKVxuICpcbiAqIGNvbnN0IFNlcnZpY2VzID0gcGlwZShzb21lQ29udGV4dCwgQ29udGV4dC5waWNrKFBvcnQpKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQ29udGV4dC5nZXRPcHRpb24oU2VydmljZXMsIFBvcnQpLCBPcHRpb24uc29tZSh7IFBPUlQ6IDgwODAgfSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKENvbnRleHQuZ2V0T3B0aW9uKFNlcnZpY2VzLCBUaW1lb3V0KSwgT3B0aW9uLm5vbmUoKSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcGljayA9IGludGVybmFsLnBpY2s7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgb21pdCA9IGludGVybmFsLm9taXQ7XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29udGV4dCwgTGF5ZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjbGFzcyBNeVRhZyBleHRlbmRzIENvbnRleHQuVGFnKFwiTXlUYWdcIik8XG4gKiAgTXlUYWcsXG4gKiAgeyByZWFkb25seSBteU51bTogbnVtYmVyIH1cbiAqID4oKSB7XG4gKiAgc3RhdGljIExpdmUgPSBMYXllci5zdWNjZWVkKHRoaXMsIHsgbXlOdW06IDEwOCB9KVxuICogfVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBUYWcgPSBpbnRlcm5hbC5UYWc7XG4vKipcbiAqIENyZWF0ZXMgYSBjb250ZXh0IHRhZyB3aXRoIGEgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiAqKkRldGFpbHMqKlxuICpcbiAqIGBDb250ZXh0LlJlZmVyZW5jZWAgYWxsb3dzIHlvdSB0byBjcmVhdGUgYSB0YWcgdGhhdCBjYW4gaG9sZCBhIHZhbHVlLiBZb3UgY2FuXG4gKiBwcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHNlcnZpY2UsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBiZSB1c2VkXG4gKiB3aGVuIHRoZSBjb250ZXh0IGlzIGFjY2Vzc2VkLCBvciBvdmVycmlkZSBpdCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gKiB3aGVuIG5lZWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIC8vIFRpdGxlOiBEZWNsYXJpbmcgYSBUYWcgd2l0aCBhIGRlZmF1bHQgdmFsdWVcbiAqIGltcG9ydCB7IENvbnRleHQsIEVmZmVjdCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNsYXNzIFNwZWNpYWxOdW1iZXIgZXh0ZW5kcyBDb250ZXh0LlJlZmVyZW5jZTxTcGVjaWFsTnVtYmVyPigpKFxuICogICBcIlNwZWNpYWxOdW1iZXJcIixcbiAqICAgeyBkZWZhdWx0VmFsdWU6ICgpID0+IDIwNDggfVxuICogKSB7fVxuICpcbiAqIC8vICAgICAg4pSM4pSA4pSA4pSAIEVmZmVjdDx2b2lkLCBuZXZlciwgbmV2ZXI+XG4gKiAvLyAgICAgIOKWvFxuICogY29uc3QgcHJvZ3JhbSA9IEVmZmVjdC5nZW4oZnVuY3Rpb24qICgpIHtcbiAqICAgY29uc3Qgc3BlY2lhbE51bWJlciA9IHlpZWxkKiBTcGVjaWFsTnVtYmVyXG4gKiAgIGNvbnNvbGUubG9nKGBUaGUgc3BlY2lhbCBudW1iZXIgaXMgJHtzcGVjaWFsTnVtYmVyfWApXG4gKiB9KVxuICpcbiAqIC8vIE5vIG5lZWQgdG8gcHJvdmlkZSB0aGUgU3BlY2lhbE51bWJlciBpbXBsZW1lbnRhdGlvblxuICogRWZmZWN0LnJ1blByb21pc2UocHJvZ3JhbSlcbiAqIC8vIE91dHB1dDogVGhlIHNwZWNpYWwgbnVtYmVyIGlzIDIwNDhcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogLy8gVGl0bGU6IE92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgdmFsdWVcbiAqIGltcG9ydCB7IENvbnRleHQsIEVmZmVjdCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNsYXNzIFNwZWNpYWxOdW1iZXIgZXh0ZW5kcyBDb250ZXh0LlJlZmVyZW5jZTxTcGVjaWFsTnVtYmVyPigpKFxuICogICBcIlNwZWNpYWxOdW1iZXJcIixcbiAqICAgeyBkZWZhdWx0VmFsdWU6ICgpID0+IDIwNDggfVxuICogKSB7fVxuICpcbiAqIGNvbnN0IHByb2dyYW0gPSBFZmZlY3QuZ2VuKGZ1bmN0aW9uKiAoKSB7XG4gKiAgIGNvbnN0IHNwZWNpYWxOdW1iZXIgPSB5aWVsZCogU3BlY2lhbE51bWJlclxuICogICBjb25zb2xlLmxvZyhgVGhlIHNwZWNpYWwgbnVtYmVyIGlzICR7c3BlY2lhbE51bWJlcn1gKVxuICogfSlcbiAqXG4gKiBFZmZlY3QucnVuUHJvbWlzZShwcm9ncmFtLnBpcGUoRWZmZWN0LnByb3ZpZGVTZXJ2aWNlKFNwZWNpYWxOdW1iZXIsIC0xKSkpXG4gKiAvLyBPdXRwdXQ6IFRoZSBzcGVjaWFsIG51bWJlciBpcyAtMVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuMTEuMFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY29uc3QgUmVmZXJlbmNlID0gaW50ZXJuYWwuUmVmZXJlbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiaW50ZXJuYWwiLCJUYWdUeXBlSWQiLCJSZWZlcmVuY2VUeXBlSWQiLCJHZW5lcmljVGFnIiwibWFrZUdlbmVyaWNUYWciLCJUeXBlSWQiLCJ1bnNhZmVNYWtlIiwibWFrZUNvbnRleHQiLCJpc0NvbnRleHQiLCJpc1RhZyIsImlzUmVmZXJlbmNlIiwiZW1wdHkiLCJtYWtlIiwiYWRkIiwiZ2V0IiwiZ2V0T3JFbHNlIiwidW5zYWZlR2V0IiwiZ2V0T3B0aW9uIiwibWVyZ2UiLCJtZXJnZUFsbCIsInBpY2siLCJvbWl0IiwiVGFnIiwiUmVmZXJlbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Effectable.js":
/*!****************************************************!*\
  !*** ./node_modules/effect/dist/esm/Effectable.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChannelTypeId: () => (/* binding */ ChannelTypeId),\n/* harmony export */   Class: () => (/* binding */ Class),\n/* harmony export */   CommitPrototype: () => (/* binding */ CommitPrototype),\n/* harmony export */   EffectPrototype: () => (/* binding */ EffectPrototype),\n/* harmony export */   EffectTypeId: () => (/* binding */ EffectTypeId),\n/* harmony export */   SinkTypeId: () => (/* binding */ SinkTypeId),\n/* harmony export */   StreamTypeId: () => (/* binding */ StreamTypeId),\n/* harmony export */   StructuralClass: () => (/* binding */ StructuralClass),\n/* harmony export */   StructuralCommitPrototype: () => (/* binding */ StructuralCommitPrototype)\n/* harmony export */ });\n/* harmony import */ var _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n\n/**\n * @since 2.0.0\n * @category type ids\n */ const EffectTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectTypeId;\n/**\n * @since 2.0.0\n * @category type ids\n */ const StreamTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.StreamTypeId;\n/**\n * @since 2.0.0\n * @category type ids\n */ const SinkTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.SinkTypeId;\n/**\n * @since 2.0.0\n * @category type ids\n */ const ChannelTypeId = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.ChannelTypeId;\n/**\n * @since 2.0.0\n * @category prototypes\n */ const EffectPrototype = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype;\n/**\n * @since 2.0.0\n * @category prototypes\n */ const CommitPrototype = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.CommitPrototype;\n/**\n * @since 2.0.0\n * @category prototypes\n */ const StructuralCommitPrototype = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.StructuralCommitPrototype;\nconst Base = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.Base;\nconst StructuralBase = _internal_effectable_js__WEBPACK_IMPORTED_MODULE_0__.StructuralBase;\n/**\n * @since 2.0.0\n * @category constructors\n */ class Class extends Base {\n}\n/**\n * @since 2.0.0\n * @category constructors\n */ class StructuralClass extends StructuralBase {\n} //# sourceMappingURL=Effectable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VmZmVjdGFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNyRDs7O0NBR0MsR0FDTSxNQUFNQyxlQUFlRCxpRUFBcUIsQ0FBQztBQUNsRDs7O0NBR0MsR0FDTSxNQUFNRSxlQUFlRixpRUFBcUIsQ0FBQztBQUNsRDs7O0NBR0MsR0FDTSxNQUFNRyxhQUFhSCwrREFBbUIsQ0FBQztBQUM5Qzs7O0NBR0MsR0FDTSxNQUFNSSxnQkFBZ0JKLGtFQUFzQixDQUFDO0FBQ3BEOzs7Q0FHQyxHQUNNLE1BQU1LLGtCQUFrQkwsb0VBQXdCLENBQUM7QUFDeEQ7OztDQUdDLEdBQ00sTUFBTU0sa0JBQWtCTixvRUFBd0IsQ0FBQztBQUN4RDs7O0NBR0MsR0FDTSxNQUFNTyw0QkFBNEJQLDhFQUFrQyxDQUFDO0FBQzVFLE1BQU1RLE9BQU9SLHlEQUFhO0FBQzFCLE1BQU1TLGlCQUFpQlQsbUVBQXVCO0FBQzlDOzs7Q0FHQyxHQUNNLE1BQU1VLGNBQWNGO0FBQU07QUFDakM7OztDQUdDLEdBQ00sTUFBTUcsd0JBQXdCRjtBQUFnQixFQUNyRCxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VmZmVjdGFibGUuanM/NWQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tIFwiLi9pbnRlcm5hbC9lZmZlY3RhYmxlLmpzXCI7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHR5cGUgaWRzXG4gKi9cbmV4cG9ydCBjb25zdCBFZmZlY3RUeXBlSWQgPSBpbnRlcm5hbC5FZmZlY3RUeXBlSWQ7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHR5cGUgaWRzXG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1UeXBlSWQgPSBpbnRlcm5hbC5TdHJlYW1UeXBlSWQ7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHR5cGUgaWRzXG4gKi9cbmV4cG9ydCBjb25zdCBTaW5rVHlwZUlkID0gaW50ZXJuYWwuU2lua1R5cGVJZDtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgdHlwZSBpZHNcbiAqL1xuZXhwb3J0IGNvbnN0IENoYW5uZWxUeXBlSWQgPSBpbnRlcm5hbC5DaGFubmVsVHlwZUlkO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBwcm90b3R5cGVzXG4gKi9cbmV4cG9ydCBjb25zdCBFZmZlY3RQcm90b3R5cGUgPSBpbnRlcm5hbC5FZmZlY3RQcm90b3R5cGU7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IHByb3RvdHlwZXNcbiAqL1xuZXhwb3J0IGNvbnN0IENvbW1pdFByb3RvdHlwZSA9IGludGVybmFsLkNvbW1pdFByb3RvdHlwZTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgcHJvdG90eXBlc1xuICovXG5leHBvcnQgY29uc3QgU3RydWN0dXJhbENvbW1pdFByb3RvdHlwZSA9IGludGVybmFsLlN0cnVjdHVyYWxDb21taXRQcm90b3R5cGU7XG5jb25zdCBCYXNlID0gaW50ZXJuYWwuQmFzZTtcbmNvbnN0IFN0cnVjdHVyYWxCYXNlID0gaW50ZXJuYWwuU3RydWN0dXJhbEJhc2U7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY2xhc3MgQ2xhc3MgZXh0ZW5kcyBCYXNlIHt9XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY2xhc3MgU3RydWN0dXJhbENsYXNzIGV4dGVuZHMgU3RydWN0dXJhbEJhc2Uge31cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVmZmVjdGFibGUuanMubWFwIl0sIm5hbWVzIjpbImludGVybmFsIiwiRWZmZWN0VHlwZUlkIiwiU3RyZWFtVHlwZUlkIiwiU2lua1R5cGVJZCIsIkNoYW5uZWxUeXBlSWQiLCJFZmZlY3RQcm90b3R5cGUiLCJDb21taXRQcm90b3R5cGUiLCJTdHJ1Y3R1cmFsQ29tbWl0UHJvdG90eXBlIiwiQmFzZSIsIlN0cnVjdHVyYWxCYXNlIiwiQ2xhc3MiLCJTdHJ1Y3R1cmFsQ2xhc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Effectable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Either.js":
/*!************************************************!*\
  !*** ./node_modules/effect/dist/esm/Either.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   andThen: () => (/* binding */ andThen),\n/* harmony export */   ap: () => (/* binding */ ap),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   filterOrLeft: () => (/* binding */ filterOrLeft),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   fromNullable: () => (/* binding */ fromNullable),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getLeft: () => (/* binding */ getLeft),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   getOrNull: () => (/* binding */ getOrNull),\n/* harmony export */   getOrThrow: () => (/* binding */ getOrThrow),\n/* harmony export */   getOrThrowWith: () => (/* binding */ getOrThrowWith),\n/* harmony export */   getOrUndefined: () => (/* binding */ getOrUndefined),\n/* harmony export */   getRight: () => (/* binding */ getRight),\n/* harmony export */   isEither: () => (/* binding */ isEither),\n/* harmony export */   isLeft: () => (/* binding */ isLeft),\n/* harmony export */   isRight: () => (/* binding */ isRight),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   liftPredicate: () => (/* binding */ liftPredicate),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapBoth: () => (/* binding */ mapBoth),\n/* harmony export */   mapLeft: () => (/* binding */ mapLeft),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   orElse: () => (/* binding */ orElse),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   \"try\": () => (/* binding */ try_),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _internal_either_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/either.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/either.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/**\n * @since 2.0.0\n */ \n\n\n\n\n\n/**\n * @category symbols\n * @since 2.0.0\n */ const TypeId = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.TypeId;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */ const right = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.right;\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */ const left = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.left;\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const fromNullable = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNullable)=>self == null ? left(onNullable(self)) : right(self));\n/**\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const fromOption = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.fromOption;\nconst try_ = (evaluate)=>{\n    if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.isFunction)(evaluate)) {\n        try {\n            return right(evaluate());\n        } catch (e) {\n            return left(e);\n        }\n    } else {\n        try {\n            return right(evaluate.try());\n        } catch (e) {\n            return left(evaluate.catch(e));\n        }\n    }\n};\n\n/**\n * Tests if a value is a `Either`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isEither(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\n * assert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isEither = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.isEither;\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\n * assert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isLeft = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.isLeft;\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isRight = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.isRight;\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getRight = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\n * assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getLeft = _internal_either_js__WEBPACK_IMPORTED_MODULE_0__.getLeft;\n/**\n * @category equivalence\n * @since 2.0.0\n */ const getEquivalence = ({ left, right })=>_Equivalence_js__WEBPACK_IMPORTED_MODULE_3__.make((x, y)=>isLeft(x) ? isLeft(y) && left(x.left, y.left) : isRight(y) && right(x.right, y.right));\n/**\n * @category mapping\n * @since 2.0.0\n */ const mapBoth = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, { onLeft, onRight })=>isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right)));\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @param self - The input `Either` value to map.\n * @param f - A transformation function to apply to the `Left` value of the input `Either`.\n *\n * @category mapping\n * @since 2.0.0\n */ const mapLeft = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isLeft(self) ? left(f(self.left)) : right(self.right));\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @param self - An `Either` to map\n * @param f - The function to map over the value of the `Either`\n *\n * @category mapping\n * @since 2.0.0\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isRight(self) ? right(f(self.right)) : left(self.left));\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * ```ts\n * import { pipe, Either } from \"effect\"\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */ const match = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, { onLeft, onRight })=>isLeft(self) ? onLeft(self.left) : onRight(self.right));\n/**\n * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n * or `Left` of the result of the provided function if the predicate returns false\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * ```ts\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     0,\n *     Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @category lifting\n * @since 3.4.0\n */ const liftPredicate = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (a, predicate, orLeftWith)=>predicate(a) ? right(a) : left(orLeftWith(a)));\n/**\n * Filter the right value with the provided function.\n * If the predicate fails, set the left value with the result of the provided function.\n *\n * @example\n * ```ts\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(1),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(0),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */ const filterOrLeft = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, predicate, orLeftWith)=>flatMap(self, (r)=>predicate(r) ? right(r) : left(orLeftWith(r))));\n/**\n * @category getters\n * @since 2.0.0\n */ const merge = /*#__PURE__*/ match({\n    onLeft: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    onRight: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n});\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrElse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onLeft)=>isLeft(self) ? onLeft(self.left) : self.right);\n/**\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrNull = /*#__PURE__*/ getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constNull);\n/**\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrUndefined = /*#__PURE__*/ getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constUndefined);\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Either` to extract the value from.\n * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrThrowWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onLeft)=>{\n    if (isRight(self)) {\n        return self.right;\n    }\n    throw onLeft(self.left);\n});\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Either` to extract the value from.\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\n * assert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrThrow = /*#__PURE__*/ getOrThrowWith(()=>new Error(\"getOrThrow called on a Left\"));\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @param self - The input `Either` value to check and potentially return.\n * @param that - A function that takes the error value from `self` (if it's a `Left`) and returns a new `Either` value.\n *\n * @category error handling\n * @since 2.0.0\n */ const orElse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>isLeft(self) ? that(self.left) : right(self.right));\n/**\n * @category sequencing\n * @since 2.0.0\n */ const flatMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isLeft(self) ? left(self.left) : f(self.right));\n/**\n * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n *\n * @category sequencing\n * @since 2.0.0\n */ const andThen = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>flatMap(self, (a)=>{\n        const b = (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.isFunction)(f) ? f(a) : f;\n        return isEither(b) ? b : right(b);\n    }));\n/**\n * @category zipping\n * @since 2.0.0\n */ const zipWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, that, f)=>flatMap(self, (r)=>map(that, (r2)=>f(r, r2))));\n/**\n * @category combining\n * @since 2.0.0\n */ const ap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>zipWith(self, that, (f, a)=>f(a)));\n/**\n * Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Either` will contain an array.\n *\n * @param fields - the struct of `Either`s to be sequenced.\n *\n * @example\n * ```ts\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n * ```\n *\n * @category combining\n * @since 2.0.0\n */ // @ts-expect-error\nconst all = (input)=>{\n    if (Symbol.iterator in input) {\n        const out = [];\n        for (const e of input){\n            if (isLeft(e)) {\n                return e;\n            }\n            out.push(e.right);\n        }\n        return right(out);\n    }\n    const out = {};\n    for (const key of Object.keys(input)){\n        const e = input[key];\n        if (isLeft(e)) {\n            return e;\n        }\n        out[key] = e.right;\n    }\n    return right(out);\n};\n/**\n * Returns an `Either` that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */ const flip = (self)=>isLeft(self) ? right(self.left) : left(self.right);\nconst adapter = /*#__PURE__*/ _Utils_js__WEBPACK_IMPORTED_MODULE_4__.adapter();\n/**\n * @category generators\n * @since 2.0.0\n */ const gen = (...args)=>{\n    const f = args.length === 1 ? args[0] : args[1].bind(args[0]);\n    const iterator = f(adapter);\n    let state = iterator.next();\n    if (state.done) {\n        return right(state.value);\n    } else {\n        let current = state.value;\n        if (_Utils_js__WEBPACK_IMPORTED_MODULE_4__.isGenKind(current)) {\n            current = current.value;\n        } else {\n            current = _Utils_js__WEBPACK_IMPORTED_MODULE_4__.yieldWrapGet(current);\n        }\n        if (isLeft(current)) {\n            return current;\n        }\n        while(!state.done){\n            state = iterator.next(current.right);\n            if (!state.done) {\n                current = state.value;\n                if (_Utils_js__WEBPACK_IMPORTED_MODULE_4__.isGenKind(current)) {\n                    current = current.value;\n                } else {\n                    current = _Utils_js__WEBPACK_IMPORTED_MODULE_4__.yieldWrapGet(current);\n                }\n                if (isLeft(current)) {\n                    return current;\n                }\n            }\n        }\n        return right(state.value);\n    }\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link bind}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */ const Do = /*#__PURE__*/ right({});\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */ const bind = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__.bind(map, flatMap);\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */ const bindTo = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__.bindTo(map);\nconst let_ = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_5__.let_(map);\n //# sourceMappingURL=Either.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VpdGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUMrQztBQUMwQjtBQUNuQjtBQUNSO0FBQ0g7QUFDVjtBQUNsQzs7O0NBR0MsR0FDTSxNQUFNUyxTQUFTSCx1REFBYSxDQUFDO0FBQ3BDOzs7Ozs7Q0FNQyxHQUNNLE1BQU1JLFFBQVFKLHNEQUFZLENBQUM7QUFDbEM7Ozs7OztDQU1DLEdBQ00sTUFBTUssT0FBT0wscURBQVcsQ0FBQztBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLE1BQU1NLGVBQWUsV0FBVyxHQUFFVCxrREFBSUEsQ0FBQyxHQUFHLENBQUNVLE1BQU1DLGFBQWVELFFBQVEsT0FBT0YsS0FBS0csV0FBV0QsU0FBU0gsTUFBTUcsT0FBTztBQUM1SDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLE1BQU1FLGFBQWFULDJEQUFpQixDQUFDO0FBQzVDLE1BQU1VLE9BQU9DLENBQUFBO0lBQ1gsSUFBSVYseURBQVVBLENBQUNVLFdBQVc7UUFDeEIsSUFBSTtZQUNGLE9BQU9QLE1BQU1PO1FBQ2YsRUFBRSxPQUFPQyxHQUFHO1lBQ1YsT0FBT1AsS0FBS087UUFDZDtJQUNGLE9BQU87UUFDTCxJQUFJO1lBQ0YsT0FBT1IsTUFBTU8sU0FBU0UsR0FBRztRQUMzQixFQUFFLE9BQU9ELEdBQUc7WUFDVixPQUFPUCxLQUFLTSxTQUFTRyxLQUFLLENBQUNGO1FBQzdCO0lBQ0Y7QUFDRjtBQVNjO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNRyxXQUFXZix5REFBZSxDQUFDO0FBQ3hDOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLE1BQU1nQixTQUFTaEIsdURBQWEsQ0FBQztBQUNwQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNaUIsVUFBVWpCLHdEQUFjLENBQUM7QUFDdEM7Ozs7Ozs7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dHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9FaXRoZXIuanM/YjNiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgKiBhcyBFcXVpdmFsZW5jZSBmcm9tIFwiLi9FcXVpdmFsZW5jZS5qc1wiO1xuaW1wb3J0IHsgY29uc3ROdWxsLCBjb25zdFVuZGVmaW5lZCwgZHVhbCwgaWRlbnRpdHkgfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgZG9Ob3RhdGlvbiBmcm9tIFwiLi9pbnRlcm5hbC9kb05vdGF0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBlaXRoZXIgZnJvbSBcIi4vaW50ZXJuYWwvZWl0aGVyLmpzXCI7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSBcIi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgKiBhcyBHZW4gZnJvbSBcIi4vVXRpbHMuanNcIjtcbi8qKlxuICogQGNhdGVnb3J5IHN5bWJvbHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgVHlwZUlkID0gZWl0aGVyLlR5cGVJZDtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgRWl0aGVyYCBob2xkaW5nIGEgYFJpZ2h0YCB2YWx1ZS4gVGhpcyB1c3VhbGx5IHJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIHZhbHVlIGR1ZSB0byB0aGUgcmlnaHQgYmlhc1xuICogb2YgdGhpcyBzdHJ1Y3R1cmUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByaWdodCA9IGVpdGhlci5yaWdodDtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgRWl0aGVyYCBob2xkaW5nIGEgYExlZnRgIHZhbHVlLiBUaGlzIHVzdWFsbHkgcmVwcmVzZW50cyBhIGZhaWx1cmUsIGR1ZSB0byB0aGUgcmlnaHQtYmlhcyBvZiB0aGlzXG4gKiBzdHJ1Y3R1cmUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZWZ0ID0gZWl0aGVyLmxlZnQ7XG4vKipcbiAqIFRha2VzIGEgbGF6eSBkZWZhdWx0IGFuZCBhIG51bGxhYmxlIHZhbHVlLCBpZiB0aGUgdmFsdWUgaXMgbm90IG51bGx5IChgbnVsbGAgb3IgYHVuZGVmaW5lZGApLCB0dXJuIGl0IGludG8gYSBgUmlnaHRgLCBpZiB0aGUgdmFsdWUgaXMgbnVsbHkgdXNlXG4gKiB0aGUgcHJvdmlkZWQgZGVmYXVsdCBhcyBhIGBMZWZ0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmZyb21OdWxsYWJsZSgxLCAoKSA9PiAnZmFsbGJhY2snKSwgRWl0aGVyLnJpZ2h0KDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZnJvbU51bGxhYmxlKG51bGwsICgpID0+ICdmYWxsYmFjaycpLCBFaXRoZXIubGVmdCgnZmFsbGJhY2snKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZnJvbU51bGxhYmxlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9uTnVsbGFibGUpID0+IHNlbGYgPT0gbnVsbCA/IGxlZnQob25OdWxsYWJsZShzZWxmKSkgOiByaWdodChzZWxmKSk7XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5mcm9tT3B0aW9uKE9wdGlvbi5zb21lKDEpLCAoKSA9PiAnZXJyb3InKSwgRWl0aGVyLnJpZ2h0KDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZnJvbU9wdGlvbihPcHRpb24ubm9uZSgpLCAoKSA9PiAnZXJyb3InKSwgRWl0aGVyLmxlZnQoJ2Vycm9yJykpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21PcHRpb24gPSBlaXRoZXIuZnJvbU9wdGlvbjtcbmNvbnN0IHRyeV8gPSBldmFsdWF0ZSA9PiB7XG4gIGlmIChpc0Z1bmN0aW9uKGV2YWx1YXRlKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmlnaHQoZXZhbHVhdGUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGxlZnQoZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmlnaHQoZXZhbHVhdGUudHJ5KCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBsZWZ0KGV2YWx1YXRlLmNhdGNoKGUpKTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuLyoqXG4gKiBJbXBvcnRzIGEgc3luY2hyb25vdXMgc2lkZS1lZmZlY3QgaW50byBhIHB1cmUgYEVpdGhlcmAgdmFsdWUsIHRyYW5zbGF0aW5nIGFueVxuICogdGhyb3duIGV4Y2VwdGlvbnMgaW50byB0eXBlZCBmYWlsZWQgZWl0aGVycyBjcmVhdGluZyB3aXRoIGBFaXRoZXIubGVmdGAuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnRyeV8gYXMgdHJ5IH07XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgRWl0aGVyYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmlzRWl0aGVyKEVpdGhlci5yaWdodCgxKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5pc0VpdGhlcihFaXRoZXIubGVmdChcImFcIikpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuaXNFaXRoZXIoeyByaWdodDogMSB9KSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRWl0aGVyID0gZWl0aGVyLmlzRWl0aGVyO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBgRWl0aGVyYCBpcyBhIGBMZWZ0YC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgRWl0aGVyYCB0byBjaGVjay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmlzTGVmdChFaXRoZXIucmlnaHQoMSkpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmlzTGVmdChFaXRoZXIubGVmdChcImFcIikpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0xlZnQgPSBlaXRoZXIuaXNMZWZ0O1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBgRWl0aGVyYCBpcyBhIGBSaWdodGAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEVpdGhlcmAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5pc1JpZ2h0KEVpdGhlci5yaWdodCgxKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5pc1JpZ2h0KEVpdGhlci5sZWZ0KFwiYVwiKSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1JpZ2h0ID0gZWl0aGVyLmlzUmlnaHQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEVpdGhlcmAgdG8gYW4gYE9wdGlvbmAgZGlzY2FyZGluZyB0aGUgYExlZnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKEVpdGhlci5nZXRSaWdodChFaXRoZXIucmlnaHQoJ29rJykpLCBPcHRpb24uc29tZSgnb2snKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldFJpZ2h0KEVpdGhlci5sZWZ0KCdlcnInKSksIE9wdGlvbi5ub25lKCkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRSaWdodCA9IGVpdGhlci5nZXRSaWdodDtcbi8qKlxuICogQ29udmVydHMgYSBgRWl0aGVyYCB0byBhbiBgT3B0aW9uYCBkaXNjYXJkaW5nIHRoZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVpdGhlciwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZ2V0TGVmdChFaXRoZXIucmlnaHQoJ29rJykpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZ2V0TGVmdChFaXRoZXIubGVmdCgnZXJyJykpLCBPcHRpb24uc29tZSgnZXJyJykpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMZWZ0ID0gZWl0aGVyLmdldExlZnQ7XG4vKipcbiAqIEBjYXRlZ29yeSBlcXVpdmFsZW5jZVxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFcXVpdmFsZW5jZSA9ICh7XG4gIGxlZnQsXG4gIHJpZ2h0XG59KSA9PiBFcXVpdmFsZW5jZS5tYWtlKCh4LCB5KSA9PiBpc0xlZnQoeCkgPyBpc0xlZnQoeSkgJiYgbGVmdCh4LmxlZnQsIHkubGVmdCkgOiBpc1JpZ2h0KHkpICYmIHJpZ2h0KHgucmlnaHQsIHkucmlnaHQpKTtcbi8qKlxuICogQGNhdGVnb3J5IG1hcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFwQm90aCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB7XG4gIG9uTGVmdCxcbiAgb25SaWdodFxufSkgPT4gaXNMZWZ0KHNlbGYpID8gbGVmdChvbkxlZnQoc2VsZi5sZWZ0KSkgOiByaWdodChvblJpZ2h0KHNlbGYucmlnaHQpKSk7XG4vKipcbiAqIE1hcHMgdGhlIGBMZWZ0YCBzaWRlIG9mIGFuIGBFaXRoZXJgIHZhbHVlIHRvIGEgbmV3IGBFaXRoZXJgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGlucHV0IGBFaXRoZXJgIHZhbHVlIHRvIG1hcC5cbiAqIEBwYXJhbSBmIC0gQSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgYExlZnRgIHZhbHVlIG9mIHRoZSBpbnB1dCBgRWl0aGVyYC5cbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBMZWZ0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzTGVmdChzZWxmKSA/IGxlZnQoZihzZWxmLmxlZnQpKSA6IHJpZ2h0KHNlbGYucmlnaHQpKTtcbi8qKlxuICogTWFwcyB0aGUgYFJpZ2h0YCBzaWRlIG9mIGFuIGBFaXRoZXJgIHZhbHVlIHRvIGEgbmV3IGBFaXRoZXJgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQW4gYEVpdGhlcmAgdG8gbWFwXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB0byBtYXAgb3ZlciB0aGUgdmFsdWUgb2YgdGhlIGBFaXRoZXJgXG4gKlxuICogQGNhdGVnb3J5IG1hcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzUmlnaHQoc2VsZikgPyByaWdodChmKHNlbGYucmlnaHQpKSA6IGxlZnQoc2VsZi5sZWZ0KSk7XG4vKipcbiAqIFRha2VzIHR3byBmdW5jdGlvbnMgYW5kIGFuIGBFaXRoZXJgIHZhbHVlLCBpZiB0aGUgdmFsdWUgaXMgYSBgTGVmdGAgdGhlIGlubmVyIHZhbHVlIGlzIGFwcGxpZWQgdG8gdGhlIGBvbkxlZnQgZnVuY3Rpb24sXG4gKiBpZiB0aGUgdmFsdWUgaXMgYSBgUmlnaHRgIHRoZSBpbm5lciB2YWx1ZSBpcyBhcHBsaWVkIHRvIHRoZSBgb25SaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBvbkxlZnQgID0gKHN0cmluZ3M6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPik6IHN0cmluZyA9PiBgc3RyaW5nczogJHtzdHJpbmdzLmpvaW4oJywgJyl9YFxuICpcbiAqIGNvbnN0IG9uUmlnaHQgPSAodmFsdWU6IG51bWJlcik6IHN0cmluZyA9PiBgT2s6ICR7dmFsdWV9YFxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShFaXRoZXIucmlnaHQoMSksIEVpdGhlci5tYXRjaCh7IG9uTGVmdCwgb25SaWdodCB9KSksICdPazogMScpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKEVpdGhlci5sZWZ0KFsnc3RyaW5nIDEnLCAnc3RyaW5nIDInXSksIEVpdGhlci5tYXRjaCh7IG9uTGVmdCwgb25SaWdodCB9KSksXG4gKiAgICdzdHJpbmdzOiBzdHJpbmcgMSwgc3RyaW5nIDInXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgcGF0dGVybiBtYXRjaGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB7XG4gIG9uTGVmdCxcbiAgb25SaWdodFxufSkgPT4gaXNMZWZ0KHNlbGYpID8gb25MZWZ0KHNlbGYubGVmdCkgOiBvblJpZ2h0KHNlbGYucmlnaHQpKTtcbi8qKlxuICogVHJhbnNmb3JtcyBhIGBQcmVkaWNhdGVgIGZ1bmN0aW9uIGludG8gYSBgUmlnaHRgIG9mIHRoZSBpbnB1dCB2YWx1ZSBpZiB0aGUgcHJlZGljYXRlIHJldHVybnMgYHRydWVgXG4gKiBvciBgTGVmdGAgb2YgdGhlIHJlc3VsdCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaWYgdGhlIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlXG4gKlxuICogQHBhcmFtIHByZWRpY2F0ZSAtIEEgYFByZWRpY2F0ZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYEFgIGFuZCByZXR1cm5zIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHBpcGUsIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGlzUG9zaXRpdmUgPSAobjogbnVtYmVyKTogYm9vbGVhbiA9PiBuID4gMFxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgMSxcbiAqICAgICBFaXRoZXIubGlmdFByZWRpY2F0ZShpc1Bvc2l0aXZlLCBuID0+IGAke259IGlzIG5vdCBwb3NpdGl2ZWApXG4gKiAgICksXG4gKiAgIEVpdGhlci5yaWdodCgxKVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICAwLFxuICogICAgIEVpdGhlci5saWZ0UHJlZGljYXRlKGlzUG9zaXRpdmUsIG4gPT4gYCR7bn0gaXMgbm90IHBvc2l0aXZlYClcbiAqICAgKSxcbiAqICAgRWl0aGVyLmxlZnQoXCIwIGlzIG5vdCBwb3NpdGl2ZVwiKVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGxpZnRpbmdcbiAqIEBzaW5jZSAzLjQuMFxuICovXG5leHBvcnQgY29uc3QgbGlmdFByZWRpY2F0ZSA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChhLCBwcmVkaWNhdGUsIG9yTGVmdFdpdGgpID0+IHByZWRpY2F0ZShhKSA/IHJpZ2h0KGEpIDogbGVmdChvckxlZnRXaXRoKGEpKSk7XG4vKipcbiAqIEZpbHRlciB0aGUgcmlnaHQgdmFsdWUgd2l0aCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBJZiB0aGUgcHJlZGljYXRlIGZhaWxzLCBzZXQgdGhlIGxlZnQgdmFsdWUgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHBpcGUsIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGlzUG9zaXRpdmUgPSAobjogbnVtYmVyKTogYm9vbGVhbiA9PiBuID4gMFxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgRWl0aGVyLnJpZ2h0KDEpLFxuICogICAgIEVpdGhlci5maWx0ZXJPckxlZnQoaXNQb3NpdGl2ZSwgbiA9PiBgJHtufSBpcyBub3QgcG9zaXRpdmVgKVxuICogICApLFxuICogICBFaXRoZXIucmlnaHQoMSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgRWl0aGVyLnJpZ2h0KDApLFxuICogICAgIEVpdGhlci5maWx0ZXJPckxlZnQoaXNQb3NpdGl2ZSwgbiA9PiBgJHtufSBpcyBub3QgcG9zaXRpdmVgKVxuICogICApLFxuICogICBFaXRoZXIubGVmdChcIjAgaXMgbm90IHBvc2l0aXZlXCIpXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck9yTGVmdCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBwcmVkaWNhdGUsIG9yTGVmdFdpdGgpID0+IGZsYXRNYXAoc2VsZiwgciA9PiBwcmVkaWNhdGUocikgPyByaWdodChyKSA6IGxlZnQob3JMZWZ0V2l0aChyKSkpKTtcbi8qKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWVyZ2UgPSAvKiNfX1BVUkVfXyovbWF0Y2goe1xuICBvbkxlZnQ6IGlkZW50aXR5LFxuICBvblJpZ2h0OiBpZGVudGl0eVxufSk7XG4vKipcbiAqIFJldHVybnMgdGhlIHdyYXBwZWQgdmFsdWUgaWYgaXQncyBhIGBSaWdodGAgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIGlzIGEgYExlZnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZ2V0T3JFbHNlKEVpdGhlci5yaWdodCgxKSwgKGVycm9yKSA9PiBlcnJvciArIFwiIVwiKSwgMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yRWxzZShFaXRoZXIubGVmdChcIm5vdCBhIG51bWJlclwiKSwgKGVycm9yKSA9PiBlcnJvciArIFwiIVwiKSwgXCJub3QgYSBudW1iZXIhXCIpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb25MZWZ0KSA9PiBpc0xlZnQoc2VsZikgPyBvbkxlZnQoc2VsZi5sZWZ0KSA6IHNlbGYucmlnaHQpO1xuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yTnVsbChFaXRoZXIucmlnaHQoMSkpLCAxKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZ2V0T3JOdWxsKEVpdGhlci5sZWZ0KFwiYVwiKSksIG51bGwpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPck51bGwgPSAvKiNfX1BVUkVfXyovZ2V0T3JFbHNlKGNvbnN0TnVsbCk7XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuZ2V0T3JVbmRlZmluZWQoRWl0aGVyLnJpZ2h0KDEpKSwgMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yVW5kZWZpbmVkKEVpdGhlci5sZWZ0KFwiYVwiKSksIHVuZGVmaW5lZClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yVW5kZWZpbmVkID0gLyojX19QVVJFX18qL2dldE9yRWxzZShjb25zdFVuZGVmaW5lZCk7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSB2YWx1ZSBvZiBhbiBgRWl0aGVyYCBvciB0aHJvd3MgaWYgdGhlIGBFaXRoZXJgIGlzIGBMZWZ0YC5cbiAqXG4gKiBJZiBhIGRlZmF1bHQgZXJyb3IgaXMgc3VmZmljaWVudCBmb3IgeW91ciB1c2UgY2FzZSBhbmQgeW91IGRvbid0IG5lZWQgdG8gY29uZmlndXJlIHRoZSB0aHJvd24gZXJyb3IsIHNlZSB7QGxpbmsgZ2V0T3JUaHJvd30uXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEVpdGhlcmAgdG8gZXh0cmFjdCB0aGUgdmFsdWUgZnJvbS5cbiAqIEBwYXJhbSBvbkxlZnQgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIGBFaXRoZXJgIGlzIGBMZWZ0YC4gSXQgcmV0dXJucyB0aGUgZXJyb3IgdG8gYmUgdGhyb3duLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgRWl0aGVyLmdldE9yVGhyb3dXaXRoKEVpdGhlci5yaWdodCgxKSwgKCkgPT4gbmV3IEVycm9yKCdVbmV4cGVjdGVkIExlZnQnKSksXG4gKiAgIDFcbiAqIClcbiAqIGFzc2VydC50aHJvd3MoKCkgPT4gRWl0aGVyLmdldE9yVGhyb3dXaXRoKEVpdGhlci5sZWZ0KFwiZXJyb3JcIiksICgpID0+IG5ldyBFcnJvcignVW5leHBlY3RlZCBMZWZ0JykpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JUaHJvd1dpdGggPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb25MZWZ0KSA9PiB7XG4gIGlmIChpc1JpZ2h0KHNlbGYpKSB7XG4gICAgcmV0dXJuIHNlbGYucmlnaHQ7XG4gIH1cbiAgdGhyb3cgb25MZWZ0KHNlbGYubGVmdCk7XG59KTtcbi8qKlxuICogRXh0cmFjdHMgdGhlIHZhbHVlIG9mIGFuIGBFaXRoZXJgIG9yIHRocm93cyBpZiB0aGUgYEVpdGhlcmAgaXMgYExlZnRgLlxuICpcbiAqIFRoZSB0aHJvd24gZXJyb3IgaXMgYSBkZWZhdWx0IGVycm9yLiBUbyBjb25maWd1cmUgdGhlIGVycm9yIHRocm93biwgc2VlICB7QGxpbmsgZ2V0T3JUaHJvd1dpdGh9LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBFaXRoZXJgIHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb20uXG4gKiBAdGhyb3dzIGBFcnJvcihcImdldE9yVGhyb3cgY2FsbGVkIG9uIGEgTGVmdFwiKWBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmdldE9yVGhyb3coRWl0aGVyLnJpZ2h0KDEpKSwgMSlcbiAqIGFzc2VydC50aHJvd3MoKCkgPT4gRWl0aGVyLmdldE9yVGhyb3coRWl0aGVyLmxlZnQoXCJlcnJvclwiKSkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPclRocm93ID0gLyojX19QVVJFX18qL2dldE9yVGhyb3dXaXRoKCgpID0+IG5ldyBFcnJvcihcImdldE9yVGhyb3cgY2FsbGVkIG9uIGEgTGVmdFwiKSk7XG4vKipcbiAqIFJldHVybnMgYHNlbGZgIGlmIGl0IGlzIGEgYFJpZ2h0YCBvciBgdGhhdGAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGlucHV0IGBFaXRoZXJgIHZhbHVlIHRvIGNoZWNrIGFuZCBwb3RlbnRpYWxseSByZXR1cm4uXG4gKiBAcGFyYW0gdGhhdCAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgZXJyb3IgdmFsdWUgZnJvbSBgc2VsZmAgKGlmIGl0J3MgYSBgTGVmdGApIGFuZCByZXR1cm5zIGEgbmV3IGBFaXRoZXJgIHZhbHVlLlxuICpcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBvckVsc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gaXNMZWZ0KHNlbGYpID8gdGhhdChzZWxmLmxlZnQpIDogcmlnaHQoc2VsZi5yaWdodCkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0TWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzTGVmdChzZWxmKSA/IGxlZnQoc2VsZi5sZWZ0KSA6IGYoc2VsZi5yaWdodCkpO1xuLyoqXG4gKiBFeGVjdXRlcyBhIHNlcXVlbmNlIG9mIHR3byBgRWl0aGVyYHMuIFRoZSBzZWNvbmQgYEVpdGhlcmAgY2FuIGJlIGRlcGVuZGVudCBvbiB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBgRWl0aGVyYC5cbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhbmRUaGVuID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiB7XG4gIGNvbnN0IGIgPSBpc0Z1bmN0aW9uKGYpID8gZihhKSA6IGY7XG4gIHJldHVybiBpc0VpdGhlcihiKSA/IGIgOiByaWdodChiKTtcbn0pKTtcbi8qKlxuICogQGNhdGVnb3J5IHppcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgemlwV2l0aCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCB0aGF0LCBmKSA9PiBmbGF0TWFwKHNlbGYsIHIgPT4gbWFwKHRoYXQsIHIyID0+IGYociwgcjIpKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IHppcFdpdGgoc2VsZiwgdGhhdCwgKGYsIGEpID0+IGYoYSkpKTtcbi8qKlxuICogVGFrZXMgYSBzdHJ1Y3R1cmUgb2YgYEVpdGhlcmBzIGFuZCByZXR1cm5zIGFuIGBFaXRoZXJgIG9mIHZhbHVlcyB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZS5cbiAqXG4gKiAtIElmIGEgdHVwbGUgaXMgc3VwcGxpZWQsIHRoZW4gdGhlIHJldHVybmVkIGBFaXRoZXJgIHdpbGwgY29udGFpbiBhIHR1cGxlIHdpdGggdGhlIHNhbWUgbGVuZ3RoLlxuICogLSBJZiBhIHN0cnVjdCBpcyBzdXBwbGllZCwgdGhlbiB0aGUgcmV0dXJuZWQgYEVpdGhlcmAgd2lsbCBjb250YWluIGEgc3RydWN0IHdpdGggdGhlIHNhbWUga2V5cy5cbiAqIC0gSWYgYW4gaXRlcmFibGUgaXMgc3VwcGxpZWQsIHRoZW4gdGhlIHJldHVybmVkIGBFaXRoZXJgIHdpbGwgY29udGFpbiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gZmllbGRzIC0gdGhlIHN0cnVjdCBvZiBgRWl0aGVyYHMgdG8gYmUgc2VxdWVuY2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuYWxsKFtFaXRoZXIucmlnaHQoMSksIEVpdGhlci5yaWdodCgyKV0pLCBFaXRoZXIucmlnaHQoWzEsIDJdKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoRWl0aGVyLmFsbCh7IHJpZ2h0OiBFaXRoZXIucmlnaHQoMSksIGI6IEVpdGhlci5yaWdodChcImhlbGxvXCIpIH0pLCBFaXRoZXIucmlnaHQoeyByaWdodDogMSwgYjogXCJoZWxsb1wiIH0pKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChFaXRoZXIuYWxsKHsgcmlnaHQ6IEVpdGhlci5yaWdodCgxKSwgYjogRWl0aGVyLmxlZnQoXCJlcnJvclwiKSB9KSwgRWl0aGVyLmxlZnQoXCJlcnJvclwiKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5leHBvcnQgY29uc3QgYWxsID0gaW5wdXQgPT4ge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIGlucHV0KSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yIChjb25zdCBlIG9mIGlucHV0KSB7XG4gICAgICBpZiAoaXNMZWZ0KGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2goZS5yaWdodCk7XG4gICAgfVxuICAgIHJldHVybiByaWdodChvdXQpO1xuICB9XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICBjb25zdCBlID0gaW5wdXRba2V5XTtcbiAgICBpZiAoaXNMZWZ0KGUpKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgb3V0W2tleV0gPSBlLnJpZ2h0O1xuICB9XG4gIHJldHVybiByaWdodChvdXQpO1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBgRWl0aGVyYCB0aGF0IHN3YXBzIHRoZSBlcnJvci9zdWNjZXNzIGNhc2VzLiBUaGlzIGFsbG93cyB5b3UgdG9cbiAqIHVzZSBhbGwgbWV0aG9kcyBvbiB0aGUgZXJyb3IgY2hhbm5lbCwgcG9zc2libHkgYmVmb3JlIGZsaXBwaW5nIGJhY2suXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICovXG5leHBvcnQgY29uc3QgZmxpcCA9IHNlbGYgPT4gaXNMZWZ0KHNlbGYpID8gcmlnaHQoc2VsZi5sZWZ0KSA6IGxlZnQoc2VsZi5yaWdodCk7XG5jb25zdCBhZGFwdGVyID0gLyojX19QVVJFX18qL0dlbi5hZGFwdGVyKCk7XG4vKipcbiAqIEBjYXRlZ29yeSBnZW5lcmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbiA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGYgPSBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBhcmdzWzFdLmJpbmQoYXJnc1swXSk7XG4gIGNvbnN0IGl0ZXJhdG9yID0gZihhZGFwdGVyKTtcbiAgbGV0IHN0YXRlID0gaXRlcmF0b3IubmV4dCgpO1xuICBpZiAoc3RhdGUuZG9uZSkge1xuICAgIHJldHVybiByaWdodChzdGF0ZS52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzdGF0ZS52YWx1ZTtcbiAgICBpZiAoR2VuLmlzR2VuS2luZChjdXJyZW50KSkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBHZW4ueWllbGRXcmFwR2V0KGN1cnJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNMZWZ0KGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgd2hpbGUgKCFzdGF0ZS5kb25lKSB7XG4gICAgICBzdGF0ZSA9IGl0ZXJhdG9yLm5leHQoY3VycmVudC5yaWdodCk7XG4gICAgICBpZiAoIXN0YXRlLmRvbmUpIHtcbiAgICAgICAgY3VycmVudCA9IHN0YXRlLnZhbHVlO1xuICAgICAgICBpZiAoR2VuLmlzR2VuS2luZChjdXJyZW50KSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQgPSBHZW4ueWllbGRXcmFwR2V0KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xlZnQoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHQoc3RhdGUudmFsdWUpO1xuICB9XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZG8gbm90YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogVGhlIFwiZG8gc2ltdWxhdGlvblwiIGluIEVmZmVjdCBhbGxvd3MgeW91IHRvIHdyaXRlIGNvZGUgaW4gYSBtb3JlIGRlY2xhcmF0aXZlIHN0eWxlLCBzaW1pbGFyIHRvIHRoZSBcImRvIG5vdGF0aW9uXCIgaW4gb3RoZXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLiBJdCBwcm92aWRlcyBhIHdheSB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBwZXJmb3JtIG9wZXJhdGlvbnMgb24gdGhlbSB1c2luZyBmdW5jdGlvbnMgbGlrZSBgYmluZGAgYW5kIGBsZXRgLlxuICpcbiAqIEhlcmUncyBob3cgdGhlIGRvIHNpbXVsYXRpb24gd29ya3M6XG4gKlxuICogMS4gU3RhcnQgdGhlIGRvIHNpbXVsYXRpb24gdXNpbmcgdGhlIGBEb2AgdmFsdWVcbiAqIDIuIFdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiB1c2UgdGhlIGBiaW5kYCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gYEVpdGhlcmAgdmFsdWVzXG4gKiAzLiBZb3UgY2FuIGFjY3VtdWxhdGUgbXVsdGlwbGUgYGJpbmRgIHN0YXRlbWVudHMgdG8gZGVmaW5lIG11bHRpcGxlIHZhcmlhYmxlcyB3aXRoaW4gdGhlIHNjb3BlXG4gKiA0LiBJbnNpZGUgdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBsZXRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBzaW1wbGUgdmFsdWVzXG4gKlxuICogQHNlZSB7QGxpbmsgYmluZH1cbiAqIEBzZWUge0BsaW5rIGJpbmRUb31cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGlwZShcbiAqICAgRWl0aGVyLkRvLFxuICogICBFaXRoZXIuYmluZChcInhcIiwgKCkgPT4gRWl0aGVyLnJpZ2h0KDIpKSxcbiAqICAgRWl0aGVyLmJpbmQoXCJ5XCIsICgpID0+IEVpdGhlci5yaWdodCgzKSksXG4gKiAgIEVpdGhlci5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBFaXRoZXIucmlnaHQoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgRG8gPSAvKiNfX1BVUkVfXyovcmlnaHQoe30pO1xuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgRWl0aGVyYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqXG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGJpbmRUb31cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRWl0aGVyLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGlwZShcbiAqICAgRWl0aGVyLkRvLFxuICogICBFaXRoZXIuYmluZChcInhcIiwgKCkgPT4gRWl0aGVyLnJpZ2h0KDIpKSxcbiAqICAgRWl0aGVyLmJpbmQoXCJ5XCIsICgpID0+IEVpdGhlci5yaWdodCgzKSksXG4gKiAgIEVpdGhlci5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBFaXRoZXIucmlnaHQoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYmluZCA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmJpbmQobWFwLCBmbGF0TWFwKTtcbi8qKlxuICogVGhlIFwiZG8gc2ltdWxhdGlvblwiIGluIEVmZmVjdCBhbGxvd3MgeW91IHRvIHdyaXRlIGNvZGUgaW4gYSBtb3JlIGRlY2xhcmF0aXZlIHN0eWxlLCBzaW1pbGFyIHRvIHRoZSBcImRvIG5vdGF0aW9uXCIgaW4gb3RoZXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLiBJdCBwcm92aWRlcyBhIHdheSB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBwZXJmb3JtIG9wZXJhdGlvbnMgb24gdGhlbSB1c2luZyBmdW5jdGlvbnMgbGlrZSBgYmluZGAgYW5kIGBsZXRgLlxuICpcbiAqIEhlcmUncyBob3cgdGhlIGRvIHNpbXVsYXRpb24gd29ya3M6XG4gKlxuICogMS4gU3RhcnQgdGhlIGRvIHNpbXVsYXRpb24gdXNpbmcgdGhlIGBEb2AgdmFsdWVcbiAqIDIuIFdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiB1c2UgdGhlIGBiaW5kYCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gYEVpdGhlcmAgdmFsdWVzXG4gKiAzLiBZb3UgY2FuIGFjY3VtdWxhdGUgbXVsdGlwbGUgYGJpbmRgIHN0YXRlbWVudHMgdG8gZGVmaW5lIG11bHRpcGxlIHZhcmlhYmxlcyB3aXRoaW4gdGhlIHNjb3BlXG4gKiA0LiBJbnNpZGUgdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBsZXRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBzaW1wbGUgdmFsdWVzXG4gKlxuICogQHNlZSB7QGxpbmsgRG99XG4gKiBAc2VlIHtAbGluayBiaW5kfVxuICogQHNlZSB7QGxpbmsgbGV0XyBsZXR9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFaXRoZXIsIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaXBlKFxuICogICBFaXRoZXIuRG8sXG4gKiAgIEVpdGhlci5iaW5kKFwieFwiLCAoKSA9PiBFaXRoZXIucmlnaHQoMikpLFxuICogICBFaXRoZXIuYmluZChcInlcIiwgKCkgPT4gRWl0aGVyLnJpZ2h0KDMpKSxcbiAqICAgRWl0aGVyLmxldChcInN1bVwiLCAoeyB4LCB5IH0pID0+IHggKyB5KVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIEVpdGhlci5yaWdodCh7IHg6IDIsIHk6IDMsIHN1bTogNSB9KSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBiaW5kVG8gPSAvKiNfX1BVUkVfXyovZG9Ob3RhdGlvbi5iaW5kVG8obWFwKTtcbmNvbnN0IGxldF8gPSAvKiNfX1BVUkVfXyovZG9Ob3RhdGlvbi5sZXRfKG1hcCk7XG5leHBvcnQge1xuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgRWl0aGVyYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqXG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGJpbmRUb31cbiAqIEBzZWUge0BsaW5rIGJpbmR9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFaXRoZXIsIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaXBlKFxuICogICBFaXRoZXIuRG8sXG4gKiAgIEVpdGhlci5iaW5kKFwieFwiLCAoKSA9PiBFaXRoZXIucmlnaHQoMikpLFxuICogICBFaXRoZXIuYmluZChcInlcIiwgKCkgPT4gRWl0aGVyLnJpZ2h0KDMpKSxcbiAqICAgRWl0aGVyLmxldChcInN1bVwiLCAoeyB4LCB5IH0pID0+IHggKyB5KVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIEVpdGhlci5yaWdodCh7IHg6IDIsIHk6IDMsIHN1bTogNSB9KSlcbiAqXG4gKiBgYGBcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmxldF8gYXMgbGV0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FaXRoZXIuanMubWFwIl0sIm5hbWVzIjpbIkVxdWl2YWxlbmNlIiwiY29uc3ROdWxsIiwiY29uc3RVbmRlZmluZWQiLCJkdWFsIiwiaWRlbnRpdHkiLCJkb05vdGF0aW9uIiwiZWl0aGVyIiwiaXNGdW5jdGlvbiIsIkdlbiIsIlR5cGVJZCIsInJpZ2h0IiwibGVmdCIsImZyb21OdWxsYWJsZSIsInNlbGYiLCJvbk51bGxhYmxlIiwiZnJvbU9wdGlvbiIsInRyeV8iLCJldmFsdWF0ZSIsImUiLCJ0cnkiLCJjYXRjaCIsImlzRWl0aGVyIiwiaXNMZWZ0IiwiaXNSaWdodCIsImdldFJpZ2h0IiwiZ2V0TGVmdCIsImdldEVxdWl2YWxlbmNlIiwibWFrZSIsIngiLCJ5IiwibWFwQm90aCIsIm9uTGVmdCIsIm9uUmlnaHQiLCJtYXBMZWZ0IiwiZiIsIm1hcCIsIm1hdGNoIiwibGlmdFByZWRpY2F0ZSIsImEiLCJwcmVkaWNhdGUiLCJvckxlZnRXaXRoIiwiZmlsdGVyT3JMZWZ0IiwiZmxhdE1hcCIsInIiLCJtZXJnZSIsImdldE9yRWxzZSIsImdldE9yTnVsbCIsImdldE9yVW5kZWZpbmVkIiwiZ2V0T3JUaHJvd1dpdGgiLCJnZXRPclRocm93IiwiRXJyb3IiLCJvckVsc2UiLCJ0aGF0IiwiYW5kVGhlbiIsImIiLCJ6aXBXaXRoIiwicjIiLCJhcCIsImFsbCIsImlucHV0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvdXQiLCJwdXNoIiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsImZsaXAiLCJhZGFwdGVyIiwiZ2VuIiwiYXJncyIsImxlbmd0aCIsImJpbmQiLCJzdGF0ZSIsIm5leHQiLCJkb25lIiwidmFsdWUiLCJjdXJyZW50IiwiaXNHZW5LaW5kIiwieWllbGRXcmFwR2V0IiwiRG8iLCJiaW5kVG8iLCJsZXRfIiwibGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Either.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Encoding.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Encoding.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeException: () => (/* binding */ DecodeException),\n/* harmony export */   DecodeExceptionTypeId: () => (/* binding */ DecodeExceptionTypeId),\n/* harmony export */   EncodeException: () => (/* binding */ EncodeException),\n/* harmony export */   EncodeExceptionTypeId: () => (/* binding */ EncodeExceptionTypeId),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   decodeBase64String: () => (/* binding */ decodeBase64String),\n/* harmony export */   decodeBase64Url: () => (/* binding */ decodeBase64Url),\n/* harmony export */   decodeBase64UrlString: () => (/* binding */ decodeBase64UrlString),\n/* harmony export */   decodeHex: () => (/* binding */ decodeHex),\n/* harmony export */   decodeHexString: () => (/* binding */ decodeHexString),\n/* harmony export */   decodeUriComponent: () => (/* binding */ decodeUriComponent),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),\n/* harmony export */   encodeBase64Url: () => (/* binding */ encodeBase64Url),\n/* harmony export */   encodeHex: () => (/* binding */ encodeHex),\n/* harmony export */   encodeUriComponent: () => (/* binding */ encodeUriComponent),\n/* harmony export */   isDecodeException: () => (/* binding */ isDecodeException),\n/* harmony export */   isEncodeException: () => (/* binding */ isEncodeException)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/encoding/base64.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js\");\n/* harmony import */ var _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/encoding/base64Url.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64Url.js\");\n/* harmony import */ var _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/encoding/common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n/* harmony import */ var _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/encoding/hex.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/hex.js\");\n/**\n * This module provides encoding & decoding functionality for:\n *\n * - base64 (RFC4648)\n * - base64 (URL)\n * - hex\n *\n * @since 2.0.0\n */ \n\n\n\n\n/**\n * Encodes the given value into a base64 (RFC4648) `string`.\n *\n * @category encoding\n * @since 2.0.0\n */ const encodeBase64 = (input)=>typeof input === \"string\" ? _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__.encode(_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(input)) : _internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__.encode(input);\n/**\n * Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */ const decodeBase64 = (str)=>_internal_encoding_base64_js__WEBPACK_IMPORTED_MODULE_0__.decode(str);\n/**\n * Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */ const decodeBase64String = (str)=>_Either_js__WEBPACK_IMPORTED_MODULE_2__.map(decodeBase64(str), (_)=>_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_));\n/**\n * Encodes the given value into a base64 (URL) `string`.\n *\n * @category encoding\n * @since 2.0.0\n */ const encodeBase64Url = (input)=>typeof input === \"string\" ? _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__.encode(_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(input)) : _internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__.encode(input);\n/**\n * Decodes a base64 (URL) encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */ const decodeBase64Url = (str)=>_internal_encoding_base64Url_js__WEBPACK_IMPORTED_MODULE_3__.decode(str);\n/**\n * Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */ const decodeBase64UrlString = (str)=>_Either_js__WEBPACK_IMPORTED_MODULE_2__.map(decodeBase64Url(str), (_)=>_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_));\n/**\n * Encodes the given value into a hex `string`.\n *\n * @category encoding\n * @since 2.0.0\n */ const encodeHex = (input)=>typeof input === \"string\" ? _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.encode(_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(input)) : _internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.encode(input);\n/**\n * Decodes a hex encoded `string` into a `Uint8Array`.\n *\n * @category decoding\n * @since 2.0.0\n */ const decodeHex = (str)=>_internal_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.decode(str);\n/**\n * Decodes a hex encoded `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 2.0.0\n */ const decodeHexString = (str)=>_Either_js__WEBPACK_IMPORTED_MODULE_2__.map(decodeHex(str), (_)=>_internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_));\n/**\n * Encodes a UTF-8 `string` into a URI component `string`.\n *\n * @category encoding\n * @since 3.12.0\n */ const encodeUriComponent = (str)=>_Either_js__WEBPACK_IMPORTED_MODULE_2__[\"try\"]({\n        try: ()=>encodeURIComponent(str),\n        catch: (e)=>EncodeException(str, e instanceof Error ? e.message : \"Invalid input\")\n    });\n/**\n * Decodes a URI component `string` into a UTF-8 `string`.\n *\n * @category decoding\n * @since 3.12.0\n */ const decodeUriComponent = (str)=>_Either_js__WEBPACK_IMPORTED_MODULE_2__[\"try\"]({\n        try: ()=>decodeURIComponent(str),\n        catch: (e)=>DecodeException(str, e instanceof Error ? e.message : \"Invalid input\")\n    });\n/**\n * @since 2.0.0\n * @category symbols\n */ const DecodeExceptionTypeId = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeExceptionTypeId;\n/**\n * Creates a checked exception which occurs when decoding fails.\n *\n * @since 2.0.0\n * @category errors\n */ const DecodeException = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException;\n/**\n * Returns `true` if the specified value is an `DecodeException`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */ const isDecodeException = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.isDecodeException;\n/**\n * @since 3.12.0\n * @category symbols\n */ const EncodeExceptionTypeId = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.EncodeExceptionTypeId;\n/**\n * Creates a checked exception which occurs when encoding fails.\n *\n * @since 3.12.0\n * @category errors\n */ const EncodeException = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.EncodeException;\n/**\n * Returns `true` if the specified value is an `Exception`, `false` otherwise.\n *\n * @since 3.12.0\n * @category refinements\n */ const isEncodeException = _internal_encoding_common_js__WEBPACK_IMPORTED_MODULE_1__.isEncodeException; //# sourceMappingURL=Encoding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUNxQztBQUNrQjtBQUNNO0FBQ047QUFDTjtBQUNsRDs7Ozs7Q0FLQyxHQUNNLE1BQU1LLGVBQWVDLENBQUFBLFFBQVMsT0FBT0EsVUFBVSxXQUFXTCxnRUFBYSxDQUFDRSxpRUFBYyxDQUFDSSxNQUFNLENBQUNELFVBQVVMLGdFQUFhLENBQUNLLE9BQU87QUFDcEk7Ozs7O0NBS0MsR0FDTSxNQUFNRyxlQUFlQyxDQUFBQSxNQUFPVCxnRUFBYSxDQUFDUyxLQUFLO0FBQ3REOzs7OztDQUtDLEdBQ00sTUFBTUUscUJBQXFCRixDQUFBQSxNQUFPViwyQ0FBVSxDQUFDUyxhQUFhQyxNQUFNSSxDQUFBQSxJQUFLWCxpRUFBYyxDQUFDUSxNQUFNLENBQUNHLElBQUk7QUFDdEc7Ozs7O0NBS0MsR0FDTSxNQUFNRSxrQkFBa0JWLENBQUFBLFFBQVMsT0FBT0EsVUFBVSxXQUFXSixtRUFBZ0IsQ0FBQ0MsaUVBQWMsQ0FBQ0ksTUFBTSxDQUFDRCxVQUFVSixtRUFBZ0IsQ0FBQ0ksT0FBTztBQUM3STs7Ozs7Q0FLQyxHQUNNLE1BQU1XLGtCQUFrQlAsQ0FBQUEsTUFBT1IsbUVBQWdCLENBQUNRLEtBQUs7QUFDNUQ7Ozs7O0NBS0MsR0FDTSxNQUFNUSx3QkFBd0JSLENBQUFBLE1BQU9WLDJDQUFVLENBQUNpQixnQkFBZ0JQLE1BQU1JLENBQUFBLElBQUtYLGlFQUFjLENBQUNRLE1BQU0sQ0FBQ0csSUFBSTtBQUM1Rzs7Ozs7Q0FLQyxHQUNNLE1BQU1LLFlBQVliLENBQUFBLFFBQVMsT0FBT0EsVUFBVSxXQUFXRiw2REFBVSxDQUFDRCxpRUFBYyxDQUFDSSxNQUFNLENBQUNELFVBQVVGLDZEQUFVLENBQUNFLE9BQU87QUFDM0g7Ozs7O0NBS0MsR0FDTSxNQUFNYyxZQUFZVixDQUFBQSxNQUFPTiw2REFBVSxDQUFDTSxLQUFLO0FBQ2hEOzs7OztDQUtDLEdBQ00sTUFBTVcsa0JBQWtCWCxDQUFBQSxNQUFPViwyQ0FBVSxDQUFDb0IsVUFBVVYsTUFBTUksQ0FBQUEsSUFBS1gsaUVBQWMsQ0FBQ1EsTUFBTSxDQUFDRyxJQUFJO0FBQ2hHOzs7OztDQUtDLEdBQ00sTUFBTVEscUJBQXFCWixDQUFBQSxNQUFPViw4Q0FBVSxDQUFDO1FBQ2xEdUIsS0FBSyxJQUFNQyxtQkFBbUJkO1FBQzlCZSxPQUFPQyxDQUFBQSxJQUFLQyxnQkFBZ0JqQixLQUFLZ0IsYUFBYUUsUUFBUUYsRUFBRUcsT0FBTyxHQUFHO0lBQ3BFLEdBQUc7QUFDSDs7Ozs7Q0FLQyxHQUNNLE1BQU1DLHFCQUFxQnBCLENBQUFBLE1BQU9WLDhDQUFVLENBQUM7UUFDbER1QixLQUFLLElBQU1RLG1CQUFtQnJCO1FBQzlCZSxPQUFPQyxDQUFBQSxJQUFLTSxnQkFBZ0J0QixLQUFLZ0IsYUFBYUUsUUFBUUYsRUFBRUcsT0FBTyxHQUFHO0lBQ3BFLEdBQUc7QUFDSDs7O0NBR0MsR0FDTSxNQUFNSSx3QkFBd0I5QiwrRUFBNEIsQ0FBQztBQUNsRTs7Ozs7Q0FLQyxHQUNNLE1BQU02QixrQkFBa0I3Qix5RUFBc0IsQ0FBQztBQUN0RDs7Ozs7Q0FLQyxHQUNNLE1BQU0rQixvQkFBb0IvQiwyRUFBd0IsQ0FBQztBQUMxRDs7O0NBR0MsR0FDTSxNQUFNZ0Msd0JBQXdCaEMsK0VBQTRCLENBQUM7QUFDbEU7Ozs7O0NBS0MsR0FDTSxNQUFNd0Isa0JBQWtCeEIseUVBQXNCLENBQUM7QUFDdEQ7Ozs7O0NBS0MsR0FDTSxNQUFNaUMsb0JBQW9CakMsMkVBQXdCLENBQUMsQ0FDMUQsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9FbmNvZGluZy5qcz9mMWNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgZW5jb2RpbmcgJiBkZWNvZGluZyBmdW5jdGlvbmFsaXR5IGZvcjpcbiAqXG4gKiAtIGJhc2U2NCAoUkZDNDY0OClcbiAqIC0gYmFzZTY0IChVUkwpXG4gKiAtIGhleFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgKiBhcyBFaXRoZXIgZnJvbSBcIi4vRWl0aGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSBcIi4vaW50ZXJuYWwvZW5jb2RpbmcvYmFzZTY0LmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjRVcmwgZnJvbSBcIi4vaW50ZXJuYWwvZW5jb2RpbmcvYmFzZTY0VXJsLmpzXCI7XG5pbXBvcnQgKiBhcyBDb21tb24gZnJvbSBcIi4vaW50ZXJuYWwvZW5jb2RpbmcvY29tbW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSBcIi4vaW50ZXJuYWwvZW5jb2RpbmcvaGV4LmpzXCI7XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBiYXNlNjQgKFJGQzQ2NDgpIGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBlbmNvZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVCYXNlNjQgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBCYXNlNjQuZW5jb2RlKENvbW1vbi5lbmNvZGVyLmVuY29kZShpbnB1dCkpIDogQmFzZTY0LmVuY29kZShpbnB1dCk7XG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQgKFJGQzQ2NDgpIGVuY29kZWQgYHN0cmluZ2AgaW50byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAY2F0ZWdvcnkgZGVjb2RpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlQmFzZTY0ID0gc3RyID0+IEJhc2U2NC5kZWNvZGUoc3RyKTtcbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCAoUkZDNDY0OCkgZW5jb2RlZCBgc3RyaW5nYCBpbnRvIGEgVVRGLTggYHN0cmluZ2AuXG4gKlxuICogQGNhdGVnb3J5IGRlY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUJhc2U2NFN0cmluZyA9IHN0ciA9PiBFaXRoZXIubWFwKGRlY29kZUJhc2U2NChzdHIpLCBfID0+IENvbW1vbi5kZWNvZGVyLmRlY29kZShfKSk7XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBiYXNlNjQgKFVSTCkgYHN0cmluZ2AuXG4gKlxuICogQGNhdGVnb3J5IGVuY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUJhc2U2NFVybCA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IEJhc2U2NFVybC5lbmNvZGUoQ29tbW9uLmVuY29kZXIuZW5jb2RlKGlucHV0KSkgOiBCYXNlNjRVcmwuZW5jb2RlKGlucHV0KTtcbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCAoVVJMKSBlbmNvZGVkIGBzdHJpbmdgIGludG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQGNhdGVnb3J5IGRlY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUJhc2U2NFVybCA9IHN0ciA9PiBCYXNlNjRVcmwuZGVjb2RlKHN0cik7XG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQgKFVSTCkgZW5jb2RlZCBgc3RyaW5nYCBpbnRvIGEgVVRGLTggYHN0cmluZ2AuXG4gKlxuICogQGNhdGVnb3J5IGRlY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUJhc2U2NFVybFN0cmluZyA9IHN0ciA9PiBFaXRoZXIubWFwKGRlY29kZUJhc2U2NFVybChzdHIpLCBfID0+IENvbW1vbi5kZWNvZGVyLmRlY29kZShfKSk7XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBoZXggYHN0cmluZ2AuXG4gKlxuICogQGNhdGVnb3J5IGVuY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUhleCA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IEhleC5lbmNvZGUoQ29tbW9uLmVuY29kZXIuZW5jb2RlKGlucHV0KSkgOiBIZXguZW5jb2RlKGlucHV0KTtcbi8qKlxuICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIGBzdHJpbmdgIGludG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQGNhdGVnb3J5IGRlY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUhleCA9IHN0ciA9PiBIZXguZGVjb2RlKHN0cik7XG4vKipcbiAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBgc3RyaW5nYCBpbnRvIGEgVVRGLTggYHN0cmluZ2AuXG4gKlxuICogQGNhdGVnb3J5IGRlY29kaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUhleFN0cmluZyA9IHN0ciA9PiBFaXRoZXIubWFwKGRlY29kZUhleChzdHIpLCBfID0+IENvbW1vbi5kZWNvZGVyLmRlY29kZShfKSk7XG4vKipcbiAqIEVuY29kZXMgYSBVVEYtOCBgc3RyaW5nYCBpbnRvIGEgVVJJIGNvbXBvbmVudCBgc3RyaW5nYC5cbiAqXG4gKiBAY2F0ZWdvcnkgZW5jb2RpbmdcbiAqIEBzaW5jZSAzLjEyLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVVyaUNvbXBvbmVudCA9IHN0ciA9PiBFaXRoZXIudHJ5KHtcbiAgdHJ5OiAoKSA9PiBlbmNvZGVVUklDb21wb25lbnQoc3RyKSxcbiAgY2F0Y2g6IGUgPT4gRW5jb2RlRXhjZXB0aW9uKHN0ciwgZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogXCJJbnZhbGlkIGlucHV0XCIpXG59KTtcbi8qKlxuICogRGVjb2RlcyBhIFVSSSBjb21wb25lbnQgYHN0cmluZ2AgaW50byBhIFVURi04IGBzdHJpbmdgLlxuICpcbiAqIEBjYXRlZ29yeSBkZWNvZGluZ1xuICogQHNpbmNlIDMuMTIuMFxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlVXJpQ29tcG9uZW50ID0gc3RyID0+IEVpdGhlci50cnkoe1xuICB0cnk6ICgpID0+IGRlY29kZVVSSUNvbXBvbmVudChzdHIpLFxuICBjYXRjaDogZSA9PiBEZWNvZGVFeGNlcHRpb24oc3RyLCBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBcIkludmFsaWQgaW5wdXRcIilcbn0pO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBEZWNvZGVFeGNlcHRpb25UeXBlSWQgPSBDb21tb24uRGVjb2RlRXhjZXB0aW9uVHlwZUlkO1xuLyoqXG4gKiBDcmVhdGVzIGEgY2hlY2tlZCBleGNlcHRpb24gd2hpY2ggb2NjdXJzIHdoZW4gZGVjb2RpbmcgZmFpbHMuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZXJyb3JzXG4gKi9cbmV4cG9ydCBjb25zdCBEZWNvZGVFeGNlcHRpb24gPSBDb21tb24uRGVjb2RlRXhjZXB0aW9uO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGBEZWNvZGVFeGNlcHRpb25gLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSByZWZpbmVtZW50c1xuICovXG5leHBvcnQgY29uc3QgaXNEZWNvZGVFeGNlcHRpb24gPSBDb21tb24uaXNEZWNvZGVFeGNlcHRpb247XG4vKipcbiAqIEBzaW5jZSAzLjEyLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBFbmNvZGVFeGNlcHRpb25UeXBlSWQgPSBDb21tb24uRW5jb2RlRXhjZXB0aW9uVHlwZUlkO1xuLyoqXG4gKiBDcmVhdGVzIGEgY2hlY2tlZCBleGNlcHRpb24gd2hpY2ggb2NjdXJzIHdoZW4gZW5jb2RpbmcgZmFpbHMuXG4gKlxuICogQHNpbmNlIDMuMTIuMFxuICogQGNhdGVnb3J5IGVycm9yc1xuICovXG5leHBvcnQgY29uc3QgRW5jb2RlRXhjZXB0aW9uID0gQ29tbW9uLkVuY29kZUV4Y2VwdGlvbjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBgRXhjZXB0aW9uYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHNpbmNlIDMuMTIuMFxuICogQGNhdGVnb3J5IHJlZmluZW1lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VuY29kZUV4Y2VwdGlvbiA9IENvbW1vbi5pc0VuY29kZUV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVuY29kaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJFaXRoZXIiLCJCYXNlNjQiLCJCYXNlNjRVcmwiLCJDb21tb24iLCJIZXgiLCJlbmNvZGVCYXNlNjQiLCJpbnB1dCIsImVuY29kZSIsImVuY29kZXIiLCJkZWNvZGVCYXNlNjQiLCJzdHIiLCJkZWNvZGUiLCJkZWNvZGVCYXNlNjRTdHJpbmciLCJtYXAiLCJfIiwiZGVjb2RlciIsImVuY29kZUJhc2U2NFVybCIsImRlY29kZUJhc2U2NFVybCIsImRlY29kZUJhc2U2NFVybFN0cmluZyIsImVuY29kZUhleCIsImRlY29kZUhleCIsImRlY29kZUhleFN0cmluZyIsImVuY29kZVVyaUNvbXBvbmVudCIsInRyeSIsImVuY29kZVVSSUNvbXBvbmVudCIsImNhdGNoIiwiZSIsIkVuY29kZUV4Y2VwdGlvbiIsIkVycm9yIiwibWVzc2FnZSIsImRlY29kZVVyaUNvbXBvbmVudCIsImRlY29kZVVSSUNvbXBvbmVudCIsIkRlY29kZUV4Y2VwdGlvbiIsIkRlY29kZUV4Y2VwdGlvblR5cGVJZCIsImlzRGVjb2RlRXhjZXB0aW9uIiwiRW5jb2RlRXhjZXB0aW9uVHlwZUlkIiwiaXNFbmNvZGVFeGNlcHRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Equal.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Equal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   equivalence: () => (/* binding */ equivalence),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   symbol: () => (/* binding */ symbol)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n\n\n\n/**\n * @since 2.0.0\n * @category symbols\n */ const symbol = /*#__PURE__*/ Symbol.for(\"effect/Equal\");\nfunction equals() {\n    if (arguments.length === 1) {\n        return (self)=>compareBoth(self, arguments[0]);\n    }\n    return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n    if (self === that) {\n        return true;\n    }\n    const selfType = typeof self;\n    if (selfType !== typeof that) {\n        return false;\n    }\n    if (selfType === \"object\" || selfType === \"function\") {\n        if (self !== null && that !== null) {\n            if (isEqual(self) && isEqual(that)) {\n                if (_Hash_js__WEBPACK_IMPORTED_MODULE_0__.hash(self) === _Hash_js__WEBPACK_IMPORTED_MODULE_0__.hash(that) && self[symbol](that)) {\n                    return true;\n                } else {\n                    return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled && _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n                }\n            } else if (self instanceof Date && that instanceof Date) {\n                return self.toISOString() === that.toISOString();\n            }\n        }\n        if (_Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled) {\n            if (Array.isArray(self) && Array.isArray(that)) {\n                return self.length === that.length && self.every((v, i)=>compareBoth(v, that[i]));\n            }\n            if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {\n                const keysSelf = Object.keys(self);\n                const keysThat = Object.keys(that);\n                if (keysSelf.length === keysThat.length) {\n                    for (const key of keysSelf){\n                        // @ts-expect-error\n                        if (!(key in that && compareBoth(self[key], that[key]))) {\n                            return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n        }\n    }\n    return _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled && _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester ? _Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.tester(self, that) : false;\n}\n/**\n * @since 2.0.0\n * @category guards\n */ const isEqual = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(u, symbol);\n/**\n * @since 2.0.0\n * @category instances\n */ const equivalence = ()=>equals; //# sourceMappingURL=Equal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBa0M7QUFDVztBQUNNO0FBQ25EOzs7Q0FHQyxHQUNNLE1BQU1HLFNBQVMsV0FBVyxHQUFFQyxPQUFPQyxHQUFHLENBQUMsZ0JBQWdCO0FBQ3ZELFNBQVNDO0lBQ2QsSUFBSUMsVUFBVUMsTUFBTSxLQUFLLEdBQUc7UUFDMUIsT0FBT0MsQ0FBQUEsT0FBUUMsWUFBWUQsTUFBTUYsU0FBUyxDQUFDLEVBQUU7SUFDL0M7SUFDQSxPQUFPRyxZQUFZSCxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRTtBQUMvQztBQUNBLFNBQVNHLFlBQVlELElBQUksRUFBRUUsSUFBSTtJQUM3QixJQUFJRixTQUFTRSxNQUFNO1FBQ2pCLE9BQU87SUFDVDtJQUNBLE1BQU1DLFdBQVcsT0FBT0g7SUFDeEIsSUFBSUcsYUFBYSxPQUFPRCxNQUFNO1FBQzVCLE9BQU87SUFDVDtJQUNBLElBQUlDLGFBQWEsWUFBWUEsYUFBYSxZQUFZO1FBQ3BELElBQUlILFNBQVMsUUFBUUUsU0FBUyxNQUFNO1lBQ2xDLElBQUlFLFFBQVFKLFNBQVNJLFFBQVFGLE9BQU87Z0JBQ2xDLElBQUlYLDBDQUFTLENBQUNTLFVBQVVULDBDQUFTLENBQUNXLFNBQVNGLElBQUksQ0FBQ04sT0FBTyxDQUFDUSxPQUFPO29CQUM3RCxPQUFPO2dCQUNULE9BQU87b0JBQ0wsT0FBT1QsNERBQXFCQSxDQUFDYSxPQUFPLElBQUliLDREQUFxQkEsQ0FBQ2MsTUFBTSxHQUFHZCw0REFBcUJBLENBQUNjLE1BQU0sQ0FBQ1AsTUFBTUUsUUFBUTtnQkFDcEg7WUFDRixPQUFPLElBQUlGLGdCQUFnQlEsUUFBUU4sZ0JBQWdCTSxNQUFNO2dCQUN2RCxPQUFPUixLQUFLUyxXQUFXLE9BQU9QLEtBQUtPLFdBQVc7WUFDaEQ7UUFDRjtRQUNBLElBQUloQiw0REFBcUJBLENBQUNhLE9BQU8sRUFBRTtZQUNqQyxJQUFJSSxNQUFNQyxPQUFPLENBQUNYLFNBQVNVLE1BQU1DLE9BQU8sQ0FBQ1QsT0FBTztnQkFDOUMsT0FBT0YsS0FBS0QsTUFBTSxLQUFLRyxLQUFLSCxNQUFNLElBQUlDLEtBQUtZLEtBQUssQ0FBQyxDQUFDQyxHQUFHQyxJQUFNYixZQUFZWSxHQUFHWCxJQUFJLENBQUNZLEVBQUU7WUFDbkY7WUFDQSxJQUFJQyxPQUFPQyxjQUFjLENBQUNoQixVQUFVZSxPQUFPRSxTQUFTLElBQUlGLE9BQU9DLGNBQWMsQ0FBQ2hCLFVBQVVlLE9BQU9FLFNBQVMsRUFBRTtnQkFDeEcsTUFBTUMsV0FBV0gsT0FBT0ksSUFBSSxDQUFDbkI7Z0JBQzdCLE1BQU1vQixXQUFXTCxPQUFPSSxJQUFJLENBQUNqQjtnQkFDN0IsSUFBSWdCLFNBQVNuQixNQUFNLEtBQUtxQixTQUFTckIsTUFBTSxFQUFFO29CQUN2QyxLQUFLLE1BQU1zQixPQUFPSCxTQUFVO3dCQUMxQixtQkFBbUI7d0JBQ25CLElBQUksQ0FBRUcsQ0FBQUEsT0FBT25CLFFBQVFELFlBQVlELElBQUksQ0FBQ3FCLElBQUksRUFBRW5CLElBQUksQ0FBQ21CLElBQUksSUFBSTs0QkFDdkQsT0FBTzVCLDREQUFxQkEsQ0FBQ2MsTUFBTSxHQUFHZCw0REFBcUJBLENBQUNjLE1BQU0sQ0FBQ1AsTUFBTUUsUUFBUTt3QkFDbkY7b0JBQ0Y7b0JBQ0EsT0FBTztnQkFDVDtZQUNGO1lBQ0EsT0FBT1QsNERBQXFCQSxDQUFDYyxNQUFNLEdBQUdkLDREQUFxQkEsQ0FBQ2MsTUFBTSxDQUFDUCxNQUFNRSxRQUFRO1FBQ25GO0lBQ0Y7SUFDQSxPQUFPVCw0REFBcUJBLENBQUNhLE9BQU8sSUFBSWIsNERBQXFCQSxDQUFDYyxNQUFNLEdBQUdkLDREQUFxQkEsQ0FBQ2MsTUFBTSxDQUFDUCxNQUFNRSxRQUFRO0FBQ3BIO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUUsVUFBVWtCLENBQUFBLElBQUs5QiwwREFBV0EsQ0FBQzhCLEdBQUc1QixRQUFRO0FBQ25EOzs7Q0FHQyxHQUNNLE1BQU02QixjQUFjLElBQU0xQixPQUFPLENBQ3hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vRXF1YWwuanM/ZWMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gXCIuL0hhc2guanNcIjtcbmltcG9ydCB7IGhhc1Byb3BlcnR5IH0gZnJvbSBcIi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgeyBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUgfSBmcm9tIFwiLi9VdGlscy5qc1wiO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9FcXVhbFwiKTtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNlbGYgPT4gY29tcGFyZUJvdGgoc2VsZiwgYXJndW1lbnRzWzBdKTtcbiAgfVxuICByZXR1cm4gY29tcGFyZUJvdGgoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xufVxuZnVuY3Rpb24gY29tcGFyZUJvdGgoc2VsZiwgdGhhdCkge1xuICBpZiAoc2VsZiA9PT0gdGhhdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGZUeXBlID0gdHlwZW9mIHNlbGY7XG4gIGlmIChzZWxmVHlwZSAhPT0gdHlwZW9mIHRoYXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNlbGZUeXBlID09PSBcIm9iamVjdFwiIHx8IHNlbGZUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoc2VsZiAhPT0gbnVsbCAmJiB0aGF0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNFcXVhbChzZWxmKSAmJiBpc0VxdWFsKHRoYXQpKSB7XG4gICAgICAgIGlmIChIYXNoLmhhc2goc2VsZikgPT09IEhhc2guaGFzaCh0aGF0KSAmJiBzZWxmW3N5bWJvbF0odGhhdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RydWN0dXJhbFJlZ2lvblN0YXRlLmVuYWJsZWQgJiYgc3RydWN0dXJhbFJlZ2lvblN0YXRlLnRlc3RlciA/IHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXIoc2VsZiwgdGhhdCkgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxmIGluc3RhbmNlb2YgRGF0ZSAmJiB0aGF0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gc2VsZi50b0lTT1N0cmluZygpID09PSB0aGF0LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZikgJiYgQXJyYXkuaXNBcnJheSh0aGF0KSkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IHRoYXQubGVuZ3RoICYmIHNlbGYuZXZlcnkoKHYsIGkpID0+IGNvbXBhcmVCb3RoKHYsIHRoYXRbaV0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VsZikgPT09IE9iamVjdC5wcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlbGYpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGNvbnN0IGtleXNTZWxmID0gT2JqZWN0LmtleXMoc2VsZik7XG4gICAgICAgIGNvbnN0IGtleXNUaGF0ID0gT2JqZWN0LmtleXModGhhdCk7XG4gICAgICAgIGlmIChrZXlzU2VsZi5sZW5ndGggPT09IGtleXNUaGF0Lmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNTZWxmKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhhdCAmJiBjb21wYXJlQm90aChzZWxmW2tleV0sIHRoYXRba2V5XSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyID8gc3RydWN0dXJhbFJlZ2lvblN0YXRlLnRlc3RlcihzZWxmLCB0aGF0KSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXIgPyBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyKHNlbGYsIHRoYXQpIDogZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZCAmJiBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyID8gc3RydWN0dXJhbFJlZ2lvblN0YXRlLnRlc3RlcihzZWxmLCB0aGF0KSA6IGZhbHNlO1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSB1ID0+IGhhc1Byb3BlcnR5KHUsIHN5bWJvbCk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICovXG5leHBvcnQgY29uc3QgZXF1aXZhbGVuY2UgPSAoKSA9PiBlcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcXVhbC5qcy5tYXAiXSwibmFtZXMiOlsiSGFzaCIsImhhc1Byb3BlcnR5Iiwic3RydWN0dXJhbFJlZ2lvblN0YXRlIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiZXF1YWxzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2VsZiIsImNvbXBhcmVCb3RoIiwidGhhdCIsInNlbGZUeXBlIiwiaXNFcXVhbCIsImhhc2giLCJlbmFibGVkIiwidGVzdGVyIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJ2IiwiaSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwia2V5c1NlbGYiLCJrZXlzIiwia2V5c1RoYXQiLCJrZXkiLCJ1IiwiZXF1aXZhbGVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Equivalence.js":
/*!*****************************************************!*\
  !*** ./node_modules/effect/dist/esm/Equivalence.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Date: () => (/* binding */ Date),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   combineAll: () => (/* binding */ combineAll),\n/* harmony export */   combineMany: () => (/* binding */ combineMany),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   strict: () => (/* binding */ strict),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   tuple: () => (/* binding */ tuple)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/**\n * This module provides an implementation of the `Equivalence` type class, which defines a binary relation\n * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\n * These properties are also known in mathematics as an \"equivalence relation\".\n *\n * @since 2.0.0\n */ \n/**\n * @category constructors\n * @since 2.0.0\n */ const make = (isEquivalent)=>(self, that)=>self === that || isEquivalent(self, that);\nconst isStrictEquivalent = (x, y)=>x === y;\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values.\n *\n * @since 2.0.0\n * @category constructors\n */ const strict = ()=>isStrictEquivalent;\n/**\n * @category instances\n * @since 2.0.0\n */ const string = /*#__PURE__*/ strict();\n/**\n * @category instances\n * @since 2.0.0\n */ const number = /*#__PURE__*/ strict();\n/**\n * @category instances\n * @since 2.0.0\n */ const boolean = /*#__PURE__*/ strict();\n/**\n * @category instances\n * @since 2.0.0\n */ const bigint = /*#__PURE__*/ strict();\n/**\n * @category instances\n * @since 2.0.0\n */ const symbol = /*#__PURE__*/ strict();\n/**\n * @category combining\n * @since 2.0.0\n */ const combine = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>make((x, y)=>self(x, y) && that(x, y)));\n/**\n * @category combining\n * @since 2.0.0\n */ const combineMany = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, collection)=>make((x, y)=>{\n        if (!self(x, y)) {\n            return false;\n        }\n        for (const equivalence of collection){\n            if (!equivalence(x, y)) {\n                return false;\n            }\n        }\n        return true;\n    }));\nconst isAlwaysEquivalent = (_x, _y)=>true;\n/**\n * @category combining\n * @since 2.0.0\n */ const combineAll = (collection)=>combineMany(isAlwaysEquivalent, collection);\n/**\n * @category mapping\n * @since 2.0.0\n */ const mapInput = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>make((x, y)=>self(f(x), f(y))));\n/**\n * @category instances\n * @since 2.0.0\n */ const Date = /*#__PURE__*/ mapInput(number, (date)=>date.getTime());\n/**\n * @category combining\n * @since 2.0.0\n */ const product = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>make(([xa, xb], [ya, yb])=>self(xa, ya) && that(xb, yb)));\n/**\n * @category combining\n * @since 2.0.0\n */ const all = (collection)=>{\n    return make((x, y)=>{\n        const len = Math.min(x.length, y.length);\n        let collectionLength = 0;\n        for (const equivalence of collection){\n            if (collectionLength >= len) {\n                break;\n            }\n            if (!equivalence(x[collectionLength], y[collectionLength])) {\n                return false;\n            }\n            collectionLength++;\n        }\n        return true;\n    });\n};\n/**\n * @category combining\n * @since 2.0.0\n */ const productMany = (self, collection)=>{\n    const equivalence = all(collection);\n    return make((x, y)=>!self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));\n};\n/**\n * Similar to `Promise.all` but operates on `Equivalence`s.\n *\n * ```\n * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n * ```\n *\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */ const tuple = (...elements)=>all(elements);\n/**\n * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.\n *\n * @category combinators\n * @since 2.0.0\n */ const array = (item)=>make((self, that)=>{\n        if (self.length !== that.length) {\n            return false;\n        }\n        for(let i = 0; i < self.length; i++){\n            const isEq = item(self[i], that[i]);\n            if (!isEq) {\n                return false;\n            }\n        }\n        return true;\n    });\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category combinators\n * @since 2.0.0\n */ const struct = (fields)=>{\n    const keys = Object.keys(fields);\n    return make((self, that)=>{\n        for (const key of keys){\n            if (!fields[key](self[key], that[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n}; //# sourceMappingURL=Equivalence.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0VxdWl2YWxlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDb0M7QUFDckM7OztDQUdDLEdBQ00sTUFBTUMsT0FBT0MsQ0FBQUEsZUFBZ0IsQ0FBQ0MsTUFBTUMsT0FBU0QsU0FBU0MsUUFBUUYsYUFBYUMsTUFBTUMsTUFBTTtBQUM5RixNQUFNQyxxQkFBcUIsQ0FBQ0MsR0FBR0MsSUFBTUQsTUFBTUM7QUFDM0M7Ozs7O0NBS0MsR0FDTSxNQUFNQyxTQUFTLElBQU1ILG1CQUFtQjtBQUMvQzs7O0NBR0MsR0FDTSxNQUFNSSxTQUFTLFdBQVcsR0FBRUQsU0FBUztBQUM1Qzs7O0NBR0MsR0FDTSxNQUFNRSxTQUFTLFdBQVcsR0FBRUYsU0FBUztBQUM1Qzs7O0NBR0MsR0FDTSxNQUFNRyxVQUFVLFdBQVcsR0FBRUgsU0FBUztBQUM3Qzs7O0NBR0MsR0FDTSxNQUFNSSxTQUFTLFdBQVcsR0FBRUosU0FBUztBQUM1Qzs7O0NBR0MsR0FDTSxNQUFNSyxTQUFTLFdBQVcsR0FBRUwsU0FBUztBQUM1Qzs7O0NBR0MsR0FDTSxNQUFNTSxVQUFVLFdBQVcsR0FBRWQsa0RBQUlBLENBQUMsR0FBRyxDQUFDRyxNQUFNQyxPQUFTSCxLQUFLLENBQUNLLEdBQUdDLElBQU1KLEtBQUtHLEdBQUdDLE1BQU1ILEtBQUtFLEdBQUdDLEtBQUs7QUFDdEc7OztDQUdDLEdBQ00sTUFBTVEsY0FBYyxXQUFXLEdBQUVmLGtEQUFJQSxDQUFDLEdBQUcsQ0FBQ0csTUFBTWEsYUFBZWYsS0FBSyxDQUFDSyxHQUFHQztRQUM3RSxJQUFJLENBQUNKLEtBQUtHLEdBQUdDLElBQUk7WUFDZixPQUFPO1FBQ1Q7UUFDQSxLQUFLLE1BQU1VLGVBQWVELFdBQVk7WUFDcEMsSUFBSSxDQUFDQyxZQUFZWCxHQUFHQyxJQUFJO2dCQUN0QixPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVCxJQUFJO0FBQ0osTUFBTVcscUJBQXFCLENBQUNDLElBQUlDLEtBQU87QUFDdkM7OztDQUdDLEdBQ00sTUFBTUMsYUFBYUwsQ0FBQUEsYUFBY0QsWUFBWUcsb0JBQW9CRixZQUFZO0FBQ3BGOzs7Q0FHQyxHQUNNLE1BQU1NLFdBQVcsV0FBVyxHQUFFdEIsa0RBQUlBLENBQUMsR0FBRyxDQUFDRyxNQUFNb0IsSUFBTXRCLEtBQUssQ0FBQ0ssR0FBR0MsSUFBTUosS0FBS29CLEVBQUVqQixJQUFJaUIsRUFBRWhCLE1BQU07QUFDNUY7OztDQUdDLEdBQ00sTUFBTWlCLE9BQU8sV0FBVyxHQUFFRixTQUFTWixRQUFRZSxDQUFBQSxPQUFRQSxLQUFLQyxPQUFPLElBQUk7QUFDMUU7OztDQUdDLEdBQ00sTUFBTUMsVUFBVSxXQUFXLEdBQUUzQixrREFBSUEsQ0FBQyxHQUFHLENBQUNHLE1BQU1DLE9BQVNILEtBQUssQ0FBQyxDQUFDMkIsSUFBSUMsR0FBRyxFQUFFLENBQUNDLElBQUlDLEdBQUcsR0FBSzVCLEtBQUt5QixJQUFJRSxPQUFPMUIsS0FBS3lCLElBQUlFLE1BQU07QUFDeEg7OztDQUdDLEdBQ00sTUFBTUMsTUFBTWhCLENBQUFBO0lBQ2pCLE9BQU9mLEtBQUssQ0FBQ0ssR0FBR0M7UUFDZCxNQUFNMEIsTUFBTUMsS0FBS0MsR0FBRyxDQUFDN0IsRUFBRThCLE1BQU0sRUFBRTdCLEVBQUU2QixNQUFNO1FBQ3ZDLElBQUlDLG1CQUFtQjtRQUN2QixLQUFLLE1BQU1wQixlQUFlRCxXQUFZO1lBQ3BDLElBQUlxQixvQkFBb0JKLEtBQUs7Z0JBQzNCO1lBQ0Y7WUFDQSxJQUFJLENBQUNoQixZQUFZWCxDQUFDLENBQUMrQixpQkFBaUIsRUFBRTlCLENBQUMsQ0FBQzhCLGlCQUFpQixHQUFHO2dCQUMxRCxPQUFPO1lBQ1Q7WUFDQUE7UUFDRjtRQUNBLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFDRjs7O0NBR0MsR0FDTSxNQUFNQyxjQUFjLENBQUNuQyxNQUFNYTtJQUNoQyxNQUFNQyxjQUFjZSxJQUFJaEI7SUFDeEIsT0FBT2YsS0FBSyxDQUFDSyxHQUFHQyxJQUFNLENBQUNKLEtBQUtHLENBQUMsQ0FBQyxFQUFFLEVBQUVDLENBQUMsQ0FBQyxFQUFFLElBQUksUUFBUVUsWUFBWVgsRUFBRWlDLEtBQUssQ0FBQyxJQUFJaEMsRUFBRWdDLEtBQUssQ0FBQztBQUNwRixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTUMsUUFBUSxDQUFDLEdBQUdDLFdBQWFULElBQUlTLFVBQVU7QUFDcEQ7Ozs7O0NBS0MsR0FDTSxNQUFNQyxRQUFRQyxDQUFBQSxPQUFRMUMsS0FBSyxDQUFDRSxNQUFNQztRQUN2QyxJQUFJRCxLQUFLaUMsTUFBTSxLQUFLaEMsS0FBS2dDLE1BQU0sRUFBRTtZQUMvQixPQUFPO1FBQ1Q7UUFDQSxJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSXpDLEtBQUtpQyxNQUFNLEVBQUVRLElBQUs7WUFDcEMsTUFBTUMsT0FBT0YsS0FBS3hDLElBQUksQ0FBQ3lDLEVBQUUsRUFBRXhDLElBQUksQ0FBQ3dDLEVBQUU7WUFDbEMsSUFBSSxDQUFDQyxNQUFNO2dCQUNULE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNULEdBQUc7QUFDSDs7Ozs7O0NBTUMsR0FDTSxNQUFNQyxTQUFTQyxDQUFBQTtJQUNwQixNQUFNQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNEO0lBQ3pCLE9BQU85QyxLQUFLLENBQUNFLE1BQU1DO1FBQ2pCLEtBQUssTUFBTThDLE9BQU9GLEtBQU07WUFDdEIsSUFBSSxDQUFDRCxNQUFNLENBQUNHLElBQUksQ0FBQy9DLElBQUksQ0FBQytDLElBQUksRUFBRTlDLElBQUksQ0FBQzhDLElBQUksR0FBRztnQkFDdEMsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7QUFDRixFQUFFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9FcXVpdmFsZW5jZS5qcz83N2I2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBFcXVpdmFsZW5jZWAgdHlwZSBjbGFzcywgd2hpY2ggZGVmaW5lcyBhIGJpbmFyeSByZWxhdGlvblxuICogdGhhdCBpcyByZWZsZXhpdmUsIHN5bW1ldHJpYywgYW5kIHRyYW5zaXRpdmUuIEluIG90aGVyIHdvcmRzLCBpdCBkZWZpbmVzIGEgbm90aW9uIG9mIGVxdWl2YWxlbmNlIGJldHdlZW4gdmFsdWVzIG9mIGEgY2VydGFpbiB0eXBlLlxuICogVGhlc2UgcHJvcGVydGllcyBhcmUgYWxzbyBrbm93biBpbiBtYXRoZW1hdGljcyBhcyBhbiBcImVxdWl2YWxlbmNlIHJlbGF0aW9uXCIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCB7IGR1YWwgfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1ha2UgPSBpc0VxdWl2YWxlbnQgPT4gKHNlbGYsIHRoYXQpID0+IHNlbGYgPT09IHRoYXQgfHwgaXNFcXVpdmFsZW50KHNlbGYsIHRoYXQpO1xuY29uc3QgaXNTdHJpY3RFcXVpdmFsZW50ID0gKHgsIHkpID0+IHggPT09IHk7XG4vKipcbiAqIFJldHVybiBhbiBgRXF1aXZhbGVuY2VgIHRoYXQgdXNlcyBzdHJpY3QgZXF1YWxpdHkgKD09PSkgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpY3QgPSAoKSA9PiBpc1N0cmljdEVxdWl2YWxlbnQ7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5nID0gLyojX19QVVJFX18qL3N0cmljdCgpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IC8qI19fUFVSRV9fKi9zdHJpY3QoKTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBib29sZWFuID0gLyojX19QVVJFX18qL3N0cmljdCgpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpZ2ludCA9IC8qI19fUFVSRV9fKi9zdHJpY3QoKTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSAvKiNfX1BVUkVfXyovc3RyaWN0KCk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29tYmluZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBtYWtlKCh4LCB5KSA9PiBzZWxmKHgsIHkpICYmIHRoYXQoeCwgeSkpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lTWFueSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBjb2xsZWN0aW9uKSA9PiBtYWtlKCh4LCB5KSA9PiB7XG4gIGlmICghc2VsZih4LCB5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGVxdWl2YWxlbmNlIG9mIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoIWVxdWl2YWxlbmNlKHgsIHkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufSkpO1xuY29uc3QgaXNBbHdheXNFcXVpdmFsZW50ID0gKF94LCBfeSkgPT4gdHJ1ZTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lQWxsID0gY29sbGVjdGlvbiA9PiBjb21iaW5lTWFueShpc0Fsd2F5c0VxdWl2YWxlbnQsIGNvbGxlY3Rpb24pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBJbnB1dCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBtYWtlKCh4LCB5KSA9PiBzZWxmKGYoeCksIGYoeSkpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgRGF0ZSA9IC8qI19fUFVSRV9fKi9tYXBJbnB1dChudW1iZXIsIGRhdGUgPT4gZGF0ZS5nZXRUaW1lKCkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3QgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gbWFrZSgoW3hhLCB4Yl0sIFt5YSwgeWJdKSA9PiBzZWxmKHhhLCB5YSkgJiYgdGhhdCh4YiwgeWIpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWxsID0gY29sbGVjdGlvbiA9PiB7XG4gIHJldHVybiBtYWtlKCh4LCB5KSA9PiB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBsZXQgY29sbGVjdGlvbkxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBlcXVpdmFsZW5jZSBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbkxlbmd0aCA+PSBsZW4pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWVxdWl2YWxlbmNlKHhbY29sbGVjdGlvbkxlbmd0aF0sIHlbY29sbGVjdGlvbkxlbmd0aF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbGxlY3Rpb25MZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0TWFueSA9IChzZWxmLCBjb2xsZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGVxdWl2YWxlbmNlID0gYWxsKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gbWFrZSgoeCwgeSkgPT4gIXNlbGYoeFswXSwgeVswXSkgPyBmYWxzZSA6IGVxdWl2YWxlbmNlKHguc2xpY2UoMSksIHkuc2xpY2UoMSkpKTtcbn07XG4vKipcbiAqIFNpbWlsYXIgdG8gYFByb21pc2UuYWxsYCBidXQgb3BlcmF0ZXMgb24gYEVxdWl2YWxlbmNlYHMuXG4gKlxuICogYGBgXG4gKiBbRXF1aXZhbGVuY2U8QT4sIEVxdWl2YWxlbmNlPEI+LCAuLi5dIC0+IEVxdWl2YWxlbmNlPFtBLCBCLCAuLi5dPlxuICogYGBgXG4gKlxuICogR2l2ZW4gYSB0dXBsZSBvZiBgRXF1aXZhbGVuY2VgcyByZXR1cm5zIGEgbmV3IGBFcXVpdmFsZW5jZWAgdGhhdCBjb21wYXJlcyB2YWx1ZXMgb2YgYSB0dXBsZVxuICogYnkgYXBwbHlpbmcgZWFjaCBgRXF1aXZhbGVuY2VgIHRvIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0dXBsZSA9ICguLi5lbGVtZW50cykgPT4gYWxsKGVsZW1lbnRzKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgRXF1aXZhbGVuY2VgIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMgYmFzZWQgb24gYSBnaXZlbiBgRXF1aXZhbGVuY2VgIGZvciB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcnJheSA9IGl0ZW0gPT4gbWFrZSgoc2VsZiwgdGhhdCkgPT4ge1xuICBpZiAoc2VsZi5sZW5ndGggIT09IHRoYXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGlzRXEgPSBpdGVtKHNlbGZbaV0sIHRoYXRbaV0pO1xuICAgIGlmICghaXNFcSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBHaXZlbiBhIHN0cnVjdCBvZiBgRXF1aXZhbGVuY2VgcyByZXR1cm5zIGEgbmV3IGBFcXVpdmFsZW5jZWAgdGhhdCBjb21wYXJlcyB2YWx1ZXMgb2YgYSBzdHJ1Y3RcbiAqIGJ5IGFwcGx5aW5nIGVhY2ggYEVxdWl2YWxlbmNlYCB0byB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBvZiB0aGUgc3RydWN0LlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJ1Y3QgPSBmaWVsZHMgPT4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgcmV0dXJuIG1ha2UoKHNlbGYsIHRoYXQpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIWZpZWxkc1trZXldKHNlbGZba2V5XSwgdGhhdFtrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcXVpdmFsZW5jZS5qcy5tYXAiXSwibmFtZXMiOlsiZHVhbCIsIm1ha2UiLCJpc0VxdWl2YWxlbnQiLCJzZWxmIiwidGhhdCIsImlzU3RyaWN0RXF1aXZhbGVudCIsIngiLCJ5Iiwic3RyaWN0Iiwic3RyaW5nIiwibnVtYmVyIiwiYm9vbGVhbiIsImJpZ2ludCIsInN5bWJvbCIsImNvbWJpbmUiLCJjb21iaW5lTWFueSIsImNvbGxlY3Rpb24iLCJlcXVpdmFsZW5jZSIsImlzQWx3YXlzRXF1aXZhbGVudCIsIl94IiwiX3kiLCJjb21iaW5lQWxsIiwibWFwSW5wdXQiLCJmIiwiRGF0ZSIsImRhdGUiLCJnZXRUaW1lIiwicHJvZHVjdCIsInhhIiwieGIiLCJ5YSIsInliIiwiYWxsIiwibGVuIiwiTWF0aCIsIm1pbiIsImxlbmd0aCIsImNvbGxlY3Rpb25MZW5ndGgiLCJwcm9kdWN0TWFueSIsInNsaWNlIiwidHVwbGUiLCJlbGVtZW50cyIsImFycmF5IiwiaXRlbSIsImkiLCJpc0VxIiwic3RydWN0IiwiZmllbGRzIiwia2V5cyIsIk9iamVjdCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Equivalence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Function.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Function.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SK: () => (/* binding */ SK),\n/* harmony export */   absurd: () => (/* binding */ absurd),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   constFalse: () => (/* binding */ constFalse),\n/* harmony export */   constNull: () => (/* binding */ constNull),\n/* harmony export */   constTrue: () => (/* binding */ constTrue),\n/* harmony export */   constUndefined: () => (/* binding */ constUndefined),\n/* harmony export */   constVoid: () => (/* binding */ constVoid),\n/* harmony export */   constant: () => (/* binding */ constant),\n/* harmony export */   dual: () => (/* binding */ dual),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   flow: () => (/* binding */ flow),\n/* harmony export */   hole: () => (/* binding */ hole),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   satisfies: () => (/* binding */ satisfies),\n/* harmony export */   tupled: () => (/* binding */ tupled),\n/* harmony export */   unsafeCoerce: () => (/* binding */ unsafeCoerce),\n/* harmony export */   untupled: () => (/* binding */ untupled)\n/* harmony export */ });\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isFunction = (input)=>typeof input === \"function\";\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * @param arity - Either the arity of the uncurried function or a predicate\n *                which determines if the function is being used in a data-first\n *                or data-last style.\n * @param body - The definition of the uncurried function.\n *\n * @example\n * ```ts\n * import { dual, pipe } from \"effect/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n * ```\n *\n * @since 2.0.0\n */ const dual = function(arity, body) {\n    if (typeof arity === \"function\") {\n        return function() {\n            if (arity(arguments)) {\n                // @ts-expect-error\n                return body.apply(this, arguments);\n            }\n            return (self)=>body(self, ...arguments);\n        };\n    }\n    switch(arity){\n        case 0:\n        case 1:\n            throw new RangeError(`Invalid arity ${arity}`);\n        case 2:\n            return function(a, b) {\n                if (arguments.length >= 2) {\n                    return body(a, b);\n                }\n                return function(self) {\n                    return body(self, a);\n                };\n            };\n        case 3:\n            return function(a, b, c) {\n                if (arguments.length >= 3) {\n                    return body(a, b, c);\n                }\n                return function(self) {\n                    return body(self, a, b);\n                };\n            };\n        case 4:\n            return function(a, b, c, d) {\n                if (arguments.length >= 4) {\n                    return body(a, b, c, d);\n                }\n                return function(self) {\n                    return body(self, a, b, c);\n                };\n            };\n        case 5:\n            return function(a, b, c, d, e) {\n                if (arguments.length >= 5) {\n                    return body(a, b, c, d, e);\n                }\n                return function(self) {\n                    return body(self, a, b, c, d);\n                };\n            };\n        default:\n            return function() {\n                if (arguments.length >= arity) {\n                    // @ts-expect-error\n                    return body.apply(this, arguments);\n                }\n                const args = arguments;\n                return function(self) {\n                    return body(self, ...args);\n                };\n            };\n    }\n};\n/**\n * Apply a function to a given value.\n *\n * @param a - The value that the function will be applied to.\n * @param self - The function to be applied to a value.\n *\n * @example\n * ```ts\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from \"effect/String\"\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n * ```\n *\n * @since 2.0.0\n */ const apply = (a)=>(self)=>self(a);\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @param a - The input argument.\n *\n * @example\n * ```ts\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n * ```\n *\n * @since 2.0.0\n */ const identity = (a)=>a;\n/**\n * A function that ensures that the type of an expression matches some type,\n * without changing the resulting type of that expression.\n *\n * @example\n * ```ts\n * import { satisfies } from \"effect/Function\"\n *\n * const test1 = satisfies<number>()(5 as const)\n *     //^? const test: 5\n *     // @ts-expect-error\n * const test2 = satisfies<string>()(5)\n *     //^? Argument of type 'number' is not assignable to parameter of type 'string'\n *\n * assert.deepStrictEqual(satisfies<number>()(5), 5)\n * ```\n *\n * @since 2.0.0\n */ const satisfies = ()=>(b)=>b;\n/**\n * Casts the result to the specified type.\n *\n * @param a - The value to be casted to the target type.\n *\n * @example\n * ```ts\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n * ```\n *\n * @since 2.0.0\n */ const unsafeCoerce = identity;\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @param value - The constant value to be returned.\n *\n * @example\n * ```ts\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */ const constant = (value)=>()=>value;\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * ```ts\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n * ```\n *\n * @since 2.0.0\n */ const constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * ```ts\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n * ```\n *\n * @since 2.0.0\n */ const constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * ```ts\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */ const constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * ```ts\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n * ```\n *\n * @since 2.0.0\n */ const constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * ```ts\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n * ```\n *\n * @since 2.0.0\n */ const constVoid = constUndefined;\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @param f - A curried function that takes multiple arguments.\n *\n * @example\n * ```ts\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n * ```\n *\n * @since 2.0.0\n */ const flip = (f)=>(...b)=>(...a)=>f(...a)(...b);\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @param ab - A function that maps from `A` to `B`.\n * @param bc - A function that maps from `B` to `C`.\n *\n * @example\n * ```ts\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n * ```\n *\n * @since 2.0.0\n */ const compose = /*#__PURE__*/ dual(2, (ab, bc)=>(a)=>bc(ab(a)));\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly useful when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */ const absurd = (_)=>{\n    throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * ```ts\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n * ```\n *\n * @since 2.0.0\n */ const tupled = (f)=>(a)=>f(...a);\n/**\n * Inverse function of `tupled`\n *\n * @example\n * ```ts\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n * ```\n *\n * @since 2.0.0\n */ const untupled = (f)=>(...a)=>f(a);\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch(arguments.length){\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default:\n            {\n                let ret = arguments[0];\n                for(let i = 1; i < arguments.length; i++){\n                    ret = arguments[i](ret);\n                }\n                return ret;\n            }\n    }\n}\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch(arguments.length){\n        case 1:\n            return ab;\n        case 2:\n            return function() {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function() {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function() {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function() {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function() {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function() {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function() {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function() {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */ const hole = /*#__PURE__*/ unsafeCoerce(absurd);\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @param _ - The first argument to be discarded.\n * @param b - The second argument to be returned.\n *\n * @example\n * ```ts\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n * ```\n *\n * @since 2.0.0\n */ const SK = (_, b)=>b; //# sourceMappingURL=Function.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLE1BQU1BLGFBQWFDLENBQUFBLFFBQVMsT0FBT0EsVUFBVSxXQUFXO0FBQy9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQ0MsR0FDTSxNQUFNQyxPQUFPLFNBQVVDLEtBQUssRUFBRUMsSUFBSTtJQUN2QyxJQUFJLE9BQU9ELFVBQVUsWUFBWTtRQUMvQixPQUFPO1lBQ0wsSUFBSUEsTUFBTUUsWUFBWTtnQkFDcEIsbUJBQW1CO2dCQUNuQixPQUFPRCxLQUFLRSxLQUFLLENBQUMsSUFBSSxFQUFFRDtZQUMxQjtZQUNBLE9BQU9FLENBQUFBLE9BQVFILEtBQUtHLFNBQVNGO1FBQy9CO0lBQ0Y7SUFDQSxPQUFRRjtRQUNOLEtBQUs7UUFDTCxLQUFLO1lBQ0gsTUFBTSxJQUFJSyxXQUFXLENBQUMsY0FBYyxFQUFFTCxNQUFNLENBQUM7UUFDL0MsS0FBSztZQUNILE9BQU8sU0FBVU0sQ0FBQyxFQUFFQyxDQUFDO2dCQUNuQixJQUFJTCxVQUFVTSxNQUFNLElBQUksR0FBRztvQkFDekIsT0FBT1AsS0FBS0ssR0FBR0M7Z0JBQ2pCO2dCQUNBLE9BQU8sU0FBVUgsSUFBSTtvQkFDbkIsT0FBT0gsS0FBS0csTUFBTUU7Z0JBQ3BCO1lBQ0Y7UUFDRixLQUFLO1lBQ0gsT0FBTyxTQUFVQSxDQUFDLEVBQUVDLENBQUMsRUFBRUUsQ0FBQztnQkFDdEIsSUFBSVAsVUFBVU0sTUFBTSxJQUFJLEdBQUc7b0JBQ3pCLE9BQU9QLEtBQUtLLEdBQUdDLEdBQUdFO2dCQUNwQjtnQkFDQSxPQUFPLFNBQVVMLElBQUk7b0JBQ25CLE9BQU9ILEtBQUtHLE1BQU1FLEdBQUdDO2dCQUN2QjtZQUNGO1FBQ0YsS0FBSztZQUNILE9BQU8sU0FBVUQsQ0FBQyxFQUFFQyxDQUFDLEVBQUVFLENBQUMsRUFBRUMsQ0FBQztnQkFDekIsSUFBSVIsVUFBVU0sTUFBTSxJQUFJLEdBQUc7b0JBQ3pCLE9BQU9QLEtBQUtLLEdBQUdDLEdBQUdFLEdBQUdDO2dCQUN2QjtnQkFDQSxPQUFPLFNBQVVOLElBQUk7b0JBQ25CLE9BQU9ILEtBQUtHLE1BQU1FLEdBQUdDLEdBQUdFO2dCQUMxQjtZQUNGO1FBQ0YsS0FBSztZQUNILE9BQU8sU0FBVUgsQ0FBQyxFQUFFQyxDQUFDLEVBQUVFLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO2dCQUM1QixJQUFJVCxVQUFVTSxNQUFNLElBQUksR0FBRztvQkFDekIsT0FBT1AsS0FBS0ssR0FBR0MsR0FBR0UsR0FBR0MsR0FBR0M7Z0JBQzFCO2dCQUNBLE9BQU8sU0FBVVAsSUFBSTtvQkFDbkIsT0FBT0gsS0FBS0csTUFBTUUsR0FBR0MsR0FBR0UsR0FBR0M7Z0JBQzdCO1lBQ0Y7UUFDRjtZQUNFLE9BQU87Z0JBQ0wsSUFBSVIsVUFBVU0sTUFBTSxJQUFJUixPQUFPO29CQUM3QixtQkFBbUI7b0JBQ25CLE9BQU9DLEtBQUtFLEtBQUssQ0FBQyxJQUFJLEVBQUVEO2dCQUMxQjtnQkFDQSxNQUFNVSxPQUFPVjtnQkFDYixPQUFPLFNBQVVFLElBQUk7b0JBQ25CLE9BQU9ILEtBQUtHLFNBQVNRO2dCQUN2QjtZQUNGO0lBQ0o7QUFDRixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTVQsUUFBUUcsQ0FBQUEsSUFBS0YsQ0FBQUEsT0FBUUEsS0FBS0UsR0FBRztBQUMxQzs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTU8sV0FBV1AsQ0FBQUEsSUFBS0EsRUFBRTtBQUMvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sTUFBTVEsWUFBWSxJQUFNUCxDQUFBQSxJQUFLQSxFQUFFO0FBQ3RDOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNUSxlQUFlRixTQUFTO0FBQ3JDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sTUFBTUcsV0FBV0MsQ0FBQUEsUUFBUyxJQUFNQSxNQUFNO0FBQzdDOzs7Ozs7Ozs7OztDQVdDLEdBQ00sTUFBTUMsWUFBWSxXQUFXLEdBQUVGLFNBQVMsTUFBTTtBQUNyRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLE1BQU1HLGFBQWEsV0FBVyxHQUFFSCxTQUFTLE9BQU87QUFDdkQ7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxNQUFNSSxZQUFZLFdBQVcsR0FBRUosU0FBUyxNQUFNO0FBQ3JEOzs7Ozs7Ozs7OztDQVdDLEdBQ00sTUFBTUssaUJBQWlCLFdBQVcsR0FBRUwsU0FBU00sV0FBVztBQUMvRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLE1BQU1DLFlBQVlGLGVBQWU7QUFDeEM7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTUcsT0FBT0MsQ0FBQUEsSUFBSyxDQUFDLEdBQUdsQixJQUFNLENBQUMsR0FBR0QsSUFBTW1CLEtBQUtuQixNQUFNQyxHQUFHO0FBQzNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxNQUFNbUIsVUFBVSxXQUFXLEdBQUUzQixLQUFLLEdBQUcsQ0FBQzRCLElBQUlDLEtBQU90QixDQUFBQSxJQUFLc0IsR0FBR0QsR0FBR3JCLEtBQUs7QUFDeEU7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU11QixTQUFTQyxDQUFBQTtJQUNwQixNQUFNLElBQUlDLE1BQU07QUFDbEIsRUFBRTtBQUNGOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNQyxTQUFTUCxDQUFBQSxJQUFLbkIsQ0FBQUEsSUFBS21CLEtBQUtuQixHQUFHO0FBQ3hDOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNMkIsV0FBV1IsQ0FBQUEsSUFBSyxDQUFDLEdBQUduQixJQUFNbUIsRUFBRW5CLEdBQUc7QUFDckMsU0FBUzRCLEtBQUs1QixDQUFDLEVBQUVxQixFQUFFLEVBQUVDLEVBQUUsRUFBRU8sRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUU7SUFDcEQsT0FBUXRDLFVBQVVNLE1BQU07UUFDdEIsS0FBSztZQUNILE9BQU9GO1FBQ1QsS0FBSztZQUNILE9BQU9xQixHQUFHckI7UUFDWixLQUFLO1lBQ0gsT0FBT3NCLEdBQUdELEdBQUdyQjtRQUNmLEtBQUs7WUFDSCxPQUFPNkIsR0FBR1AsR0FBR0QsR0FBR3JCO1FBQ2xCLEtBQUs7WUFDSCxPQUFPOEIsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3JCO1FBQ3JCLEtBQUs7WUFDSCxPQUFPK0IsR0FBR0QsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3JCO1FBQ3hCLEtBQUs7WUFDSCxPQUFPZ0MsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3JCO1FBQzNCLEtBQUs7WUFDSCxPQUFPaUMsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3JCO1FBQzlCLEtBQUs7WUFDSCxPQUFPa0MsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3JCO1FBQ2pDO1lBQ0U7Z0JBQ0UsSUFBSW1DLE1BQU12QyxTQUFTLENBQUMsRUFBRTtnQkFDdEIsSUFBSyxJQUFJd0MsSUFBSSxHQUFHQSxJQUFJeEMsVUFBVU0sTUFBTSxFQUFFa0MsSUFBSztvQkFDekNELE1BQU12QyxTQUFTLENBQUN3QyxFQUFFLENBQUNEO2dCQUNyQjtnQkFDQSxPQUFPQTtZQUNUO0lBQ0o7QUFDRjtBQUNPLFNBQVNFLEtBQUtoQixFQUFFLEVBQUVDLEVBQUUsRUFBRU8sRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUksRUFBRTtJQUNyRCxPQUFRMUMsVUFBVU0sTUFBTTtRQUN0QixLQUFLO1lBQ0gsT0FBT21CO1FBQ1QsS0FBSztZQUNILE9BQU87Z0JBQ0wsT0FBT0MsR0FBR0QsR0FBR3hCLEtBQUssQ0FBQyxJQUFJLEVBQUVEO1lBQzNCO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsT0FBT2lDLEdBQUdQLEdBQUdELEdBQUd4QixLQUFLLENBQUMsSUFBSSxFQUFFRDtZQUM5QjtRQUNGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLE9BQU9rQyxHQUFHRCxHQUFHUCxHQUFHRCxHQUFHeEIsS0FBSyxDQUFDLElBQUksRUFBRUQ7WUFDakM7UUFDRixLQUFLO1lBQ0gsT0FBTztnQkFDTCxPQUFPbUMsR0FBR0QsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3hCLEtBQUssQ0FBQyxJQUFJLEVBQUVEO1lBQ3BDO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsT0FBT29DLEdBQUdELEdBQUdELEdBQUdELEdBQUdQLEdBQUdELEdBQUd4QixLQUFLLENBQUMsSUFBSSxFQUFFRDtZQUN2QztRQUNGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLE9BQU9xQyxHQUFHRCxHQUFHRCxHQUFHRCxHQUFHRCxHQUFHUCxHQUFHRCxHQUFHeEIsS0FBSyxDQUFDLElBQUksRUFBRUQ7WUFDMUM7UUFDRixLQUFLO1lBQ0gsT0FBTztnQkFDTCxPQUFPc0MsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR0QsR0FBR1AsR0FBR0QsR0FBR3hCLEtBQUssQ0FBQyxJQUFJLEVBQUVEO1lBQzdDO1FBQ0YsS0FBSztZQUNILE9BQU87Z0JBQ0wsT0FBTzBDLEdBQUdKLEdBQUdELEdBQUdELEdBQUdELEdBQUdELEdBQUdELEdBQUdQLEdBQUdELEdBQUd4QixLQUFLLENBQUMsSUFBSSxFQUFFRDtZQUNoRDtJQUNKO0lBQ0E7QUFDRjtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNMkMsT0FBTyxXQUFXLEdBQUU5QixhQUFhYyxRQUFRO0FBQ3REOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1pQixLQUFLLENBQUNoQixHQUFHdkIsSUFBTUEsRUFBRSxDQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0Z1bmN0aW9uLmpzPzFjZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYGZ1bmN0aW9uYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0Z1bmN0aW9uKGlzRnVuY3Rpb24pLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0Z1bmN0aW9uKFwiZnVuY3Rpb25cIiksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gaW5wdXQgPT4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgZGF0YS1sYXN0IChha2EgYHBpcGVgYWJsZSkgb3JcbiAqIGRhdGEtZmlyc3Qgc3R5bGUuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciB0byBgZHVhbGAgaXMgZWl0aGVyIHRoZSBhcml0eSBvZiB0aGUgdW5jdXJyaWVkIGZ1bmN0aW9uXG4gKiBvciBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIHVzZWQgaW4gYSBkYXRhLWZpcnN0XG4gKiBvciBkYXRhLWxhc3Qgc3R5bGUuXG4gKlxuICogVXNpbmcgdGhlIGFyaXR5IGlzIHRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZSwgYnV0IHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlXG4gKiB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgcHJlZGljYXRlLiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgYSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiBvcHRpb25hbCBhcmd1bWVudCwgeW91IGNhbiB1c2UgYSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIGlmIHRoZVxuICogZnVuY3Rpb24gaXMgYmVpbmcgdXNlZCBpbiBhIGRhdGEtZmlyc3Qgb3IgZGF0YS1sYXN0IHN0eWxlLlxuICpcbiAqIEBwYXJhbSBhcml0eSAtIEVpdGhlciB0aGUgYXJpdHkgb2YgdGhlIHVuY3VycmllZCBmdW5jdGlvbiBvciBhIHByZWRpY2F0ZVxuICogICAgICAgICAgICAgICAgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZnVuY3Rpb24gaXMgYmVpbmcgdXNlZCBpbiBhIGRhdGEtZmlyc3RcbiAqICAgICAgICAgICAgICAgIG9yIGRhdGEtbGFzdCBzdHlsZS5cbiAqIEBwYXJhbSBib2R5IC0gVGhlIGRlZmluaXRpb24gb2YgdGhlIHVuY3VycmllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGR1YWwsIHBpcGUgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiAvLyBFeGFtcGUgdXNpbmcgYXJpdHkgdG8gZGV0ZXJtaW5lIGRhdGEtZmlyc3Qgb3IgZGF0YS1sYXN0IHN0eWxlXG4gKiBjb25zdCBzdW06IHtcbiAqICAgKHRoYXQ6IG51bWJlcik6IChzZWxmOiBudW1iZXIpID0+IG51bWJlclxuICogICAoc2VsZjogbnVtYmVyLCB0aGF0OiBudW1iZXIpOiBudW1iZXJcbiAqIH0gPSBkdWFsKDIsIChzZWxmOiBudW1iZXIsIHRoYXQ6IG51bWJlcik6IG51bWJlciA9PiBzZWxmICsgdGhhdClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN1bSgyLCAzKSwgNSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZSgyLCBzdW0oMykpLCA1KVxuICpcbiAqIC8vIEV4YW1wbGUgdXNpbmcgYSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIGRhdGEtZmlyc3Qgb3IgZGF0YS1sYXN0IHN0eWxlXG4gKiBjb25zdCBzdW0yOiB7XG4gKiAgICh0aGF0OiBudW1iZXIpOiAoc2VsZjogbnVtYmVyKSA9PiBudW1iZXJcbiAqICAgKHNlbGY6IG51bWJlciwgdGhhdDogbnVtYmVyKTogbnVtYmVyXG4gKiB9ID0gZHVhbCgoYXJncykgPT4gYXJncy5sZW5ndGggPT09IDEsIChzZWxmOiBudW1iZXIsIHRoYXQ6IG51bWJlcik6IG51bWJlciA9PiBzZWxmICsgdGhhdClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN1bSgyLCAzKSwgNSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZSgyLCBzdW0oMykpLCA1KVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkdWFsID0gZnVuY3Rpb24gKGFyaXR5LCBib2R5KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYXJpdHkoYXJndW1lbnRzKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZiA9PiBib2R5KHNlbGYsIC4uLmFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKGFyaXR5KSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGFyaXR5ICR7YXJpdHl9YCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiLCBjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhLCBiKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiLCBjLCBkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhLCBiLCBjKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gYm9keShzZWxmLCBhLCBiLCBjLCBkKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IGFyaXR5KSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkoc2VsZiwgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGEgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgdmFsdWUgdGhhdCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBhcHBsaWVkIHRvLlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZnVuY3Rpb24gdG8gYmUgYXBwbGllZCB0byBhIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcGlwZSwgYXBwbHkgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqIGltcG9ydCB7IGxlbmd0aCB9IGZyb20gXCJlZmZlY3QvU3RyaW5nXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUobGVuZ3RoLCBhcHBseShcImhlbGxvXCIpKSwgNSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBhID0+IHNlbGYgPT4gc2VsZihhKTtcbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLCBpLmUuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0cyBpbnB1dCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBpbnB1dCBhcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpZGVudGl0eSg1KSwgNSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSBhID0+IGE7XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBlbnN1cmVzIHRoYXQgdGhlIHR5cGUgb2YgYW4gZXhwcmVzc2lvbiBtYXRjaGVzIHNvbWUgdHlwZSxcbiAqIHdpdGhvdXQgY2hhbmdpbmcgdGhlIHJlc3VsdGluZyB0eXBlIG9mIHRoYXQgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNhdGlzZmllcyB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGNvbnN0IHRlc3QxID0gc2F0aXNmaWVzPG51bWJlcj4oKSg1IGFzIGNvbnN0KVxuICogICAgIC8vXj8gY29uc3QgdGVzdDogNVxuICogICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAqIGNvbnN0IHRlc3QyID0gc2F0aXNmaWVzPHN0cmluZz4oKSg1KVxuICogICAgIC8vXj8gQXJndW1lbnQgb2YgdHlwZSAnbnVtYmVyJyBpcyBub3QgYXNzaWduYWJsZSB0byBwYXJhbWV0ZXIgb2YgdHlwZSAnc3RyaW5nJ1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc2F0aXNmaWVzPG51bWJlcj4oKSg1KSwgNSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2F0aXNmaWVzID0gKCkgPT4gYiA9PiBiO1xuLyoqXG4gKiBDYXN0cyB0aGUgcmVzdWx0IHRvIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSB2YWx1ZSB0byBiZSBjYXN0ZWQgdG8gdGhlIHRhcmdldCB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdW5zYWZlQ29lcmNlLCBpZGVudGl0eSB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwodW5zYWZlQ29lcmNlLCBpZGVudGl0eSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdW5zYWZlQ29lcmNlID0gaWRlbnRpdHk7XG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdGFudCB2YWx1ZSB0aGF0IG5ldmVyIGNoYW5nZXMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBwYXNzIGEgdmFsdWUgdG8gYSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gKGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbm90aGVyIGZ1bmN0aW9uIGFzIGl0cyBhcmd1bWVudClcbiAqIGFuZCB3YW50IHRoYXQgaW5uZXIgZnVuY3Rpb24gdG8gYWx3YXlzIHVzZSB0aGUgc2FtZSB2YWx1ZSwgbm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgY29uc3RhbnQgdmFsdWUgdG8gYmUgcmV0dXJuZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjb25zdGFudCB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGNvbnN0IGNvbnN0TnVsbCA9IGNvbnN0YW50KG51bGwpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChjb25zdE51bGwoKSwgbnVsbClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoY29uc3ROdWxsKCksIG51bGwpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0YW50ID0gdmFsdWUgPT4gKCkgPT4gdmFsdWU7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjb25zdFRydWUgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGNvbnN0VHJ1ZSgpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb25zdFRydWUgPSAvKiNfX1BVUkVfXyovY29uc3RhbnQodHJ1ZSk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgZmFsc2VgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY29uc3RGYWxzZSB9IGZyb20gXCJlZmZlY3QvRnVuY3Rpb25cIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoY29uc3RGYWxzZSgpLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29uc3RGYWxzZSA9IC8qI19fUFVSRV9fKi9jb25zdGFudChmYWxzZSk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgbnVsbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjb25zdE51bGwgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGNvbnN0TnVsbCgpLCBudWxsKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb25zdE51bGwgPSAvKiNfX1BVUkVfXyovY29uc3RhbnQobnVsbCk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNvbnN0VW5kZWZpbmVkIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChjb25zdFVuZGVmaW5lZCgpLCB1bmRlZmluZWQpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0VW5kZWZpbmVkID0gLyojX19QVVJFX18qL2NvbnN0YW50KHVuZGVmaW5lZCk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdm9pZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjb25zdFZvaWQgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGNvbnN0Vm9pZCgpLCB1bmRlZmluZWQpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnN0Vm9pZCA9IGNvbnN0VW5kZWZpbmVkO1xuLyoqXG4gKiBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgYXJndW1lbnRzIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGYgLSBBIGN1cnJpZWQgZnVuY3Rpb24gdGhhdCB0YWtlcyBtdWx0aXBsZSBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmbGlwIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogY29uc3QgZiA9IChhOiBudW1iZXIpID0+IChiOiBzdHJpbmcpID0+IGEgLSBiLmxlbmd0aFxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZmxpcChmKSgnYWFhJykoMiksIC0xKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGlwID0gZiA9PiAoLi4uYikgPT4gKC4uLmEpID0+IGYoLi4uYSkoLi4uYik7XG4vKipcbiAqIENvbXBvc2VzIHR3byBmdW5jdGlvbnMsIGBhYmAgYW5kIGBiY2AgaW50byBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHRha2VzIGluIGFuIGFyZ3VtZW50IGBhYCBvZiB0eXBlIGBBYCBhbmQgcmV0dXJucyBhIHJlc3VsdCBvZiB0eXBlIGBDYC5cbiAqIFRoZSByZXN1bHQgaXMgb2J0YWluZWQgYnkgZmlyc3QgYXBwbHlpbmcgdGhlIGBhYmAgZnVuY3Rpb24gdG8gYGFgIGFuZCB0aGVuIGFwcGx5aW5nIHRoZSBgYmNgIGZ1bmN0aW9uIHRvIHRoZSByZXN1bHQgb2YgYGFiYC5cbiAqXG4gKiBAcGFyYW0gYWIgLSBBIGZ1bmN0aW9uIHRoYXQgbWFwcyBmcm9tIGBBYCB0byBgQmAuXG4gKiBAcGFyYW0gYmMgLSBBIGZ1bmN0aW9uIHRoYXQgbWFwcyBmcm9tIGBCYCB0byBgQ2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjb21wb3NlIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogY29uc3QgaW5jcmVtZW50ID0gKG46IG51bWJlcikgPT4gbiArIDE7XG4gKiBjb25zdCBzcXVhcmUgPSAobjogbnVtYmVyKSA9PiBuICogbjtcbiAqXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoY29tcG9zZShpbmNyZW1lbnQsIHNxdWFyZSkoMiksIDkpO1xuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wb3NlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKGFiLCBiYykgPT4gYSA9PiBiYyhhYihhKSkpO1xuLyoqXG4gKiBUaGUgYGFic3VyZGAgZnVuY3Rpb24gaXMgYSBzdHViIGZvciBjYXNlcyB3aGVyZSBhIHZhbHVlIG9mIHR5cGUgYG5ldmVyYCBpcyBlbmNvdW50ZXJlZCBpbiB5b3VyIGNvZGUsXG4gKiBtZWFuaW5nIHRoYXQgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgZm9yIHRoaXMgY29kZSB0byBiZSBleGVjdXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiBpdCdzIG5lY2Vzc2FyeSB0byBzcGVjaWZ5IHRoYXQgY2VydGFpbiBjYXNlcyBhcmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFic3VyZCA9IF8gPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgYGFic3VyZGAgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIHVuY2FsbGFibGVcIik7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgdHVwbGVkIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbjogaW5zdGVhZCBvZiBgbmAgYXJndW1lbnRzLCBpdCBhY2NlcHRzIGEgc2luZ2xlIHR1cGxlIGFyZ3VtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdHVwbGVkIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiXG4gKlxuICogY29uc3Qgc3VtVHVwbGVkID0gdHVwbGVkKCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciA9PiB4ICsgeSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN1bVR1cGxlZChbMSwgMl0pLCAzKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0dXBsZWQgPSBmID0+IGEgPT4gZiguLi5hKTtcbi8qKlxuICogSW52ZXJzZSBmdW5jdGlvbiBvZiBgdHVwbGVkYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdW50dXBsZWQgfSBmcm9tIFwiZWZmZWN0L0Z1bmN0aW9uXCJcbiAqXG4gKiBjb25zdCBnZXRGaXJzdCA9IHVudHVwbGVkKDxBLCBCPih0dXBsZTogW0EsIEJdKTogQSA9PiB0dXBsZVswXSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGdldEZpcnN0KDEsIDIpLCAxKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB1bnR1cGxlZCA9IGYgPT4gKC4uLmEpID0+IGYoYSk7XG5leHBvcnQgZnVuY3Rpb24gcGlwZShhLCBhYiwgYmMsIGNkLCBkZSwgZWYsIGZnLCBnaCwgaGkpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGE7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGFiKGEpO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBiYyhhYihhKSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGNkKGJjKGFiKGEpKSk7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIGRlKGNkKGJjKGFiKGEpKSkpO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBlZihkZShjZChiYyhhYihhKSkpKSk7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGZnKGVmKGRlKGNkKGJjKGFiKGEpKSkpKSk7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGdoKGZnKGVmKGRlKGNkKGJjKGFiKGEpKSkpKSkpO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBoaShnaChmZyhlZihkZShjZChiYyhhYihhKSkpKSkpKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgbGV0IHJldCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXQgPSBhcmd1bWVudHNbaV0ocmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZmxvdyhhYiwgYmMsIGNkLCBkZSwgZWYsIGZnLCBnaCwgaGksIGlqKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBhYjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZShjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpO1xuICAgICAgfTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSk7XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmZyhlZihkZShjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpKSk7XG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnaChmZyhlZihkZShjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpKSkpO1xuICAgICAgfTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGkoZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKSk7XG4gICAgICB9O1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpaihoaShnaChmZyhlZihkZShjZChiYyhhYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpKSkpKSk7XG4gICAgICB9O1xuICB9XG4gIHJldHVybjtcbn1cbi8qKlxuICogVHlwZSBob2xlIHNpbXVsYXRpb24uXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBob2xlID0gLyojX19QVVJFX18qL3Vuc2FmZUNvZXJjZShhYnN1cmQpO1xuLyoqXG4gKiBUaGUgU0sgY29tYmluYXRvciwgYWxzbyBrbm93biBhcyB0aGUgXCJTLUsgY29tYmluYXRvclwiIG9yIFwiUy1jb21iaW5hdG9yXCIsIGlzIGEgZnVuZGFtZW50YWwgY29tYmluYXRvciBpbiB0aGVcbiAqIGxhbWJkYSBjYWxjdWx1cyBhbmQgdGhlIFNLSSBjb21iaW5hdG9yIGNhbGN1bHVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBkaXNjYXJkaW5nIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gaXQgYW5kIHJldHVybmluZyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSBfIC0gVGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGRpc2NhcmRlZC5cbiAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBhcmd1bWVudCB0byBiZSByZXR1cm5lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFNLIH0gZnJvbSBcImVmZmVjdC9GdW5jdGlvblwiO1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoU0soMCwgXCJoZWxsb1wiKSwgXCJoZWxsb1wiKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBTSyA9IChfLCBiKSA9PiBiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbImlzRnVuY3Rpb24iLCJpbnB1dCIsImR1YWwiLCJhcml0eSIsImJvZHkiLCJhcmd1bWVudHMiLCJhcHBseSIsInNlbGYiLCJSYW5nZUVycm9yIiwiYSIsImIiLCJsZW5ndGgiLCJjIiwiZCIsImUiLCJhcmdzIiwiaWRlbnRpdHkiLCJzYXRpc2ZpZXMiLCJ1bnNhZmVDb2VyY2UiLCJjb25zdGFudCIsInZhbHVlIiwiY29uc3RUcnVlIiwiY29uc3RGYWxzZSIsImNvbnN0TnVsbCIsImNvbnN0VW5kZWZpbmVkIiwidW5kZWZpbmVkIiwiY29uc3RWb2lkIiwiZmxpcCIsImYiLCJjb21wb3NlIiwiYWIiLCJiYyIsImFic3VyZCIsIl8iLCJFcnJvciIsInR1cGxlZCIsInVudHVwbGVkIiwicGlwZSIsImNkIiwiZGUiLCJlZiIsImZnIiwiZ2giLCJoaSIsInJldCIsImkiLCJmbG93IiwiaWoiLCJob2xlIiwiU0siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Function.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/GlobalValue.js":
/*!*****************************************************!*\
  !*** ./node_modules/effect/dist/esm/GlobalValue.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globalValue: () => (/* binding */ globalValue)\n/* harmony export */ });\n/* harmony import */ var _internal_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/version.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/version.js\");\n/**\n * The `GlobalValue` module ensures that a single instance of a value is created globally,\n * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)\n * or during hot-reloading in development environments like Next.js or Remix.\n *\n * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to\n * the current version of the `effect` library. The store holds values that are keyed by an identifier,\n * allowing the reuse of previously computed instances across imports or reloads.\n *\n * This pattern is particularly useful in scenarios where frequent reloading can cause services or\n * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.\n *\n * @since 2.0.0\n */ \nconst globalStoreId = /*#__PURE__*/ Symbol.for(`effect/GlobalValue/globalStoreId/${_internal_version_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentVersion()}`);\nif (!(globalStoreId in globalThis)) {\n    ;\n    globalThis[globalStoreId] = /*#__PURE__*/ new Map();\n}\nconst globalStore = globalThis[globalStoreId];\n/**\n * Retrieves or computes a global value associated with the given `id`. If the value for this `id`\n * has already been computed, it will be returned from the global store. If it does not exist yet,\n * the provided `compute` function will be executed to compute the value, store it, and then return it.\n *\n * This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments\n * like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused\n * thereafter.\n *\n * @example\n * ```ts\n * import { globalValue } from \"effect/GlobalValue\"\n *\n * // This cache will persist as long as the module is running,\n * // even if reloaded or imported elsewhere\n * const myCache = globalValue(\n *   Symbol.for(\"myCache\"),\n *   () => new WeakMap<object, number>()\n * )\n * ```\n *\n * @since 2.0.0\n */ const globalValue = (id, compute)=>{\n    if (!globalStore.has(id)) {\n        globalStore.set(id, compute());\n    }\n    return globalStore.get(id);\n}; //# sourceMappingURL=GlobalValue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0dsb2JhbFZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNnRDtBQUNqRCxNQUFNQyxnQkFBZ0IsV0FBVyxHQUFFQyxPQUFPQyxHQUFHLENBQUMsQ0FBQyxpQ0FBaUMsRUFBZUgsbUVBQXlCLEdBQUcsQ0FBQztBQUM1SCxJQUFJLENBQUVDLENBQUFBLGlCQUFpQkksVUFBUyxHQUFJOztJQUVsQ0EsVUFBVSxDQUFDSixjQUFjLEdBQUcsV0FBVyxHQUFFLElBQUlLO0FBQy9DO0FBQ0EsTUFBTUMsY0FBY0YsVUFBVSxDQUFDSixjQUFjO0FBQzdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ00sTUFBTU8sY0FBYyxDQUFDQyxJQUFJQztJQUM5QixJQUFJLENBQUNILFlBQVlJLEdBQUcsQ0FBQ0YsS0FBSztRQUN4QkYsWUFBWUssR0FBRyxDQUFDSCxJQUFJQztJQUN0QjtJQUNBLE9BQU9ILFlBQVlNLEdBQUcsQ0FBQ0o7QUFDekIsRUFBRSxDQUNGLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vR2xvYmFsVmFsdWUuanM/OTk5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBgR2xvYmFsVmFsdWVgIG1vZHVsZSBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgYSB2YWx1ZSBpcyBjcmVhdGVkIGdsb2JhbGx5LFxuICogZXZlbiB3aGVuIG1vZHVsZXMgYXJlIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIChlLmcuLCBkdWUgdG8gbWl4aW5nIENvbW1vbkpTIGFuZCBFU00gYnVpbGRzKVxuICogb3IgZHVyaW5nIGhvdC1yZWxvYWRpbmcgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGxpa2UgTmV4dC5qcyBvciBSZW1peC5cbiAqXG4gKiBJdCBhY2hpZXZlcyB0aGlzIGJ5IHVzaW5nIGEgdmVyc2lvbmVkIGdsb2JhbCBzdG9yZSwgaWRlbnRpZmllZCBieSBhIHVuaXF1ZSBgU3ltYm9sYCB0aWVkIHRvXG4gKiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBgZWZmZWN0YCBsaWJyYXJ5LiBUaGUgc3RvcmUgaG9sZHMgdmFsdWVzIHRoYXQgYXJlIGtleWVkIGJ5IGFuIGlkZW50aWZpZXIsXG4gKiBhbGxvd2luZyB0aGUgcmV1c2Ugb2YgcHJldmlvdXNseSBjb21wdXRlZCBpbnN0YW5jZXMgYWNyb3NzIGltcG9ydHMgb3IgcmVsb2Fkcy5cbiAqXG4gKiBUaGlzIHBhdHRlcm4gaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBpbiBzY2VuYXJpb3Mgd2hlcmUgZnJlcXVlbnQgcmVsb2FkaW5nIGNhbiBjYXVzZSBzZXJ2aWNlcyBvclxuICogc2luZ2xlLWluc3RhbmNlIG9iamVjdHMgdG8gYmUgcmVjcmVhdGVkIHVubmVjZXNzYXJpbHksIHN1Y2ggYXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIHdpdGggaG90LXJlbG9hZGluZy5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0ICogYXMgdmVyc2lvbiBmcm9tIFwiLi9pbnRlcm5hbC92ZXJzaW9uLmpzXCI7XG5jb25zdCBnbG9iYWxTdG9yZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoYGVmZmVjdC9HbG9iYWxWYWx1ZS9nbG9iYWxTdG9yZUlkLyR7LyojX19QVVJFX18qL3ZlcnNpb24uZ2V0Q3VycmVudFZlcnNpb24oKX1gKTtcbmlmICghKGdsb2JhbFN0b3JlSWQgaW4gZ2xvYmFsVGhpcykpIHtcbiAgO1xuICBnbG9iYWxUaGlzW2dsb2JhbFN0b3JlSWRdID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcbn1cbmNvbnN0IGdsb2JhbFN0b3JlID0gZ2xvYmFsVGhpc1tnbG9iYWxTdG9yZUlkXTtcbi8qKlxuICogUmV0cmlldmVzIG9yIGNvbXB1dGVzIGEgZ2xvYmFsIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gYGlkYC4gSWYgdGhlIHZhbHVlIGZvciB0aGlzIGBpZGBcbiAqIGhhcyBhbHJlYWR5IGJlZW4gY29tcHV0ZWQsIGl0IHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGUgZ2xvYmFsIHN0b3JlLiBJZiBpdCBkb2VzIG5vdCBleGlzdCB5ZXQsXG4gKiB0aGUgcHJvdmlkZWQgYGNvbXB1dGVgIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgdG8gY29tcHV0ZSB0aGUgdmFsdWUsIHN0b3JlIGl0LCBhbmQgdGhlbiByZXR1cm4gaXQuXG4gKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgZXZlbiBpbiBjYXNlcyB3aGVyZSB0aGUgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIChlLmcuLCBpbiBtaXhlZCBlbnZpcm9ubWVudHNcbiAqIGxpa2UgQ29tbW9uSlMgYW5kIEVTTSwgb3IgZHVyaW5nIGhvdC1yZWxvYWRpbmcgaW4gZGV2ZWxvcG1lbnQpLCB0aGUgdmFsdWUgaXMgY29tcHV0ZWQgb25seSBvbmNlIGFuZCByZXVzZWRcbiAqIHRoZXJlYWZ0ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCJlZmZlY3QvR2xvYmFsVmFsdWVcIlxuICpcbiAqIC8vIFRoaXMgY2FjaGUgd2lsbCBwZXJzaXN0IGFzIGxvbmcgYXMgdGhlIG1vZHVsZSBpcyBydW5uaW5nLFxuICogLy8gZXZlbiBpZiByZWxvYWRlZCBvciBpbXBvcnRlZCBlbHNld2hlcmVcbiAqIGNvbnN0IG15Q2FjaGUgPSBnbG9iYWxWYWx1ZShcbiAqICAgU3ltYm9sLmZvcihcIm15Q2FjaGVcIiksXG4gKiAgICgpID0+IG5ldyBXZWFrTWFwPG9iamVjdCwgbnVtYmVyPigpXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdsb2JhbFZhbHVlID0gKGlkLCBjb21wdXRlKSA9PiB7XG4gIGlmICghZ2xvYmFsU3RvcmUuaGFzKGlkKSkge1xuICAgIGdsb2JhbFN0b3JlLnNldChpZCwgY29tcHV0ZSgpKTtcbiAgfVxuICByZXR1cm4gZ2xvYmFsU3RvcmUuZ2V0KGlkKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbG9iYWxWYWx1ZS5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsImdsb2JhbFN0b3JlSWQiLCJTeW1ib2wiLCJmb3IiLCJnZXRDdXJyZW50VmVyc2lvbiIsImdsb2JhbFRoaXMiLCJNYXAiLCJnbG9iYWxTdG9yZSIsImdsb2JhbFZhbHVlIiwiaWQiLCJjb21wdXRlIiwiaGFzIiwic2V0IiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Hash.js":
/*!**********************************************!*\
  !*** ./node_modules/effect/dist/esm/Hash.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   cached: () => (/* binding */ cached),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   optimize: () => (/* binding */ optimize),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   structure: () => (/* binding */ structure),\n/* harmony export */   structureKeys: () => (/* binding */ structureKeys),\n/* harmony export */   symbol: () => (/* binding */ symbol)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/**\n * @since 2.0.0\n */ \n\n\n\n/** @internal */ const randomHashCache = /*#__PURE__*/ (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_0__.globalValue)(/*#__PURE__*/ Symbol.for(\"effect/Hash/randomHashCache\"), ()=>new WeakMap());\n/**\n * @since 2.0.0\n * @category symbols\n */ const symbol = /*#__PURE__*/ Symbol.for(\"effect/Hash\");\n/**\n * @since 2.0.0\n * @category hashing\n */ const hash = (self)=>{\n    if (_Utils_js__WEBPACK_IMPORTED_MODULE_1__.structuralRegionState.enabled === true) {\n        return 0;\n    }\n    switch(typeof self){\n        case \"number\":\n            return number(self);\n        case \"bigint\":\n            return string(self.toString(10));\n        case \"boolean\":\n            return string(String(self));\n        case \"symbol\":\n            return string(String(self));\n        case \"string\":\n            return string(self);\n        case \"undefined\":\n            return string(\"undefined\");\n        case \"function\":\n        case \"object\":\n            {\n                if (self === null) {\n                    return string(\"null\");\n                } else if (self instanceof Date) {\n                    return hash(self.toISOString());\n                } else if (isHash(self)) {\n                    return self[symbol]();\n                } else {\n                    return random(self);\n                }\n            }\n        default:\n            throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);\n    }\n};\n/**\n * @since 2.0.0\n * @category hashing\n */ const random = (self)=>{\n    if (!randomHashCache.has(self)) {\n        randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));\n    }\n    return randomHashCache.get(self);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */ const combine = (b)=>(self)=>self * 53 ^ b;\n/**\n * @since 2.0.0\n * @category hashing\n */ const optimize = (n)=>n & 0xbfffffff | n >>> 1 & 0x40000000;\n/**\n * @since 2.0.0\n * @category guards\n */ const isHash = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(u, symbol);\n/**\n * @since 2.0.0\n * @category hashing\n */ const number = (n)=>{\n    if (n !== n || n === Infinity) {\n        return 0;\n    }\n    let h = n | 0;\n    if (h !== n) {\n        h ^= n * 0xffffffff;\n    }\n    while(n > 0xffffffff){\n        h ^= n /= 0xffffffff;\n    }\n    return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */ const string = (str)=>{\n    let h = 5381, i = str.length;\n    while(i){\n        h = h * 33 ^ str.charCodeAt(--i);\n    }\n    return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */ const structureKeys = (o, keys)=>{\n    let h = 12289;\n    for(let i = 0; i < keys.length; i++){\n        h ^= (0,_Function_js__WEBPACK_IMPORTED_MODULE_3__.pipe)(string(keys[i]), combine(hash(o[keys[i]])));\n    }\n    return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */ const structure = (o)=>structureKeys(o, Object.keys(o));\n/**\n * @since 2.0.0\n * @category hashing\n */ const array = (arr)=>{\n    let h = 6151;\n    for(let i = 0; i < arr.length; i++){\n        h = (0,_Function_js__WEBPACK_IMPORTED_MODULE_3__.pipe)(h, combine(hash(arr[i])));\n    }\n    return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */ const cached = function() {\n    if (arguments.length === 1) {\n        const self = arguments[0];\n        return function(hash) {\n            Object.defineProperty(self, symbol, {\n                value () {\n                    return hash;\n                },\n                enumerable: false\n            });\n            return hash;\n        };\n    }\n    const self = arguments[0];\n    const hash = arguments[1];\n    Object.defineProperty(self, symbol, {\n        value () {\n            return hash;\n        },\n        enumerable: false\n    });\n    return hash;\n}; //# sourceMappingURL=Hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ29DO0FBQ1U7QUFDRjtBQUNNO0FBQ25ELGNBQWMsR0FDZCxNQUFNSSxrQkFBa0IsV0FBVyxHQUFFSCw0REFBV0EsQ0FBRSxXQUFXLEdBQUVJLE9BQU9DLEdBQUcsQ0FBQyxnQ0FBZ0MsSUFBTSxJQUFJQztBQUNwSDs7O0NBR0MsR0FDTSxNQUFNQyxTQUFTLFdBQVcsR0FBRUgsT0FBT0MsR0FBRyxDQUFDLGVBQWU7QUFDN0Q7OztDQUdDLEdBQ00sTUFBTUcsT0FBT0MsQ0FBQUE7SUFDbEIsSUFBSVAsNERBQXFCQSxDQUFDUSxPQUFPLEtBQUssTUFBTTtRQUMxQyxPQUFPO0lBQ1Q7SUFDQSxPQUFRLE9BQU9EO1FBQ2IsS0FBSztZQUNILE9BQU9FLE9BQU9GO1FBQ2hCLEtBQUs7WUFDSCxPQUFPRyxPQUFPSCxLQUFLSSxRQUFRLENBQUM7UUFDOUIsS0FBSztZQUNILE9BQU9ELE9BQU9FLE9BQU9MO1FBQ3ZCLEtBQUs7WUFDSCxPQUFPRyxPQUFPRSxPQUFPTDtRQUN2QixLQUFLO1lBQ0gsT0FBT0csT0FBT0g7UUFDaEIsS0FBSztZQUNILE9BQU9HLE9BQU87UUFDaEIsS0FBSztRQUNMLEtBQUs7WUFDSDtnQkFDRSxJQUFJSCxTQUFTLE1BQU07b0JBQ2pCLE9BQU9HLE9BQU87Z0JBQ2hCLE9BQU8sSUFBSUgsZ0JBQWdCTSxNQUFNO29CQUMvQixPQUFPUCxLQUFLQyxLQUFLTyxXQUFXO2dCQUM5QixPQUFPLElBQUlDLE9BQU9SLE9BQU87b0JBQ3ZCLE9BQU9BLElBQUksQ0FBQ0YsT0FBTztnQkFDckIsT0FBTztvQkFDTCxPQUFPVyxPQUFPVDtnQkFDaEI7WUFDRjtRQUNGO1lBQ0UsTUFBTSxJQUFJVSxNQUFNLENBQUMsc0JBQXNCLEVBQUUsT0FBT1YsS0FBSyx1RUFBdUUsQ0FBQztJQUNqSTtBQUNGLEVBQUU7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ZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9IYXNoLmpzPzI2ODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCIuL0dsb2JhbFZhbHVlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSB9IGZyb20gXCIuL1ByZWRpY2F0ZS5qc1wiO1xuaW1wb3J0IHsgc3RydWN0dXJhbFJlZ2lvblN0YXRlIH0gZnJvbSBcIi4vVXRpbHMuanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHJhbmRvbUhhc2hDYWNoZSA9IC8qI19fUFVSRV9fKi9nbG9iYWxWYWx1ZSggLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvSGFzaC9yYW5kb21IYXNoQ2FjaGVcIiksICgpID0+IG5ldyBXZWFrTWFwKCkpO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9IYXNoXCIpO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoID0gc2VsZiA9PiB7XG4gIGlmIChzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHNlbGYpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gbnVtYmVyKHNlbGYpO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBzdHJpbmcoc2VsZi50b1N0cmluZygxMCkpO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gc3RyaW5nKFN0cmluZyhzZWxmKSk7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIHN0cmluZyhTdHJpbmcoc2VsZikpO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBzdHJpbmcoc2VsZik7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIHN0cmluZyhcInVuZGVmaW5lZFwiKTtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICB7XG4gICAgICAgIGlmIChzZWxmID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZyhcIm51bGxcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gaGFzaChzZWxmLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSGFzaChzZWxmKSkge1xuICAgICAgICAgIHJldHVybiBzZWxmW3N5bWJvbF0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiB1bmhhbmRsZWQgdHlwZW9mICR7dHlwZW9mIHNlbGZ9IC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNgKTtcbiAgfVxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3QgcmFuZG9tID0gc2VsZiA9PiB7XG4gIGlmICghcmFuZG9tSGFzaENhY2hlLmhhcyhzZWxmKSkge1xuICAgIHJhbmRvbUhhc2hDYWNoZS5zZXQoc2VsZiwgbnVtYmVyKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkpO1xuICB9XG4gIHJldHVybiByYW5kb21IYXNoQ2FjaGUuZ2V0KHNlbGYpO1xufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3QgY29tYmluZSA9IGIgPT4gc2VsZiA9PiBzZWxmICogNTMgXiBiO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBvcHRpbWl6ZSA9IG4gPT4gbiAmIDB4YmZmZmZmZmYgfCBuID4+PiAxICYgMHg0MDAwMDAwMDtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0hhc2ggPSB1ID0+IGhhc1Byb3BlcnR5KHUsIHN5bWJvbCk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGhhc2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IG4gPT4ge1xuICBpZiAobiAhPT0gbiB8fCBuID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBoID0gbiB8IDA7XG4gIGlmIChoICE9PSBuKSB7XG4gICAgaCBePSBuICogMHhmZmZmZmZmZjtcbiAgfVxuICB3aGlsZSAobiA+IDB4ZmZmZmZmZmYpIHtcbiAgICBoIF49IG4gLz0gMHhmZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gb3B0aW1pemUoaCk7XG59O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSBzdHIgPT4ge1xuICBsZXQgaCA9IDUzODEsXG4gICAgaSA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChpKSB7XG4gICAgaCA9IGggKiAzMyBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cbiAgcmV0dXJuIG9wdGltaXplKGgpO1xufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3Qgc3RydWN0dXJlS2V5cyA9IChvLCBrZXlzKSA9PiB7XG4gIGxldCBoID0gMTIyODk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGggXj0gcGlwZShzdHJpbmcoa2V5c1tpXSksIGNvbWJpbmUoaGFzaChvW2tleXNbaV1dKSkpO1xuICB9XG4gIHJldHVybiBvcHRpbWl6ZShoKTtcbn07XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGhhc2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cnVjdHVyZSA9IG8gPT4gc3RydWN0dXJlS2V5cyhvLCBPYmplY3Qua2V5cyhvKSk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGhhc2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFycmF5ID0gYXJyID0+IHtcbiAgbGV0IGggPSA2MTUxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGggPSBwaXBlKGgsIGNvbWJpbmUoaGFzaChhcnJbaV0pKSk7XG4gIH1cbiAgcmV0dXJuIG9wdGltaXplKGgpO1xufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgaGFzaGluZ1xuICovXG5leHBvcnQgY29uc3QgY2FjaGVkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHNlbGYgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgc3ltYm9sLCB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSBhcmd1bWVudHNbMF07XG4gIGNvbnN0IGhhc2ggPSBhcmd1bWVudHNbMV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBzeW1ib2wsIHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBoYXNoO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhhc2guanMubWFwIl0sIm5hbWVzIjpbInBpcGUiLCJnbG9iYWxWYWx1ZSIsImhhc1Byb3BlcnR5Iiwic3RydWN0dXJhbFJlZ2lvblN0YXRlIiwicmFuZG9tSGFzaENhY2hlIiwiU3ltYm9sIiwiZm9yIiwiV2Vha01hcCIsInN5bWJvbCIsImhhc2giLCJzZWxmIiwiZW5hYmxlZCIsIm51bWJlciIsInN0cmluZyIsInRvU3RyaW5nIiwiU3RyaW5nIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiaXNIYXNoIiwicmFuZG9tIiwiRXJyb3IiLCJoYXMiLCJzZXQiLCJNYXRoIiwiZmxvb3IiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZ2V0IiwiY29tYmluZSIsImIiLCJvcHRpbWl6ZSIsIm4iLCJ1IiwiSW5maW5pdHkiLCJoIiwic3RyIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJzdHJ1Y3R1cmVLZXlzIiwibyIsImtleXMiLCJzdHJ1Y3R1cmUiLCJPYmplY3QiLCJhcnJheSIsImFyciIsImNhY2hlZCIsImFyZ3VtZW50cyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Inspectable.js":
/*!*****************************************************!*\
  !*** ./node_modules/effect/dist/esm/Inspectable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProto: () => (/* binding */ BaseProto),\n/* harmony export */   Class: () => (/* binding */ Class),\n/* harmony export */   NodeInspectSymbol: () => (/* binding */ NodeInspectSymbol),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   isRedactable: () => (/* binding */ isRedactable),\n/* harmony export */   redact: () => (/* binding */ redact),\n/* harmony export */   stringifyCircular: () => (/* binding */ stringifyCircular),\n/* harmony export */   symbolRedactable: () => (/* binding */ symbolRedactable),\n/* harmony export */   toJSON: () => (/* binding */ toJSON),\n/* harmony export */   toStringUnknown: () => (/* binding */ toStringUnknown),\n/* harmony export */   withRedactableContext: () => (/* binding */ withRedactableContext)\n/* harmony export */ });\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/**\n * @since 2.0.0\n */ \n\n/**\n * @since 2.0.0\n * @category symbols\n */ const NodeInspectSymbol = /*#__PURE__*/ Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * @since 2.0.0\n */ const toJSON = (x)=>{\n    try {\n        if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(x, \"toJSON\") && (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(x[\"toJSON\"]) && x[\"toJSON\"].length === 0) {\n            return x.toJSON();\n        } else if (Array.isArray(x)) {\n            return x.map(toJSON);\n        }\n    } catch (_) {\n        return {};\n    }\n    return redact(x);\n};\n/**\n * @since 2.0.0\n */ const format = (x)=>JSON.stringify(x, null, 2);\n/**\n * @since 2.0.0\n */ const BaseProto = {\n    toJSON () {\n        return toJSON(this);\n    },\n    [NodeInspectSymbol] () {\n        return this.toJSON();\n    },\n    toString () {\n        return format(this.toJSON());\n    }\n};\n/**\n * @since 2.0.0\n */ class Class {\n    /**\n   * @since 2.0.0\n   */ [NodeInspectSymbol]() {\n        return this.toJSON();\n    }\n    /**\n   * @since 2.0.0\n   */ toString() {\n        return format(this.toJSON());\n    }\n}\n/**\n * @since 2.0.0\n */ const toStringUnknown = (u, whitespace = 2)=>{\n    if (typeof u === \"string\") {\n        return u;\n    }\n    try {\n        return typeof u === \"object\" ? stringifyCircular(u, whitespace) : String(u);\n    } catch (_) {\n        return String(u);\n    }\n};\n/**\n * @since 2.0.0\n */ const stringifyCircular = (obj, whitespace)=>{\n    let cache = [];\n    const retVal = JSON.stringify(obj, (_key, value)=>typeof value === \"object\" && value !== null ? cache.includes(value) ? undefined // circular reference\n         : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);\n    cache = undefined;\n    return retVal;\n};\n/**\n * @since 3.10.0\n * @category redactable\n */ const symbolRedactable = /*#__PURE__*/ Symbol.for(\"effect/Inspectable/Redactable\");\n/**\n * @since 3.10.0\n * @category redactable\n */ const isRedactable = (u)=>typeof u === \"object\" && u !== null && symbolRedactable in u;\nconst redactableState = /*#__PURE__*/ (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_1__.globalValue)(\"effect/Inspectable/redactableState\", ()=>({\n        fiberRefs: undefined\n    }));\n/**\n * @since 3.10.0\n * @category redactable\n */ const withRedactableContext = (context, f)=>{\n    const prev = redactableState.fiberRefs;\n    redactableState.fiberRefs = context;\n    try {\n        return f();\n    } finally{\n        redactableState.fiberRefs = prev;\n    }\n};\n/**\n * @since 3.10.0\n * @category redactable\n */ const redact = (u)=>{\n    if (isRedactable(u) && redactableState.fiberRefs !== undefined) {\n        return u[symbolRedactable](redactableState.fiberRefs);\n    }\n    return u;\n}; //# sourceMappingURL=Inspectable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0luc3BlY3RhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUM4QztBQUNVO0FBQ3pEOzs7Q0FHQyxHQUNNLE1BQU1HLG9CQUFvQixXQUFXLEdBQUVDLE9BQU9DLEdBQUcsQ0FBQyw4QkFBOEI7QUFDdkY7O0NBRUMsR0FDTSxNQUFNQyxTQUFTQyxDQUFBQTtJQUNwQixJQUFJO1FBQ0YsSUFBSU4sMERBQVdBLENBQUNNLEdBQUcsYUFBYUwseURBQVVBLENBQUNLLENBQUMsQ0FBQyxTQUFTLEtBQUtBLENBQUMsQ0FBQyxTQUFTLENBQUNDLE1BQU0sS0FBSyxHQUFHO1lBQ25GLE9BQU9ELEVBQUVELE1BQU07UUFDakIsT0FBTyxJQUFJRyxNQUFNQyxPQUFPLENBQUNILElBQUk7WUFDM0IsT0FBT0EsRUFBRUksR0FBRyxDQUFDTDtRQUNmO0lBQ0YsRUFBRSxPQUFPTSxHQUFHO1FBQ1YsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxPQUFPQyxPQUFPTjtBQUNoQixFQUFFO0FBQ0Y7O0NBRUMsR0FDTSxNQUFNTyxTQUFTUCxDQUFBQSxJQUFLUSxLQUFLQyxTQUFTLENBQUNULEdBQUcsTUFBTSxHQUFHO0FBQ3REOztDQUVDLEdBQ00sTUFBTVUsWUFBWTtJQUN2Qlg7UUFDRSxPQUFPQSxPQUFPLElBQUk7SUFDcEI7SUFDQSxDQUFDSCxrQkFBa0I7UUFDakIsT0FBTyxJQUFJLENBQUNHLE1BQU07SUFDcEI7SUFDQVk7UUFDRSxPQUFPSixPQUFPLElBQUksQ0FBQ1IsTUFBTTtJQUMzQjtBQUNGLEVBQUU7QUFDRjs7Q0FFQyxHQUNNLE1BQU1hO0lBQ1g7O0dBRUMsR0FDRCxDQUFDaEIsa0JBQWtCLEdBQUc7UUFDcEIsT0FBTyxJQUFJLENBQUNHLE1BQU07SUFDcEI7SUFDQTs7R0FFQyxHQUNEWSxXQUFXO1FBQ1QsT0FBT0osT0FBTyxJQUFJLENBQUNSLE1BQU07SUFDM0I7QUFDRjtBQUNBOztDQUVDLEdBQ00sTUFBTWMsa0JBQWtCLENBQUNDLEdBQUdDLGFBQWEsQ0FBQztJQUMvQyxJQUFJLE9BQU9ELE1BQU0sVUFBVTtRQUN6QixPQUFPQTtJQUNUO0lBQ0EsSUFBSTtRQUNGLE9BQU8sT0FBT0EsTUFBTSxXQUFXRSxrQkFBa0JGLEdBQUdDLGNBQWNFLE9BQU9IO0lBQzNFLEVBQUUsT0FBT1QsR0FBRztRQUNWLE9BQU9ZLE9BQU9IO0lBQ2hCO0FBQ0YsRUFBRTtBQUNGOztDQUVDLEdBQ00sTUFBTUUsb0JBQW9CLENBQUNFLEtBQUtIO0lBQ3JDLElBQUlJLFFBQVEsRUFBRTtJQUNkLE1BQU1DLFNBQVNaLEtBQUtDLFNBQVMsQ0FBQ1MsS0FBSyxDQUFDRyxNQUFNQyxRQUFVLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxPQUFPSCxNQUFNSSxRQUFRLENBQUNELFNBQVNFLFVBQVUscUJBQXFCO1dBQ3ZKTCxNQUFNTSxJQUFJLENBQUNILFVBQVdJLENBQUFBLGdCQUFnQkMsU0FBUyxLQUFLSCxhQUFhSSxhQUFhTixTQUFTQSxLQUFLLENBQUNPLGlCQUFpQixDQUFDSCxnQkFBZ0JDLFNBQVMsSUFBSUwsS0FBSSxJQUFLQSxPQUFPUDtJQUM5SkksUUFBUUs7SUFDUixPQUFPSjtBQUNULEVBQUU7QUFDRjs7O0NBR0MsR0FDTSxNQUFNUyxtQkFBbUIsV0FBVyxHQUFFaEMsT0FBT0MsR0FBRyxDQUFDLGlDQUFpQztBQUN6Rjs7O0NBR0MsR0FDTSxNQUFNOEIsZUFBZWQsQ0FBQUEsSUFBSyxPQUFPQSxNQUFNLFlBQVlBLE1BQU0sUUFBUWUsb0JBQW9CZixFQUFFO0FBQzlGLE1BQU1ZLGtCQUFrQixXQUFXLEdBQUVqQyw0REFBV0EsQ0FBQyxzQ0FBc0MsSUFBTztRQUM1RmtDLFdBQVdIO0lBQ2I7QUFDQTs7O0NBR0MsR0FDTSxNQUFNTSx3QkFBd0IsQ0FBQ0MsU0FBU0M7SUFDN0MsTUFBTUMsT0FBT1AsZ0JBQWdCQyxTQUFTO0lBQ3RDRCxnQkFBZ0JDLFNBQVMsR0FBR0k7SUFDNUIsSUFBSTtRQUNGLE9BQU9DO0lBQ1QsU0FBVTtRQUNSTixnQkFBZ0JDLFNBQVMsR0FBR007SUFDOUI7QUFDRixFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sTUFBTTNCLFNBQVNRLENBQUFBO0lBQ3BCLElBQUljLGFBQWFkLE1BQU1ZLGdCQUFnQkMsU0FBUyxLQUFLSCxXQUFXO1FBQzlELE9BQU9WLENBQUMsQ0FBQ2UsaUJBQWlCLENBQUNILGdCQUFnQkMsU0FBUztJQUN0RDtJQUNBLE9BQU9iO0FBQ1QsRUFBRSxDQUNGLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vSW5zcGVjdGFibGUuanM/YmY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCIuL0dsb2JhbFZhbHVlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNGdW5jdGlvbiB9IGZyb20gXCIuL1ByZWRpY2F0ZS5qc1wiO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKi9cbmV4cG9ydCBjb25zdCBOb2RlSW5zcGVjdFN5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdG9KU09OID0geCA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKGhhc1Byb3BlcnR5KHgsIFwidG9KU09OXCIpICYmIGlzRnVuY3Rpb24oeFtcInRvSlNPTlwiXSkgJiYgeFtcInRvSlNPTlwiXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB4LnRvSlNPTigpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgcmV0dXJuIHgubWFwKHRvSlNPTik7XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiByZWRhY3QoeCk7XG59O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IHggPT4gSlNPTi5zdHJpbmdpZnkoeCwgbnVsbCwgMik7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgQmFzZVByb3RvID0ge1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRvSlNPTih0aGlzKTtcbiAgfSxcbiAgW05vZGVJbnNwZWN0U3ltYm9sXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfVxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGFzcyB7XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfVxufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHRvU3RyaW5nVW5rbm93biA9ICh1LCB3aGl0ZXNwYWNlID0gMikgPT4ge1xuICBpZiAodHlwZW9mIHUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgdSA9PT0gXCJvYmplY3RcIiA/IHN0cmluZ2lmeUNpcmN1bGFyKHUsIHdoaXRlc3BhY2UpIDogU3RyaW5nKHUpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIFN0cmluZyh1KTtcbiAgfVxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdpZnlDaXJjdWxhciA9IChvYmosIHdoaXRlc3BhY2UpID0+IHtcbiAgbGV0IGNhY2hlID0gW107XG4gIGNvbnN0IHJldFZhbCA9IEpTT04uc3RyaW5naWZ5KG9iaiwgKF9rZXksIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgPyBjYWNoZS5pbmNsdWRlcyh2YWx1ZSkgPyB1bmRlZmluZWQgLy8gY2lyY3VsYXIgcmVmZXJlbmNlXG4gIDogY2FjaGUucHVzaCh2YWx1ZSkgJiYgKHJlZGFjdGFibGVTdGF0ZS5maWJlclJlZnMgIT09IHVuZGVmaW5lZCAmJiBpc1JlZGFjdGFibGUodmFsdWUpID8gdmFsdWVbc3ltYm9sUmVkYWN0YWJsZV0ocmVkYWN0YWJsZVN0YXRlLmZpYmVyUmVmcykgOiB2YWx1ZSkgOiB2YWx1ZSwgd2hpdGVzcGFjZSk7XG4gIGNhY2hlID0gdW5kZWZpbmVkO1xuICByZXR1cm4gcmV0VmFsO1xufTtcbi8qKlxuICogQHNpbmNlIDMuMTAuMFxuICogQGNhdGVnb3J5IHJlZGFjdGFibGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN5bWJvbFJlZGFjdGFibGUgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9JbnNwZWN0YWJsZS9SZWRhY3RhYmxlXCIpO1xuLyoqXG4gKiBAc2luY2UgMy4xMC4wXG4gKiBAY2F0ZWdvcnkgcmVkYWN0YWJsZVxuICovXG5leHBvcnQgY29uc3QgaXNSZWRhY3RhYmxlID0gdSA9PiB0eXBlb2YgdSA9PT0gXCJvYmplY3RcIiAmJiB1ICE9PSBudWxsICYmIHN5bWJvbFJlZGFjdGFibGUgaW4gdTtcbmNvbnN0IHJlZGFjdGFibGVTdGF0ZSA9IC8qI19fUFVSRV9fKi9nbG9iYWxWYWx1ZShcImVmZmVjdC9JbnNwZWN0YWJsZS9yZWRhY3RhYmxlU3RhdGVcIiwgKCkgPT4gKHtcbiAgZmliZXJSZWZzOiB1bmRlZmluZWRcbn0pKTtcbi8qKlxuICogQHNpbmNlIDMuMTAuMFxuICogQGNhdGVnb3J5IHJlZGFjdGFibGVcbiAqL1xuZXhwb3J0IGNvbnN0IHdpdGhSZWRhY3RhYmxlQ29udGV4dCA9IChjb250ZXh0LCBmKSA9PiB7XG4gIGNvbnN0IHByZXYgPSByZWRhY3RhYmxlU3RhdGUuZmliZXJSZWZzO1xuICByZWRhY3RhYmxlU3RhdGUuZmliZXJSZWZzID0gY29udGV4dDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZigpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlZGFjdGFibGVTdGF0ZS5maWJlclJlZnMgPSBwcmV2O1xuICB9XG59O1xuLyoqXG4gKiBAc2luY2UgMy4xMC4wXG4gKiBAY2F0ZWdvcnkgcmVkYWN0YWJsZVxuICovXG5leHBvcnQgY29uc3QgcmVkYWN0ID0gdSA9PiB7XG4gIGlmIChpc1JlZGFjdGFibGUodSkgJiYgcmVkYWN0YWJsZVN0YXRlLmZpYmVyUmVmcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVbc3ltYm9sUmVkYWN0YWJsZV0ocmVkYWN0YWJsZVN0YXRlLmZpYmVyUmVmcyk7XG4gIH1cbiAgcmV0dXJuIHU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5zcGVjdGFibGUuanMubWFwIl0sIm5hbWVzIjpbImdsb2JhbFZhbHVlIiwiaGFzUHJvcGVydHkiLCJpc0Z1bmN0aW9uIiwiTm9kZUluc3BlY3RTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJ0b0pTT04iLCJ4IiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiXyIsInJlZGFjdCIsImZvcm1hdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJCYXNlUHJvdG8iLCJ0b1N0cmluZyIsIkNsYXNzIiwidG9TdHJpbmdVbmtub3duIiwidSIsIndoaXRlc3BhY2UiLCJzdHJpbmdpZnlDaXJjdWxhciIsIlN0cmluZyIsIm9iaiIsImNhY2hlIiwicmV0VmFsIiwiX2tleSIsInZhbHVlIiwiaW5jbHVkZXMiLCJ1bmRlZmluZWQiLCJwdXNoIiwicmVkYWN0YWJsZVN0YXRlIiwiZmliZXJSZWZzIiwiaXNSZWRhY3RhYmxlIiwic3ltYm9sUmVkYWN0YWJsZSIsIndpdGhSZWRhY3RhYmxlQ29udGV4dCIsImNvbnRleHQiLCJmIiwicHJldiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Inspectable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Iterable.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Iterable.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendAll: () => (/* binding */ appendAll),\n/* harmony export */   cartesian: () => (/* binding */ cartesian),\n/* harmony export */   cartesianWith: () => (/* binding */ cartesianWith),\n/* harmony export */   chunksOf: () => (/* binding */ chunksOf),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   containsWith: () => (/* binding */ containsWith),\n/* harmony export */   dedupeAdjacent: () => (/* binding */ dedupeAdjacent),\n/* harmony export */   dedupeAdjacentWith: () => (/* binding */ dedupeAdjacentWith),\n/* harmony export */   drop: () => (/* binding */ drop),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   filterMapWhile: () => (/* binding */ filterMapWhile),\n/* harmony export */   findFirst: () => (/* binding */ findFirst),\n/* harmony export */   findLast: () => (/* binding */ findLast),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatMapNullable: () => (/* binding */ flatMapNullable),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   fromRecord: () => (/* binding */ fromRecord),\n/* harmony export */   getLefts: () => (/* binding */ getLefts),\n/* harmony export */   getRights: () => (/* binding */ getRights),\n/* harmony export */   getSomes: () => (/* binding */ getSomes),\n/* harmony export */   group: () => (/* binding */ group),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   groupWith: () => (/* binding */ groupWith),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   intersperse: () => (/* binding */ intersperse),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   makeBy: () => (/* binding */ makeBy),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   of: () => (/* binding */ of),\n/* harmony export */   prepend: () => (/* binding */ prepend),\n/* harmony export */   prependAll: () => (/* binding */ prependAll),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   replicate: () => (/* binding */ replicate),\n/* harmony export */   scan: () => (/* binding */ scan),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   take: () => (/* binding */ take),\n/* harmony export */   takeWhile: () => (/* binding */ takeWhile),\n/* harmony export */   unfold: () => (/* binding */ unfold),\n/* harmony export */   unsafeHead: () => (/* binding */ unsafeHead),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _Option_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Option.js */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Tuple_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tuple.js */ \"(ssr)/./node_modules/effect/dist/esm/Tuple.js\");\n/**\n * This module provides utility functions for working with Iterables in TypeScript.\n *\n * @since 2.0.0\n */ \n\n\n\n\n\n/**\n * Return a `Iterable` with element `i` initialized with `f(i)`.\n *\n * If the `length` is not specified, the `Iterable` will be infinite.\n *\n * **Note**. `length` is normalized to an integer >= 1.\n *\n * @example\n * ```ts\n * import { makeBy } from \"effect/Iterable\"\n *\n * assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const makeBy = (f, options)=>{\n    const max = options?.length !== undefined ? Math.max(1, Math.floor(options.length)) : Infinity;\n    return {\n        [Symbol.iterator] () {\n            let i = 0;\n            return {\n                next () {\n                    if (i < max) {\n                        return {\n                            value: f(i++),\n                            done: false\n                        };\n                    }\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n            };\n        }\n    };\n};\n/**\n * Return a `Iterable` containing a range of integers, including both endpoints.\n *\n * If `end` is omitted, the range will not have an upper bound.\n *\n * @example\n * ```ts\n * import { range } from \"effect/Iterable\"\n *\n * assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const range = (start, end)=>{\n    if (end === undefined) {\n        return makeBy((i)=>start + i);\n    }\n    return makeBy((i)=>start + i, {\n        length: start <= end ? end - start + 1 : 1\n    });\n};\n/**\n * Return a `Iterable` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * ```ts\n * import { replicate } from \"effect/Iterable\"\n *\n * assert.deepStrictEqual(Array.from(replicate(\"a\", 3)), [\"a\", \"a\", \"a\"])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const replicate = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (a, n)=>makeBy(()=>a, {\n        length: n\n    }));\n/**\n * Takes a record and returns an Iterable of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * ```ts\n * import { fromRecord } from \"effect/Iterable\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(Array.from(fromRecord(x)), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const fromRecord = (self)=>({\n        *[Symbol.iterator] () {\n            for(const key in self){\n                if (Object.prototype.hasOwnProperty.call(self, key)) {\n                    yield [\n                        key,\n                        self[key]\n                    ];\n                }\n            }\n        }\n    });\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `Iterable`.\n *\n * @category concatenating\n * @since 2.0.0\n */ const prepend = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, head)=>prependAll(self, [\n        head\n    ]));\n/**\n * Prepends the specified prefix iterable to the beginning of the specified iterable.\n *\n * @example\n * ```ts\n * import { Iterable } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.from(Iterable.prependAll([1, 2], [\"a\", \"b\"])),\n *   [\"a\", \"b\", 1, 2]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */ const prependAll = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>appendAll(that, self));\n/**\n * Append an element to the end of an `Iterable`, creating a new `Iterable`.\n *\n * @category concatenating\n * @since 2.0.0\n */ const append = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, last)=>appendAll(self, [\n        last\n    ]));\n/**\n * Concatenates two iterables, combining their elements.\n *\n * @category concatenating\n * @since 2.0.0\n */ const appendAll = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>({\n        [Symbol.iterator] () {\n            const iterA = self[Symbol.iterator]();\n            let doneA = false;\n            let iterB;\n            return {\n                next () {\n                    if (!doneA) {\n                        const r = iterA.next();\n                        if (r.done) {\n                            doneA = true;\n                            iterB = that[Symbol.iterator]();\n                            return iterB.next();\n                        }\n                        return r;\n                    }\n                    return iterB.next();\n                }\n            };\n        }\n    }));\n/**\n * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 2.0.0\n */ const scan = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, b, f)=>({\n        [Symbol.iterator] () {\n            let acc = b;\n            let iterator;\n            function next() {\n                if (iterator === undefined) {\n                    iterator = self[Symbol.iterator]();\n                    return {\n                        done: false,\n                        value: acc\n                    };\n                }\n                const result = iterator.next();\n                if (result.done) {\n                    return result;\n                }\n                acc = f(acc, result.value);\n                return {\n                    done: false,\n                    value: acc\n                };\n            }\n            return {\n                next\n            };\n        }\n    }));\n/**\n * Determine if an `Iterable` is empty\n *\n * @example\n * ```ts\n * import { isEmpty } from \"effect/Iterable\"\n *\n * assert.deepStrictEqual(isEmpty([]), true);\n * assert.deepStrictEqual(isEmpty([1, 2, 3]), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isEmpty = (self)=>{\n    const iterator = self[Symbol.iterator]();\n    return iterator.next().done === true;\n};\n/**\n * Return the number of elements in a `Iterable`.\n *\n * @category getters\n * @since 2.0.0\n */ const size = (self)=>{\n    const iterator = self[Symbol.iterator]();\n    let count = 0;\n    while(!iterator.next().done){\n        count++;\n    }\n    return count;\n};\n/**\n * Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */ const head = (self)=>{\n    const iterator = self[Symbol.iterator]();\n    const result = iterator.next();\n    return result.done ? _Option_js__WEBPACK_IMPORTED_MODULE_1__.none() : _Option_js__WEBPACK_IMPORTED_MODULE_1__.some(result.value);\n};\n/**\n * Get the first element of a `Iterable`, or throw an error if the `Iterable` is empty.\n *\n * @category getters\n * @since 3.3.0\n */ const unsafeHead = (self)=>{\n    const iterator = self[Symbol.iterator]();\n    const result = iterator.next();\n    if (result.done) throw new Error(\"unsafeHead: empty iterable\");\n    return result.value;\n};\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */ const take = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>({\n        [Symbol.iterator] () {\n            let i = 0;\n            const iterator = self[Symbol.iterator]();\n            return {\n                next () {\n                    if (i < n) {\n                        i++;\n                        return iterator.next();\n                    }\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n            };\n        }\n    }));\n/**\n * Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.\n *\n * @category getters\n * @since 2.0.0\n */ const takeWhile = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let i = 0;\n            return {\n                next () {\n                    const result = iterator.next();\n                    if (result.done || !predicate(result.value, i++)) {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                    return result;\n                }\n            };\n        }\n    }));\n/**\n * Drop a max number of elements from the start of an `Iterable`\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */ const drop = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let i = 0;\n            return {\n                next () {\n                    while(i < n){\n                        const result = iterator.next();\n                        if (result.done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        }\n                        i++;\n                    }\n                    return iterator.next();\n                }\n            };\n        }\n    }));\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */ const findFirst = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    let i = 0;\n    for (const a of self){\n        const o = f(a, i);\n        if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(o)) {\n            if (o) {\n                return _Option_js__WEBPACK_IMPORTED_MODULE_1__.some(a);\n            }\n        } else {\n            if (_Option_js__WEBPACK_IMPORTED_MODULE_1__.isSome(o)) {\n                return o;\n            }\n        }\n        i++;\n    }\n    return _Option_js__WEBPACK_IMPORTED_MODULE_1__.none();\n});\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */ const findLast = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    let i = 0;\n    let last = _Option_js__WEBPACK_IMPORTED_MODULE_1__.none();\n    for (const a of self){\n        const o = f(a, i);\n        if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(o)) {\n            if (o) {\n                last = _Option_js__WEBPACK_IMPORTED_MODULE_1__.some(a);\n            }\n        } else {\n            if (_Option_js__WEBPACK_IMPORTED_MODULE_1__.isSome(o)) {\n                last = o;\n            }\n        }\n        i++;\n    }\n    return last;\n});\n/**\n * Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.\n *\n * @category zipping\n * @since 2.0.0\n */ const zip = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>zipWith(self, that, _Tuple_js__WEBPACK_IMPORTED_MODULE_3__.make));\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @category zipping\n * @since 2.0.0\n */ const zipWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, f)=>({\n        [Symbol.iterator] () {\n            const selfIterator = self[Symbol.iterator]();\n            const thatIterator = that[Symbol.iterator]();\n            return {\n                next () {\n                    const selfResult = selfIterator.next();\n                    const thatResult = thatIterator.next();\n                    if (selfResult.done || thatResult.done) {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                    return {\n                        done: false,\n                        value: f(selfResult.value, thatResult.value)\n                    };\n                }\n            };\n        }\n    }));\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * @since 2.0.0\n */ const intersperse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, middle)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let next = iterator.next();\n            let emitted = false;\n            return {\n                next () {\n                    if (next.done) {\n                        return next;\n                    } else if (emitted) {\n                        emitted = false;\n                        return {\n                            done: false,\n                            value: middle\n                        };\n                    }\n                    emitted = true;\n                    const result = next;\n                    next = iterator.next();\n                    return result;\n                }\n            };\n        }\n    }));\n/**\n * Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */ const containsWith = (isEquivalent)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, a)=>{\n        for (const i of self){\n            if (isEquivalent(a, i)) {\n                return true;\n            }\n        }\n        return false;\n    });\nconst _equivalence = /*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_4__.equivalence();\n/**\n * Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */ const contains = /*#__PURE__*/ containsWith(_equivalence);\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`.\n *\n * @category splitting\n * @since 2.0.0\n */ const chunksOf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>{\n    const safeN = Math.max(1, Math.floor(n));\n    return {\n        [Symbol.iterator] () {\n            let iterator = self[Symbol.iterator]();\n            return {\n                next () {\n                    if (iterator === undefined) {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                    const chunk = [];\n                    for(let i = 0; i < safeN; i++){\n                        const result = iterator.next();\n                        if (result.done) {\n                            iterator = undefined;\n                            return chunk.length === 0 ? {\n                                done: true,\n                                value: undefined\n                            } : {\n                                done: false,\n                                value: chunk\n                            };\n                        }\n                        chunk.push(result.value);\n                    }\n                    return {\n                        done: false,\n                        value: chunk\n                    };\n                }\n            };\n        }\n    };\n});\n/**\n * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * @category grouping\n * @since 2.0.0\n */ const groupWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, isEquivalent)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let nextResult;\n            return {\n                next () {\n                    let result;\n                    if (nextResult !== undefined) {\n                        if (nextResult.done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        }\n                        result = nextResult;\n                        nextResult = undefined;\n                    } else {\n                        result = iterator.next();\n                        if (result.done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        }\n                    }\n                    const chunk = [\n                        result.value\n                    ];\n                    while(true){\n                        const next = iterator.next();\n                        if (next.done || !isEquivalent(result.value, next.value)) {\n                            nextResult = next;\n                            return {\n                                done: false,\n                                value: chunk\n                            };\n                        }\n                        chunk.push(next.value);\n                    }\n                }\n            };\n        }\n    }));\n/**\n * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 2.0.0\n */ const group = /*#__PURE__*/ groupWith(/*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_4__.equivalence());\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 2.0.0\n */ const groupBy = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = {};\n    for (const a of self){\n        const k = f(a);\n        if (Object.prototype.hasOwnProperty.call(out, k)) {\n            out[k].push(a);\n        } else {\n            out[k] = [\n                a\n            ];\n        }\n    }\n    return out;\n});\nconst constEmpty = {\n    [Symbol.iterator] () {\n        return constEmptyIterator;\n    }\n};\nconst constEmptyIterator = {\n    next () {\n        return {\n            done: true,\n            value: undefined\n        };\n    }\n};\n/**\n * @category constructors\n * @since 2.0.0\n */ const empty = ()=>constEmpty;\n/**\n * Constructs a new `Iterable<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */ const of = (a)=>[\n        a\n    ];\n/**\n * @category mapping\n * @since 2.0.0\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let i = 0;\n            return {\n                next () {\n                    const result = iterator.next();\n                    if (result.done) {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                    return {\n                        done: false,\n                        value: f(result.value, i++)\n                    };\n                }\n            };\n        }\n    }));\n/**\n * Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>flatten(map(self, f)));\n/**\n * Flattens an Iterable of Iterables into a single Iterable\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatten = (self)=>({\n        [Symbol.iterator] () {\n            const outerIterator = self[Symbol.iterator]();\n            let innerIterator;\n            function next() {\n                if (innerIterator === undefined) {\n                    const next = outerIterator.next();\n                    if (next.done) {\n                        return next;\n                    }\n                    innerIterator = next.value[Symbol.iterator]();\n                }\n                const result = innerIterator.next();\n                if (result.done) {\n                    innerIterator = undefined;\n                    return next();\n                }\n                return result;\n            }\n            return {\n                next\n            };\n        }\n    });\n/**\n * @category filtering\n * @since 2.0.0\n */ const filterMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let i = 0;\n            return {\n                next () {\n                    let result = iterator.next();\n                    while(!result.done){\n                        const b = f(result.value, i++);\n                        if (_Option_js__WEBPACK_IMPORTED_MODULE_1__.isSome(b)) {\n                            return {\n                                done: false,\n                                value: b.value\n                            };\n                        }\n                        result = iterator.next();\n                    }\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n            };\n        }\n    }));\n/**\n * Transforms all elements of the `Iterable` for as long as the specified function returns some value\n *\n * @category filtering\n * @since 2.0.0\n */ const filterMapWhile = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let i = 0;\n            return {\n                next () {\n                    const result = iterator.next();\n                    if (result.done) {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                    const b = f(result.value, i++);\n                    if (_Option_js__WEBPACK_IMPORTED_MODULE_1__.isSome(b)) {\n                        return {\n                            done: false,\n                            value: b.value\n                        };\n                    }\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n            };\n        }\n    }));\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s.\n *\n * @example\n * ```ts\n * import { Iterable, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),\n *   [1, 2]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getSomes = /*#__PURE__*/ filterMap(_Function_js__WEBPACK_IMPORTED_MODULE_0__.identity);\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s.\n *\n * @example\n * ```ts\n * import { Iterable, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.from(Iterable.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n *   [\"err\"]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getLefts = (self)=>filterMap(self, _Either_js__WEBPACK_IMPORTED_MODULE_5__.getLeft);\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s.\n *\n * @example\n * ```ts\n * import { Iterable, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Array.from(Iterable.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n *   [1, 2]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getRights = (self)=>filterMap(self, _Either_js__WEBPACK_IMPORTED_MODULE_5__.getRight);\n/**\n * @category filtering\n * @since 2.0.0\n */ const filter = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let i = 0;\n            return {\n                next () {\n                    let result = iterator.next();\n                    while(!result.done){\n                        if (predicate(result.value, i++)) {\n                            return {\n                                done: false,\n                                value: result.value\n                            };\n                        }\n                        result = iterator.next();\n                    }\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n            };\n        }\n    }));\n/**\n * @category sequencing\n * @since 2.0.0\n */ const flatMapNullable = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>filterMap(self, (a)=>{\n        const b = f(a);\n        return b == null ? _Option_js__WEBPACK_IMPORTED_MODULE_1__.none() : _Option_js__WEBPACK_IMPORTED_MODULE_1__.some(b);\n    }));\n/**\n * Check if a predicate holds true for some `Iterable` element.\n *\n * @category elements\n * @since 2.0.0\n */ const some = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    let i = 0;\n    for (const a of self){\n        if (predicate(a, i++)) {\n            return true;\n        }\n    }\n    return false;\n});\n/**\n * @category constructors\n * @since 2.0.0\n */ const unfold = (b, f)=>({\n        [Symbol.iterator] () {\n            let next = b;\n            return {\n                next () {\n                    const o = f(next);\n                    if (_Option_js__WEBPACK_IMPORTED_MODULE_1__.isNone(o)) {\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                    const [a, b] = o.value;\n                    next = b;\n                    return {\n                        done: false,\n                        value: a\n                    };\n                }\n            };\n        }\n    });\n/**\n * Iterate over the `Iterable` applying `f`.\n *\n * @since 2.0.0\n */ const forEach = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    let i = 0;\n    for (const a of self){\n        f(a, i++);\n    }\n});\n/**\n * @category folding\n * @since 2.0.0\n */ const reduce = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, b, f)=>{\n    if (Array.isArray(self)) {\n        return self.reduce(f, b);\n    }\n    let i = 0;\n    let result = b;\n    for (const n of self){\n        result = f(result, n, i++);\n    }\n    return result;\n});\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * @since 2.0.0\n */ const dedupeAdjacentWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, isEquivalent)=>({\n        [Symbol.iterator] () {\n            const iterator = self[Symbol.iterator]();\n            let first = true;\n            let last;\n            function next() {\n                const result = iterator.next();\n                if (result.done) {\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n                if (first) {\n                    first = false;\n                    last = result.value;\n                    return result;\n                }\n                const current = result.value;\n                if (isEquivalent(last, current)) {\n                    return next();\n                }\n                last = current;\n                return result;\n            }\n            return {\n                next\n            };\n        }\n    }));\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n */ const dedupeAdjacent = /*#__PURE__*/ dedupeAdjacentWith(/*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_4__.equivalence());\n/**\n * Zips this Iterable crosswise with the specified Iterable using the specified combiner.\n *\n * @since 2.0.0\n * @category elements\n */ const cartesianWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, f)=>flatMap(self, (a)=>map(that, (b)=>f(a, b))));\n/**\n * Zips this Iterable crosswise with the specified Iterable.\n *\n * @since 2.0.0\n * @category elements\n */ const cartesian = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>cartesianWith(self, that, (a, b)=>[\n            a,\n            b\n        ])); //# sourceMappingURL=Iterable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL0l0ZXJhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNnQztBQUNHO0FBQ1c7QUFDZDtBQUNVO0FBQ1A7QUFDcEM7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNTyxTQUFTLENBQUNDLEdBQUdDO0lBQ3hCLE1BQU1DLE1BQU1ELFNBQVNFLFdBQVdDLFlBQVlDLEtBQUtILEdBQUcsQ0FBQyxHQUFHRyxLQUFLQyxLQUFLLENBQUNMLFFBQVFFLE1BQU0sS0FBS0k7SUFDdEYsT0FBTztRQUNMLENBQUNDLE9BQU9DLFFBQVEsQ0FBQztZQUNmLElBQUlDLElBQUk7WUFDUixPQUFPO2dCQUNMQztvQkFDRSxJQUFJRCxJQUFJUixLQUFLO3dCQUNYLE9BQU87NEJBQ0xVLE9BQU9aLEVBQUVVOzRCQUNURyxNQUFNO3dCQUNSO29CQUNGO29CQUNBLE9BQU87d0JBQ0xBLE1BQU07d0JBQ05ELE9BQU9SO29CQUNUO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YsRUFBRTtBQUNGOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTVUsUUFBUSxDQUFDQyxPQUFPQztJQUMzQixJQUFJQSxRQUFRWixXQUFXO1FBQ3JCLE9BQU9MLE9BQU9XLENBQUFBLElBQUtLLFFBQVFMO0lBQzdCO0lBQ0EsT0FBT1gsT0FBT1csQ0FBQUEsSUFBS0ssUUFBUUwsR0FBRztRQUM1QlAsUUFBUVksU0FBU0MsTUFBTUEsTUFBTUQsUUFBUSxJQUFJO0lBQzNDO0FBQ0YsRUFBRTtBQUNGOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTUUsWUFBWSxXQUFXLEdBQUV2QixrREFBSUEsQ0FBQyxHQUFHLENBQUN3QixHQUFHQyxJQUFNcEIsT0FBTyxJQUFNbUIsR0FBRztRQUN0RWYsUUFBUWdCO0lBQ1YsSUFBSTtBQUNKOzs7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O0NBSUMsR0FDTSxNQUFNa0csaUJBQWlCLFdBQVcsR0FBRUgsbUJBQW9CLFdBQVcsR0FBRWpILGtEQUFpQixJQUFJO0FBQ2pHOzs7OztDQUtDLEdBQ00sTUFBTXFILGdCQUFnQixXQUFXLEdBQUVwSCxrREFBSUEsQ0FBQyxHQUFHLENBQUMyQixNQUFNUyxNQUFNOUIsSUFBTXVGLFFBQVFsRSxNQUFNSCxDQUFBQSxJQUFLb0UsSUFBSXhELE1BQU1TLENBQUFBLElBQUt2QyxFQUFFa0IsR0FBR3FCLE1BQU07QUFDbEg7Ozs7O0NBS0MsR0FDTSxNQUFNd0UsWUFBWSxXQUFXLEdBQUVySCxrREFBSUEsQ0FBQyxHQUFHLENBQUMyQixNQUFNUyxPQUFTZ0YsY0FBY3pGLE1BQU1TLE1BQU0sQ0FBQ1osR0FBR3FCLElBQU07WUFBQ3JCO1lBQUdxQjtTQUFFLEdBQUcsQ0FDM0csb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9JdGVyYWJsZS5qcz80YzVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBJdGVyYWJsZXMgaW4gVHlwZVNjcmlwdC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0ICogYXMgRSBmcm9tIFwiLi9FaXRoZXIuanNcIjtcbmltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuL0VxdWFsLmpzXCI7XG5pbXBvcnQgeyBkdWFsLCBpZGVudGl0eSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBPIGZyb20gXCIuL09wdGlvbi5qc1wiO1xuaW1wb3J0IHsgaXNCb29sZWFuIH0gZnJvbSBcIi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgKiBhcyBUdXBsZSBmcm9tIFwiLi9UdXBsZS5qc1wiO1xuLyoqXG4gKiBSZXR1cm4gYSBgSXRlcmFibGVgIHdpdGggZWxlbWVudCBgaWAgaW5pdGlhbGl6ZWQgd2l0aCBgZihpKWAuXG4gKlxuICogSWYgdGhlIGBsZW5ndGhgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBgSXRlcmFibGVgIHdpbGwgYmUgaW5maW5pdGUuXG4gKlxuICogKipOb3RlKiouIGBsZW5ndGhgIGlzIG5vcm1hbGl6ZWQgdG8gYW4gaW50ZWdlciA+PSAxLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFrZUJ5IH0gZnJvbSBcImVmZmVjdC9JdGVyYWJsZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChBcnJheS5mcm9tKG1ha2VCeShuID0+IG4gKiAyLCB7IGxlbmd0aDogNSB9KSksIFswLCAyLCA0LCA2LCA4XSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFrZUJ5ID0gKGYsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWF4ID0gb3B0aW9ucz8ubGVuZ3RoICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCgxLCBNYXRoLmZsb29yKG9wdGlvbnMubGVuZ3RoKSkgOiBJbmZpbml0eTtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgaWYgKGkgPCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmKGkrKyksXG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIFJldHVybiBhIGBJdGVyYWJsZWAgY29udGFpbmluZyBhIHJhbmdlIG9mIGludGVnZXJzLCBpbmNsdWRpbmcgYm90aCBlbmRwb2ludHMuXG4gKlxuICogSWYgYGVuZGAgaXMgb21pdHRlZCwgdGhlIHJhbmdlIHdpbGwgbm90IGhhdmUgYW4gdXBwZXIgYm91bmQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyByYW5nZSB9IGZyb20gXCJlZmZlY3QvSXRlcmFibGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQXJyYXkuZnJvbShyYW5nZSgxLCAzKSksIFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbWFrZUJ5KGkgPT4gc3RhcnQgKyBpKTtcbiAgfVxuICByZXR1cm4gbWFrZUJ5KGkgPT4gc3RhcnQgKyBpLCB7XG4gICAgbGVuZ3RoOiBzdGFydCA8PSBlbmQgPyBlbmQgLSBzdGFydCArIDEgOiAxXG4gIH0pO1xufTtcbi8qKlxuICogUmV0dXJuIGEgYEl0ZXJhYmxlYCBjb250YWluaW5nIGEgdmFsdWUgcmVwZWF0ZWQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gKlxuICogKipOb3RlKiouIGBuYCBpcyBub3JtYWxpemVkIHRvIGFuIGludGVnZXIgPj0gMS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHJlcGxpY2F0ZSB9IGZyb20gXCJlZmZlY3QvSXRlcmFibGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQXJyYXkuZnJvbShyZXBsaWNhdGUoXCJhXCIsIDMpKSwgW1wiYVwiLCBcImFcIiwgXCJhXCJdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsaWNhdGUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoYSwgbikgPT4gbWFrZUJ5KCgpID0+IGEsIHtcbiAgbGVuZ3RoOiBuXG59KSk7XG4vKipcbiAqIFRha2VzIGEgcmVjb3JkIGFuZCByZXR1cm5zIGFuIEl0ZXJhYmxlIG9mIHR1cGxlcyBjb250YWluaW5nIGl0cyBrZXlzIGFuZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgcmVjb3JkIHRvIHRyYW5zZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21SZWNvcmQgfSBmcm9tIFwiZWZmZWN0L0l0ZXJhYmxlXCJcbiAqXG4gKiBjb25zdCB4ID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoQXJyYXkuZnJvbShmcm9tUmVjb3JkKHgpKSwgW1tcImFcIiwgMV0sIFtcImJcIiwgMl0sIFtcImNcIiwgM11dKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21SZWNvcmQgPSBzZWxmID0+ICh7XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzZWxmKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYsIGtleSkpIHtcbiAgICAgICAgeWllbGQgW2tleSwgc2VsZltrZXldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBQcmVwZW5kIGFuIGVsZW1lbnQgdG8gdGhlIGZyb250IG9mIGFuIGBJdGVyYWJsZWAsIGNyZWF0aW5nIGEgbmV3IGBJdGVyYWJsZWAuXG4gKlxuICogQGNhdGVnb3J5IGNvbmNhdGVuYXRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcHJlcGVuZCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBoZWFkKSA9PiBwcmVwZW5kQWxsKHNlbGYsIFtoZWFkXSkpO1xuLyoqXG4gKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIHByZWZpeCBpdGVyYWJsZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzcGVjaWZpZWQgaXRlcmFibGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBJdGVyYWJsZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIEFycmF5LmZyb20oSXRlcmFibGUucHJlcGVuZEFsbChbMSwgMl0sIFtcImFcIiwgXCJiXCJdKSksXG4gKiAgIFtcImFcIiwgXCJiXCIsIDEsIDJdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29uY2F0ZW5hdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcmVwZW5kQWxsID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGFwcGVuZEFsbCh0aGF0LCBzZWxmKSk7XG4vKipcbiAqIEFwcGVuZCBhbiBlbGVtZW50IHRvIHRoZSBlbmQgb2YgYW4gYEl0ZXJhYmxlYCwgY3JlYXRpbmcgYSBuZXcgYEl0ZXJhYmxlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uY2F0ZW5hdGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbGFzdCkgPT4gYXBwZW5kQWxsKHNlbGYsIFtsYXN0XSkpO1xuLyoqXG4gKiBDb25jYXRlbmF0ZXMgdHdvIGl0ZXJhYmxlcywgY29tYmluaW5nIHRoZWlyIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBjb25jYXRlbmF0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZEFsbCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiAoe1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBpdGVyQSA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGxldCBkb25lQSA9IGZhbHNlO1xuICAgIGxldCBpdGVyQjtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKCFkb25lQSkge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyQS5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSkge1xuICAgICAgICAgICAgZG9uZUEgPSB0cnVlO1xuICAgICAgICAgICAgaXRlckIgPSB0aGF0W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyQi5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyQi5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSkpO1xuLyoqXG4gKiBSZWR1Y2UgYW4gYEl0ZXJhYmxlYCBmcm9tIHRoZSBsZWZ0LCBrZWVwaW5nIGFsbCBpbnRlcm1lZGlhdGUgcmVzdWx0cyBpbnN0ZWFkIG9mIG9ubHkgdGhlIGZpbmFsIHJlc3VsdC5cbiAqXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzY2FuID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGIsIGYpID0+ICh7XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCBhY2MgPSBiO1xuICAgIGxldCBpdGVyYXRvcjtcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGl0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogYWNjXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGFjYyA9IGYoYWNjLCByZXN1bHQudmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBhY2NcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuZXh0XG4gICAgfTtcbiAgfVxufSkpO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYEl0ZXJhYmxlYCBpcyBlbXB0eVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gXCJlZmZlY3QvSXRlcmFibGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFbXB0eShbXSksIHRydWUpO1xuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0VtcHR5KFsxLCAyLCAzXSksIGZhbHNlKTtcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNFbXB0eSA9IHNlbGYgPT4ge1xuICBjb25zdCBpdGVyYXRvciA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXRlcmF0b3IubmV4dCgpLmRvbmUgPT09IHRydWU7XG59O1xuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGBJdGVyYWJsZWAuXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2l6ZSA9IHNlbGYgPT4ge1xuICBjb25zdCBpdGVyYXRvciA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICBsZXQgY291bnQgPSAwO1xuICB3aGlsZSAoIWl0ZXJhdG9yLm5leHQoKS5kb25lKSB7XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBgSXRlcmFibGVgLCBvciBgTm9uZWAgaWYgdGhlIGBJdGVyYWJsZWAgaXMgZW1wdHkuXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaGVhZCA9IHNlbGYgPT4ge1xuICBjb25zdCBpdGVyYXRvciA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gIHJldHVybiByZXN1bHQuZG9uZSA/IE8ubm9uZSgpIDogTy5zb21lKHJlc3VsdC52YWx1ZSk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBgSXRlcmFibGVgLCBvciB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYEl0ZXJhYmxlYCBpcyBlbXB0eS5cbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDMuMy4wXG4gKi9cbmV4cG9ydCBjb25zdCB1bnNhZmVIZWFkID0gc2VsZiA9PiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gc2VsZltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgaWYgKHJlc3VsdC5kb25lKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNhZmVIZWFkOiBlbXB0eSBpdGVyYWJsZVwiKTtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG4vKipcbiAqIEtlZXAgb25seSBhIG1heCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYW4gYEl0ZXJhYmxlYCwgY3JlYXRpbmcgYSBuZXcgYEl0ZXJhYmxlYC5cbiAqXG4gKiAqKk5vdGUqKi4gYG5gIGlzIG5vcm1hbGl6ZWQgdG8gYSBub24gbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0YWtlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG4pID0+ICh7XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBpdGVyYXRvciA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAoaSA8IG4pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBsb25nZXN0IGluaXRpYWwgSXRlcmFibGUgZm9yIHdoaWNoIGFsbCBlbGVtZW50IHNhdGlzZnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGNyZWF0aW5nIGEgbmV3IGBJdGVyYWJsZWAuXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdGFrZVdoaWxlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHByZWRpY2F0ZSkgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lIHx8ICFwcmVkaWNhdGUocmVzdWx0LnZhbHVlLCBpKyspKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogRHJvcCBhIG1heCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYW4gYEl0ZXJhYmxlYFxuICpcbiAqICoqTm90ZSoqLiBgbmAgaXMgbm9ybWFsaXplZCB0byBhIG5vbiBuZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRyb3AgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbikgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgc3BlY2lmaWVkXG4gKiBwcmVkaWNhdGUsIG9yIGBOb25lYCBpZiBubyBzdWNoIGVsZW1lbnQgZXhpc3RzLlxuICpcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kRmlyc3QgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgYSBvZiBzZWxmKSB7XG4gICAgY29uc3QgbyA9IGYoYSwgaSk7XG4gICAgaWYgKGlzQm9vbGVhbihvKSkge1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgcmV0dXJuIE8uc29tZShhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE8uaXNTb21lKG8pKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIE8ubm9uZSgpO1xufSk7XG4vKipcbiAqIEZpbmQgdGhlIGxhc3QgZWxlbWVudCBmb3Igd2hpY2ggYSBwcmVkaWNhdGUgaG9sZHMuXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRMYXN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgbGFzdCA9IE8ubm9uZSgpO1xuICBmb3IgKGNvbnN0IGEgb2Ygc2VsZikge1xuICAgIGNvbnN0IG8gPSBmKGEsIGkpO1xuICAgIGlmIChpc0Jvb2xlYW4obykpIHtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGxhc3QgPSBPLnNvbWUoYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChPLmlzU29tZShvKSkge1xuICAgICAgICBsYXN0ID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBsYXN0O1xufSk7XG4vKipcbiAqIFRha2VzIHR3byBgSXRlcmFibGVgcyBhbmQgcmV0dXJucyBhbiBgSXRlcmFibGVgIG9mIGNvcnJlc3BvbmRpbmcgcGFpcnMuXG4gKlxuICogQGNhdGVnb3J5IHppcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgemlwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IHppcFdpdGgoc2VsZiwgdGhhdCwgVHVwbGUubWFrZSkpO1xuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIHBhaXJzIG9mIGVsZW1lbnRzIGF0IHRoZSBzYW1lIGluZGV4IGluIHR3byBgSXRlcmFibGVgcywgY29sbGVjdGluZyB0aGUgcmVzdWx0cy4gSWYgb25lXG4gKiBpbnB1dCBgSXRlcmFibGVgIGlzIHNob3J0LCBleGNlc3MgZWxlbWVudHMgb2YgdGhlIGxvbmdlciBgSXRlcmFibGVgIGFyZSBkaXNjYXJkZWQuXG4gKlxuICogQGNhdGVnb3J5IHppcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgemlwV2l0aCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCB0aGF0LCBmKSA9PiAoe1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBzZWxmSXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCB0aGF0SXRlcmF0b3IgPSB0aGF0W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZlJlc3VsdCA9IHNlbGZJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGNvbnN0IHRoYXRSZXN1bHQgPSB0aGF0SXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc2VsZlJlc3VsdC5kb25lIHx8IHRoYXRSZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogZihzZWxmUmVzdWx0LnZhbHVlLCB0aGF0UmVzdWx0LnZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogUGxhY2VzIGFuIGVsZW1lbnQgaW4gYmV0d2VlbiBtZW1iZXJzIG9mIGFuIGBJdGVyYWJsZWAuXG4gKiBJZiB0aGUgaW5wdXQgaXMgYSBub24tZW1wdHkgYXJyYXksIHRoZSByZXN1bHQgaXMgYWxzbyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVyc3BlcnNlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG1pZGRsZSkgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBsZXQgZW1pdHRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZW1pdHRlZCkge1xuICAgICAgICAgIGVtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogbWlkZGxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dDtcbiAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KSk7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhbiBgSXRlcmFibGVgIGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgdXNpbmcgYSBwcm92aWRlZCBgaXNFcXVpdmFsZW50YCBmdW5jdGlvbi5cbiAqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29udGFpbnNXaXRoID0gaXNFcXVpdmFsZW50ID0+IGR1YWwoMiwgKHNlbGYsIGEpID0+IHtcbiAgZm9yIChjb25zdCBpIG9mIHNlbGYpIHtcbiAgICBpZiAoaXNFcXVpdmFsZW50KGEsIGkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG5jb25zdCBfZXF1aXZhbGVuY2UgPSAvKiNfX1BVUkVfXyovRXF1YWwuZXF1aXZhbGVuY2UoKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgYEl0ZXJhYmxlYCBjb250YWlucyBhIGdpdmVuIHZhbHVlIHVzaW5nIHRoZSBkZWZhdWx0IGBFcXVpdmFsZW5jZWAuXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRhaW5zID0gLyojX19QVVJFX18qL2NvbnRhaW5zV2l0aChfZXF1aXZhbGVuY2UpO1xuLyoqXG4gKiBTcGxpdHMgYW4gYEl0ZXJhYmxlYCBpbnRvIGxlbmd0aC1gbmAgcGllY2VzLiBUaGUgbGFzdCBwaWVjZSB3aWxsIGJlIHNob3J0ZXIgaWYgYG5gIGRvZXMgbm90IGV2ZW5seSBkaXZpZGUgdGhlIGxlbmd0aCBvZlxuICogdGhlIGBJdGVyYWJsZWAuXG4gKlxuICogQGNhdGVnb3J5IHNwbGl0dGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjaHVua3NPZiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBuKSA9PiB7XG4gIGNvbnN0IHNhZmVOID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihuKSk7XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICBsZXQgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYWZlTjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgaXRlcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHJldHVybiBjaHVuay5sZW5ndGggPT09IDAgPyB7XG4gICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVuay5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBjaHVua1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufSk7XG4vKipcbiAqIEdyb3VwIGVxdWFsLCBjb25zZWN1dGl2ZSBlbGVtZW50cyBvZiBhbiBgSXRlcmFibGVgIGludG8gYE5vbkVtcHR5QXJyYXlgcyB1c2luZyB0aGUgcHJvdmlkZWQgYGlzRXF1aXZhbGVudGAgZnVuY3Rpb24uXG4gKlxuICogQGNhdGVnb3J5IGdyb3VwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwV2l0aCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBpc0VxdWl2YWxlbnQpID0+ICh7XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gc2VsZltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgbGV0IG5leHRSZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChuZXh0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobmV4dFJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBuZXh0UmVzdWx0O1xuICAgICAgICAgIG5leHRSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSBbcmVzdWx0LnZhbHVlXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0LmRvbmUgfHwgIWlzRXF1aXZhbGVudChyZXN1bHQudmFsdWUsIG5leHQudmFsdWUpKSB7XG4gICAgICAgICAgICBuZXh0UmVzdWx0ID0gbmV4dDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogY2h1bmtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNodW5rLnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KSk7XG4vKipcbiAqIEdyb3VwIGVxdWFsLCBjb25zZWN1dGl2ZSBlbGVtZW50cyBvZiBhbiBgSXRlcmFibGVgIGludG8gYE5vbkVtcHR5QXJyYXlgcy5cbiAqXG4gKiBAY2F0ZWdvcnkgZ3JvdXBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ3JvdXAgPSAvKiNfX1BVUkVfXyovZ3JvdXBXaXRoKCAvKiNfX1BVUkVfXyovRXF1YWwuZXF1aXZhbGVuY2UoKSk7XG4vKipcbiAqIFNwbGl0cyBhbiBgSXRlcmFibGVgIGludG8gc3ViLW5vbi1lbXB0eS1hcnJheXMgc3RvcmVkIGluIGFuIG9iamVjdCwgYmFzZWQgb24gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGEgYHN0cmluZ2AtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQsIGFuZCBncm91cGluZyB0aGUgcmVzdWx0cyBhY2NvcmRpbmcgdG8gdmFsdWVzIHJldHVybmVkXG4gKlxuICogQGNhdGVnb3J5IGdyb3VwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwQnkgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4ge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBhIG9mIHNlbGYpIHtcbiAgICBjb25zdCBrID0gZihhKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dCwgaykpIHtcbiAgICAgIG91dFtrXS5wdXNoKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRba10gPSBbYV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbmNvbnN0IGNvbnN0RW1wdHkgPSB7XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBjb25zdEVtcHR5SXRlcmF0b3I7XG4gIH1cbn07XG5jb25zdCBjb25zdEVtcHR5SXRlcmF0b3IgPSB7XG4gIG5leHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbmU6IHRydWUsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBlbXB0eSA9ICgpID0+IGNvbnN0RW1wdHk7XG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEl0ZXJhYmxlPEE+YCBmcm9tIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBvZiA9IGEgPT4gW2FdO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBmKHJlc3VsdC52YWx1ZSwgaSsrKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBpbiBhbiBJdGVyYWJsZSBhbmQgcmV0dXJucyBhIG5ldyBJdGVyYWJsZSBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgbWFwcGVkIGVsZW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXRNYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gZmxhdHRlbihtYXAoc2VsZiwgZikpKTtcbi8qKlxuICogRmxhdHRlbnMgYW4gSXRlcmFibGUgb2YgSXRlcmFibGVzIGludG8gYSBzaW5nbGUgSXRlcmFibGVcbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gc2VsZiA9PiAoe1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBvdXRlckl0ZXJhdG9yID0gc2VsZltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgbGV0IGlubmVySXRlcmF0b3I7XG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmIChpbm5lckl0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IG91dGVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJJdGVyYXRvciA9IG5leHQudmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgaW5uZXJJdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuZXh0XG4gICAgfTtcbiAgfVxufSk7XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyTWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+ICh7XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gc2VsZltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgY29uc3QgYiA9IGYocmVzdWx0LnZhbHVlLCBpKyspO1xuICAgICAgICAgIGlmIChPLmlzU29tZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBiLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KSk7XG4vKipcbiAqIFRyYW5zZm9ybXMgYWxsIGVsZW1lbnRzIG9mIHRoZSBgSXRlcmFibGVgIGZvciBhcyBsb25nIGFzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gcmV0dXJucyBzb21lIHZhbHVlXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXJNYXBXaGlsZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiAoe1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGIgPSBmKHJlc3VsdC52YWx1ZSwgaSsrKTtcbiAgICAgICAgaWYgKE8uaXNTb21lKGIpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGIudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSkpO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGBTb21lYCB2YWx1ZXMgZnJvbSBhbiBgSXRlcmFibGVgIG9mIGBPcHRpb25gcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEl0ZXJhYmxlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBBcnJheS5mcm9tKEl0ZXJhYmxlLmdldFNvbWVzKFtPcHRpb24uc29tZSgxKSwgT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMildKSksXG4gKiAgIFsxLCAyXVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTb21lcyA9IC8qI19fUFVSRV9fKi9maWx0ZXJNYXAoaWRlbnRpdHkpO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGBMZWZ0YCB2YWx1ZXMgZnJvbSBhbiBgSXRlcmFibGVgIG9mIGBFaXRoZXJgcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEl0ZXJhYmxlLCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBBcnJheS5mcm9tKEl0ZXJhYmxlLmdldExlZnRzKFtFaXRoZXIucmlnaHQoMSksIEVpdGhlci5sZWZ0KFwiZXJyXCIpLCBFaXRoZXIucmlnaHQoMildKSksXG4gKiAgIFtcImVyclwiXVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMZWZ0cyA9IHNlbGYgPT4gZmlsdGVyTWFwKHNlbGYsIEUuZ2V0TGVmdCk7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgYFJpZ2h0YCB2YWx1ZXMgZnJvbSBhbiBgSXRlcmFibGVgIG9mIGBFaXRoZXJgcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEl0ZXJhYmxlLCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBBcnJheS5mcm9tKEl0ZXJhYmxlLmdldFJpZ2h0cyhbRWl0aGVyLnJpZ2h0KDEpLCBFaXRoZXIubGVmdChcImVyclwiKSwgRWl0aGVyLnJpZ2h0KDIpXSkpLFxuICogICBbMSwgMl1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0UmlnaHRzID0gc2VsZiA9PiBmaWx0ZXJNYXAoc2VsZiwgRS5nZXRSaWdodCk7XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHByZWRpY2F0ZSkgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBzZWxmW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKHJlc3VsdC52YWx1ZSwgaSsrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcE51bGxhYmxlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGZpbHRlck1hcChzZWxmLCBhID0+IHtcbiAgY29uc3QgYiA9IGYoYSk7XG4gIHJldHVybiBiID09IG51bGwgPyBPLm5vbmUoKSA6IE8uc29tZShiKTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaG9sZHMgdHJ1ZSBmb3Igc29tZSBgSXRlcmFibGVgIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgcHJlZGljYXRlKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCBhIG9mIHNlbGYpIHtcbiAgICBpZiAocHJlZGljYXRlKGEsIGkrKykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB1bmZvbGQgPSAoYiwgZikgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IG5leHQgPSBiO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBvID0gZihuZXh0KTtcbiAgICAgICAgaWYgKE8uaXNOb25lKG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvLnZhbHVlO1xuICAgICAgICBuZXh0ID0gYjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGBJdGVyYWJsZWAgYXBwbHlpbmcgYGZgLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCBhIG9mIHNlbGYpIHtcbiAgICBmKGEsIGkrKyk7XG4gIH1cbn0pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByZWR1Y2UgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgYiwgZikgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZWxmKSkge1xuICAgIHJldHVybiBzZWxmLnJlZHVjZShmLCBiKTtcbiAgfVxuICBsZXQgaSA9IDA7XG4gIGxldCByZXN1bHQgPSBiO1xuICBmb3IgKGNvbnN0IG4gb2Ygc2VsZikge1xuICAgIHJlc3VsdCA9IGYocmVzdWx0LCBuLCBpKyspO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbi8qKlxuICogRGVkdXBsaWNhdGVzIGFkamFjZW50IGVsZW1lbnRzIHRoYXQgYXJlIGlkZW50aWNhbCB1c2luZyB0aGUgcHJvdmlkZWQgYGlzRXF1aXZhbGVudGAgZnVuY3Rpb24uXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkZWR1cGVBZGphY2VudFdpdGggPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgaXNFcXVpdmFsZW50KSA9PiAoe1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IHNlbGZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgbGV0IGxhc3Q7XG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGxhc3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgaWYgKGlzRXF1aXZhbGVudChsYXN0LCBjdXJyZW50KSkge1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuICAgICAgbGFzdCA9IGN1cnJlbnQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dFxuICAgIH07XG4gIH1cbn0pKTtcbi8qKlxuICogRGVkdXBsaWNhdGVzIGFkamFjZW50IGVsZW1lbnRzIHRoYXQgYXJlIGlkZW50aWNhbC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZHVwZUFkamFjZW50ID0gLyojX19QVVJFX18qL2RlZHVwZUFkamFjZW50V2l0aCggLyojX19QVVJFX18qL0VxdWFsLmVxdWl2YWxlbmNlKCkpO1xuLyoqXG4gKiBaaXBzIHRoaXMgSXRlcmFibGUgY3Jvc3N3aXNlIHdpdGggdGhlIHNwZWNpZmllZCBJdGVyYWJsZSB1c2luZyB0aGUgc3BlY2lmaWVkIGNvbWJpbmVyLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBjYXJ0ZXNpYW5XaXRoID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRoYXQsIGYpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiBtYXAodGhhdCwgYiA9PiBmKGEsIGIpKSkpO1xuLyoqXG4gKiBaaXBzIHRoaXMgSXRlcmFibGUgY3Jvc3N3aXNlIHdpdGggdGhlIHNwZWNpZmllZCBJdGVyYWJsZS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICovXG5leHBvcnQgY29uc3QgY2FydGVzaWFuID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGNhcnRlc2lhbldpdGgoc2VsZiwgdGhhdCwgKGEsIGIpID0+IFthLCBiXSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlcmFibGUuanMubWFwIl0sIm5hbWVzIjpbIkUiLCJFcXVhbCIsImR1YWwiLCJpZGVudGl0eSIsIk8iLCJpc0Jvb2xlYW4iLCJUdXBsZSIsIm1ha2VCeSIsImYiLCJvcHRpb25zIiwibWF4IiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiTWF0aCIsImZsb29yIiwiSW5maW5pdHkiLCJTeW1ib2wiLCJpdGVyYXRvciIsImkiLCJuZXh0IiwidmFsdWUiLCJkb25lIiwicmFuZ2UiLCJzdGFydCIsImVuZCIsInJlcGxpY2F0ZSIsImEiLCJuIiwiZnJvbVJlY29yZCIsInNlbGYiLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwcmVwZW5kIiwiaGVhZCIsInByZXBlbmRBbGwiLCJ0aGF0IiwiYXBwZW5kQWxsIiwiYXBwZW5kIiwibGFzdCIsIml0ZXJBIiwiZG9uZUEiLCJpdGVyQiIsInIiLCJzY2FuIiwiYiIsImFjYyIsInJlc3VsdCIsImlzRW1wdHkiLCJzaXplIiwiY291bnQiLCJub25lIiwic29tZSIsInVuc2FmZUhlYWQiLCJFcnJvciIsInRha2UiLCJ0YWtlV2hpbGUiLCJwcmVkaWNhdGUiLCJkcm9wIiwiZmluZEZpcnN0IiwibyIsImlzU29tZSIsImZpbmRMYXN0IiwiemlwIiwiemlwV2l0aCIsIm1ha2UiLCJzZWxmSXRlcmF0b3IiLCJ0aGF0SXRlcmF0b3IiLCJzZWxmUmVzdWx0IiwidGhhdFJlc3VsdCIsImludGVyc3BlcnNlIiwibWlkZGxlIiwiZW1pdHRlZCIsImNvbnRhaW5zV2l0aCIsImlzRXF1aXZhbGVudCIsIl9lcXVpdmFsZW5jZSIsImVxdWl2YWxlbmNlIiwiY29udGFpbnMiLCJjaHVua3NPZiIsInNhZmVOIiwiY2h1bmsiLCJwdXNoIiwiZ3JvdXBXaXRoIiwibmV4dFJlc3VsdCIsImdyb3VwIiwiZ3JvdXBCeSIsIm91dCIsImsiLCJjb25zdEVtcHR5IiwiY29uc3RFbXB0eUl0ZXJhdG9yIiwiZW1wdHkiLCJvZiIsIm1hcCIsImZsYXRNYXAiLCJmbGF0dGVuIiwib3V0ZXJJdGVyYXRvciIsImlubmVySXRlcmF0b3IiLCJmaWx0ZXJNYXAiLCJmaWx0ZXJNYXBXaGlsZSIsImdldFNvbWVzIiwiZ2V0TGVmdHMiLCJnZXRMZWZ0IiwiZ2V0UmlnaHRzIiwiZ2V0UmlnaHQiLCJmaWx0ZXIiLCJmbGF0TWFwTnVsbGFibGUiLCJ1bmZvbGQiLCJpc05vbmUiLCJmb3JFYWNoIiwicmVkdWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVkdXBlQWRqYWNlbnRXaXRoIiwiZmlyc3QiLCJjdXJyZW50IiwiZGVkdXBlQWRqYWNlbnQiLCJjYXJ0ZXNpYW5XaXRoIiwiY2FydGVzaWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Iterable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Micro.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Micro.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CurrentConcurrency: () => (/* binding */ CurrentConcurrency),\n/* harmony export */   CurrentScheduler: () => (/* binding */ CurrentScheduler),\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   MaxOpsBeforeYield: () => (/* binding */ MaxOpsBeforeYield),\n/* harmony export */   MicroCauseTypeId: () => (/* binding */ MicroCauseTypeId),\n/* harmony export */   MicroExitTypeId: () => (/* binding */ MicroExitTypeId),\n/* harmony export */   MicroFiberTypeId: () => (/* binding */ MicroFiberTypeId),\n/* harmony export */   MicroSchedulerDefault: () => (/* binding */ MicroSchedulerDefault),\n/* harmony export */   MicroScope: () => (/* binding */ MicroScope),\n/* harmony export */   MicroScopeTypeId: () => (/* binding */ MicroScopeTypeId),\n/* harmony export */   NoSuchElementException: () => (/* binding */ NoSuchElementException),\n/* harmony export */   TaggedError: () => (/* binding */ TaggedError),\n/* harmony export */   TimeoutException: () => (/* binding */ TimeoutException),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   acquireRelease: () => (/* binding */ acquireRelease),\n/* harmony export */   acquireUseRelease: () => (/* binding */ acquireUseRelease),\n/* harmony export */   addFinalizer: () => (/* binding */ addFinalizer),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   andThen: () => (/* binding */ andThen),\n/* harmony export */   as: () => (/* binding */ as),\n/* harmony export */   asSome: () => (/* binding */ asSome),\n/* harmony export */   asVoid: () => (/* binding */ asVoid),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   catchAll: () => (/* binding */ catchAll),\n/* harmony export */   catchAllCause: () => (/* binding */ catchAllCause),\n/* harmony export */   catchAllDefect: () => (/* binding */ catchAllDefect),\n/* harmony export */   catchCauseIf: () => (/* binding */ catchCauseIf),\n/* harmony export */   catchIf: () => (/* binding */ catchIf),\n/* harmony export */   catchTag: () => (/* binding */ catchTag),\n/* harmony export */   causeDie: () => (/* binding */ causeDie),\n/* harmony export */   causeFail: () => (/* binding */ causeFail),\n/* harmony export */   causeInterrupt: () => (/* binding */ causeInterrupt),\n/* harmony export */   causeIsDie: () => (/* binding */ causeIsDie),\n/* harmony export */   causeIsFail: () => (/* binding */ causeIsFail),\n/* harmony export */   causeIsInterrupt: () => (/* binding */ causeIsInterrupt),\n/* harmony export */   causeSquash: () => (/* binding */ causeSquash),\n/* harmony export */   causeWithTrace: () => (/* binding */ causeWithTrace),\n/* harmony export */   context: () => (/* binding */ context),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   die: () => (/* binding */ die),\n/* harmony export */   either: () => (/* binding */ either),\n/* harmony export */   ensuring: () => (/* binding */ ensuring),\n/* harmony export */   exit: () => (/* binding */ exit),\n/* harmony export */   exitDie: () => (/* binding */ exitDie),\n/* harmony export */   exitFail: () => (/* binding */ exitFail),\n/* harmony export */   exitFailCause: () => (/* binding */ exitFailCause),\n/* harmony export */   exitInterrupt: () => (/* binding */ exitInterrupt),\n/* harmony export */   exitIsDie: () => (/* binding */ exitIsDie),\n/* harmony export */   exitIsFail: () => (/* binding */ exitIsFail),\n/* harmony export */   exitIsFailure: () => (/* binding */ exitIsFailure),\n/* harmony export */   exitIsInterrupt: () => (/* binding */ exitIsInterrupt),\n/* harmony export */   exitIsSuccess: () => (/* binding */ exitIsSuccess),\n/* harmony export */   exitSucceed: () => (/* binding */ exitSucceed),\n/* harmony export */   exitVoid: () => (/* binding */ exitVoid),\n/* harmony export */   exitVoidAll: () => (/* binding */ exitVoidAll),\n/* harmony export */   fail: () => (/* binding */ fail),\n/* harmony export */   failCause: () => (/* binding */ failCause),\n/* harmony export */   failCauseSync: () => (/* binding */ failCauseSync),\n/* harmony export */   failSync: () => (/* binding */ failSync),\n/* harmony export */   fiberAwait: () => (/* binding */ fiberAwait),\n/* harmony export */   fiberInterrupt: () => (/* binding */ fiberInterrupt),\n/* harmony export */   fiberInterruptAll: () => (/* binding */ fiberInterruptAll),\n/* harmony export */   fiberJoin: () => (/* binding */ fiberJoin),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   filterOrFail: () => (/* binding */ filterOrFail),\n/* harmony export */   filterOrFailCause: () => (/* binding */ filterOrFailCause),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   forever: () => (/* binding */ forever),\n/* harmony export */   fork: () => (/* binding */ fork),\n/* harmony export */   forkDaemon: () => (/* binding */ forkDaemon),\n/* harmony export */   forkIn: () => (/* binding */ forkIn),\n/* harmony export */   forkScoped: () => (/* binding */ forkScoped),\n/* harmony export */   fromEither: () => (/* binding */ fromEither),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   ignore: () => (/* binding */ ignore),\n/* harmony export */   ignoreLogged: () => (/* binding */ ignoreLogged),\n/* harmony export */   interrupt: () => (/* binding */ interrupt),\n/* harmony export */   interruptible: () => (/* binding */ interruptible),\n/* harmony export */   isMicro: () => (/* binding */ isMicro),\n/* harmony export */   isMicroCause: () => (/* binding */ isMicroCause),\n/* harmony export */   isMicroExit: () => (/* binding */ isMicroExit),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapError: () => (/* binding */ mapError),\n/* harmony export */   mapErrorCause: () => (/* binding */ mapErrorCause),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   matchCause: () => (/* binding */ matchCause),\n/* harmony export */   matchCauseEffect: () => (/* binding */ matchCauseEffect),\n/* harmony export */   matchEffect: () => (/* binding */ matchEffect),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   onError: () => (/* binding */ onError),\n/* harmony export */   onExit: () => (/* binding */ onExit),\n/* harmony export */   onExitIf: () => (/* binding */ onExitIf),\n/* harmony export */   onInterrupt: () => (/* binding */ onInterrupt),\n/* harmony export */   option: () => (/* binding */ option),\n/* harmony export */   orDie: () => (/* binding */ orDie),\n/* harmony export */   orElseSucceed: () => (/* binding */ orElseSucceed),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   provideContext: () => (/* binding */ provideContext),\n/* harmony export */   provideScope: () => (/* binding */ provideScope),\n/* harmony export */   provideService: () => (/* binding */ provideService),\n/* harmony export */   provideServiceEffect: () => (/* binding */ provideServiceEffect),\n/* harmony export */   race: () => (/* binding */ race),\n/* harmony export */   raceAll: () => (/* binding */ raceAll),\n/* harmony export */   raceAllFirst: () => (/* binding */ raceAllFirst),\n/* harmony export */   raceFirst: () => (/* binding */ raceFirst),\n/* harmony export */   repeat: () => (/* binding */ repeat),\n/* harmony export */   repeatExit: () => (/* binding */ repeatExit),\n/* harmony export */   replicate: () => (/* binding */ replicate),\n/* harmony export */   replicateEffect: () => (/* binding */ replicateEffect),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   runFork: () => (/* binding */ runFork),\n/* harmony export */   runPromise: () => (/* binding */ runPromise),\n/* harmony export */   runPromiseExit: () => (/* binding */ runPromiseExit),\n/* harmony export */   runSync: () => (/* binding */ runSync),\n/* harmony export */   runSyncExit: () => (/* binding */ runSyncExit),\n/* harmony export */   sandbox: () => (/* binding */ sandbox),\n/* harmony export */   scheduleAddDelay: () => (/* binding */ scheduleAddDelay),\n/* harmony export */   scheduleExponential: () => (/* binding */ scheduleExponential),\n/* harmony export */   scheduleIntersect: () => (/* binding */ scheduleIntersect),\n/* harmony export */   scheduleRecurs: () => (/* binding */ scheduleRecurs),\n/* harmony export */   scheduleSpaced: () => (/* binding */ scheduleSpaced),\n/* harmony export */   scheduleUnion: () => (/* binding */ scheduleUnion),\n/* harmony export */   scheduleWithMaxDelay: () => (/* binding */ scheduleWithMaxDelay),\n/* harmony export */   scheduleWithMaxElapsed: () => (/* binding */ scheduleWithMaxElapsed),\n/* harmony export */   scope: () => (/* binding */ scope),\n/* harmony export */   scopeMake: () => (/* binding */ scopeMake),\n/* harmony export */   scopeUnsafeMake: () => (/* binding */ scopeUnsafeMake),\n/* harmony export */   scoped: () => (/* binding */ scoped),\n/* harmony export */   service: () => (/* binding */ service),\n/* harmony export */   serviceOption: () => (/* binding */ serviceOption),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   succeed: () => (/* binding */ succeed),\n/* harmony export */   succeedNone: () => (/* binding */ succeedNone),\n/* harmony export */   succeedSome: () => (/* binding */ succeedSome),\n/* harmony export */   suspend: () => (/* binding */ suspend),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   tapDefect: () => (/* binding */ tapDefect),\n/* harmony export */   tapError: () => (/* binding */ tapError),\n/* harmony export */   tapErrorCause: () => (/* binding */ tapErrorCause),\n/* harmony export */   tapErrorCauseIf: () => (/* binding */ tapErrorCauseIf),\n/* harmony export */   timeout: () => (/* binding */ timeout),\n/* harmony export */   timeoutOption: () => (/* binding */ timeoutOption),\n/* harmony export */   timeoutOrElse: () => (/* binding */ timeoutOrElse),\n/* harmony export */   \"try\": () => (/* binding */ try_),\n/* harmony export */   tryPromise: () => (/* binding */ tryPromise),\n/* harmony export */   uninterruptible: () => (/* binding */ uninterruptible),\n/* harmony export */   uninterruptibleMask: () => (/* binding */ uninterruptibleMask),\n/* harmony export */   updateContext: () => (/* binding */ updateContext),\n/* harmony export */   updateService: () => (/* binding */ updateService),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   when: () => (/* binding */ when),\n/* harmony export */   whileLoop: () => (/* binding */ whileLoop),\n/* harmony export */   withConcurrency: () => (/* binding */ withConcurrency),\n/* harmony export */   withMicroFiber: () => (/* binding */ withMicroFiber),\n/* harmony export */   withTrace: () => (/* binding */ withTrace),\n/* harmony export */   yieldFlush: () => (/* binding */ yieldFlush),\n/* harmony export */   yieldNow: () => (/* binding */ yieldNow),\n/* harmony export */   yieldNowWith: () => (/* binding */ yieldNowWith),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Array_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Array.js */ \"(ssr)/./node_modules/effect/dist/esm/Array.js\");\n/* harmony import */ var _Context_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Context.js */ \"(ssr)/./node_modules/effect/dist/esm/Context.js\");\n/* harmony import */ var _Effectable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Effectable.js\");\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _internal_context_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/context.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/context.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _internal_effectable_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./internal/effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/* harmony import */ var _Option_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Option.js */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/**\n * A lightweight alternative to the `Effect` data type, with a subset of the functionality.\n *\n * @since 3.4.0\n * @experimental\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @since 3.4.0\n * @experimental\n * @category type ids\n */ const TypeId = /*#__PURE__*/ Symbol.for(\"effect/Micro\");\n/**\n * @since 3.4.0\n * @experimental\n * @category MicroExit\n */ const MicroExitTypeId = /*#__PURE__*/ Symbol.for(\"effect/Micro/MicroExit\");\n/**\n * @since 3.4.0\n * @experimental\n * @category guards\n */ const isMicro = (u)=>typeof u === \"object\" && u !== null && TypeId in u;\n// ----------------------------------------------------------------------------\n// MicroCause\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const MicroCauseTypeId = /*#__PURE__*/ Symbol.for(\"effect/Micro/MicroCause\");\n/**\n * @since 3.6.6\n * @experimental\n * @category guards\n */ const isMicroCause = (self)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(self, MicroCauseTypeId);\nconst microCauseVariance = {\n    _E: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n};\nclass MicroCauseImpl extends globalThis.Error {\n    constructor(_tag, originalError, traces){\n        const causeName = `MicroCause.${_tag}`;\n        let name;\n        let message;\n        let stack;\n        if (originalError instanceof globalThis.Error) {\n            name = `(${causeName}) ${originalError.name}`;\n            message = originalError.message;\n            const messageLines = message.split(\"\\n\").length;\n            stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(\"\\n\").slice(0, messageLines + 3).join(\"\\n\")}` : `${name}: ${message}`;\n        } else {\n            name = causeName;\n            message = (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.toStringUnknown)(originalError, 0);\n            stack = `${name}: ${message}`;\n        }\n        if (traces.length > 0) {\n            stack += `\\n    ${traces.join(\"\\n    \")}`;\n        }\n        super(message);\n        this._tag = _tag;\n        this.traces = traces;\n        this[MicroCauseTypeId] = microCauseVariance;\n        this.name = name;\n        this.stack = stack;\n    }\n    pipe() {\n        return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_3__.pipeArguments)(this, arguments);\n    }\n    toString() {\n        return this.stack;\n    }\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.NodeInspectSymbol]() {\n        return this.stack;\n    }\n}\nclass Fail extends MicroCauseImpl {\n    constructor(error, traces = []){\n        super(\"Fail\", error, traces);\n        this.error = error;\n    }\n}\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeFail = (error, traces = [])=>new Fail(error, traces);\nclass Die extends MicroCauseImpl {\n    constructor(defect, traces = []){\n        super(\"Die\", defect, traces);\n        this.defect = defect;\n    }\n}\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeDie = (defect, traces = [])=>new Die(defect, traces);\nclass Interrupt extends MicroCauseImpl {\n    constructor(traces = []){\n        super(\"Interrupt\", \"interrupted\", traces);\n    }\n}\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeInterrupt = (traces = [])=>new Interrupt(traces);\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeIsFail = (self)=>self._tag === \"Fail\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeIsDie = (self)=>self._tag === \"Die\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeIsInterrupt = (self)=>self._tag === \"Interrupt\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeSquash = (self)=>self._tag === \"Fail\" ? self.error : self._tag === \"Die\" ? self.defect : self;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */ const causeWithTrace = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, trace)=>{\n    const traces = [\n        ...self.traces,\n        trace\n    ];\n    switch(self._tag){\n        case \"Die\":\n            return causeDie(self.defect, traces);\n        case \"Interrupt\":\n            return causeInterrupt(traces);\n        case \"Fail\":\n            return causeFail(self.error, traces);\n    }\n});\n// ----------------------------------------------------------------------------\n// MicroFiber\n// ----------------------------------------------------------------------------\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */ const MicroFiberTypeId = /*#__PURE__*/ Symbol.for(\"effect/Micro/MicroFiber\");\nconst fiberVariance = {\n    _A: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    _E: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n};\nclass MicroFiberImpl {\n    constructor(context, interruptible = true){\n        this._stack = [];\n        this._observers = [];\n        this.currentOpCount = 0;\n        this._interrupted = false;\n        // cancel the yielded operation, or for the yielded exit value\n        this._yielded = undefined;\n        this.context = context;\n        this.interruptible = interruptible;\n        this[MicroFiberTypeId] = fiberVariance;\n    }\n    getRef(ref) {\n        return _internal_context_js__WEBPACK_IMPORTED_MODULE_4__.unsafeGetReference(this.context, ref);\n    }\n    addObserver(cb) {\n        if (this._exit) {\n            cb(this._exit);\n            return _Function_js__WEBPACK_IMPORTED_MODULE_1__.constVoid;\n        }\n        this._observers.push(cb);\n        return ()=>{\n            const index = this._observers.indexOf(cb);\n            if (index >= 0) {\n                this._observers.splice(index, 1);\n            }\n        };\n    }\n    unsafeInterrupt() {\n        if (this._exit) {\n            return;\n        }\n        this._interrupted = true;\n        if (this.interruptible) {\n            this.evaluate(exitInterrupt);\n        }\n    }\n    unsafePoll() {\n        return this._exit;\n    }\n    evaluate(effect) {\n        if (this._exit) {\n            return;\n        } else if (this._yielded !== undefined) {\n            const yielded = this._yielded;\n            this._yielded = undefined;\n            yielded();\n        }\n        const exit = this.runLoop(effect);\n        if (exit === Yield) {\n            return;\n        }\n        // the interruptChildren middlware is added in Micro.fork, so it can be\n        // tree-shaken if not used\n        const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);\n        if (interruptChildren !== undefined) {\n            return this.evaluate(flatMap(interruptChildren, ()=>exit));\n        }\n        this._exit = exit;\n        for(let i = 0; i < this._observers.length; i++){\n            this._observers[i](exit);\n        }\n        this._observers.length = 0;\n    }\n    runLoop(effect) {\n        let yielding = false;\n        let current = effect;\n        this.currentOpCount = 0;\n        try {\n            while(true){\n                this.currentOpCount++;\n                if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {\n                    yielding = true;\n                    const prev = current;\n                    current = flatMap(yieldNow, ()=>prev);\n                }\n                current = current[evaluate](this);\n                if (current === Yield) {\n                    const yielded = this._yielded;\n                    if (MicroExitTypeId in yielded) {\n                        this._yielded = undefined;\n                        return yielded;\n                    }\n                    return Yield;\n                }\n            }\n        } catch (error) {\n            if (!(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(current, evaluate)) {\n                return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);\n            }\n            return exitDie(error);\n        }\n    }\n    getCont(symbol) {\n        while(true){\n            const op = this._stack.pop();\n            if (!op) return undefined;\n            const cont = op[ensureCont] && op[ensureCont](this);\n            if (cont) return {\n                [symbol]: cont\n            };\n            if (op[symbol]) return op;\n        }\n    }\n    yieldWith(value) {\n        this._yielded = value;\n        return Yield;\n    }\n    children() {\n        return this._children ??= new Set();\n    }\n}\nconst fiberMiddleware = /*#__PURE__*/ (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_5__.globalValue)(\"effect/Micro/fiberMiddleware\", ()=>({\n        interruptChildren: undefined\n    }));\nconst fiberInterruptChildren = (fiber)=>{\n    if (fiber._children === undefined || fiber._children.size === 0) {\n        return undefined;\n    }\n    return fiberInterruptAll(fiber._children);\n};\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */ const fiberAwait = (self)=>async((resume)=>sync(self.addObserver((exit)=>resume(succeed(exit)))));\n/**\n * @since 3.11.2\n * @experimental\n * @category MicroFiber\n */ const fiberJoin = (self)=>flatten(fiberAwait(self));\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */ const fiberInterrupt = (self)=>suspend(()=>{\n        self.unsafeInterrupt();\n        return asVoid(fiberAwait(self));\n    });\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */ const fiberInterruptAll = (fibers)=>suspend(()=>{\n        for (const fiber of fibers)fiber.unsafeInterrupt();\n        const iter = fibers[Symbol.iterator]();\n        const wait = suspend(()=>{\n            let result = iter.next();\n            while(!result.done){\n                if (result.value.unsafePoll()) {\n                    result = iter.next();\n                    continue;\n                }\n                const fiber = result.value;\n                return async((resume)=>{\n                    fiber.addObserver((_)=>{\n                        resume(wait);\n                    });\n                });\n            }\n            return exitVoid;\n        });\n        return wait;\n    });\nconst identifier = /*#__PURE__*/ Symbol.for(\"effect/Micro/identifier\");\nconst args = /*#__PURE__*/ Symbol.for(\"effect/Micro/args\");\nconst evaluate = /*#__PURE__*/ Symbol.for(\"effect/Micro/evaluate\");\nconst successCont = /*#__PURE__*/ Symbol.for(\"effect/Micro/successCont\");\nconst failureCont = /*#__PURE__*/ Symbol.for(\"effect/Micro/failureCont\");\nconst ensureCont = /*#__PURE__*/ Symbol.for(\"effect/Micro/ensureCont\");\nconst Yield = /*#__PURE__*/ Symbol.for(\"effect/Micro/Yield\");\nconst microVariance = {\n    _A: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    _E: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity,\n    _R: _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity\n};\nconst MicroProto = {\n    ..._Effectable_js__WEBPACK_IMPORTED_MODULE_6__.EffectPrototype,\n    _op: \"Micro\",\n    [TypeId]: microVariance,\n    pipe () {\n        return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_3__.pipeArguments)(this, arguments);\n    },\n    [Symbol.iterator] () {\n        return new _Utils_js__WEBPACK_IMPORTED_MODULE_7__.SingleShotGen(new _Utils_js__WEBPACK_IMPORTED_MODULE_7__.YieldWrap(this));\n    },\n    toJSON () {\n        return {\n            _id: \"Micro\",\n            op: this[identifier],\n            ...args in this ? {\n                args: this[args]\n            } : undefined\n        };\n    },\n    toString () {\n        return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.format)(this);\n    },\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.NodeInspectSymbol] () {\n        return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.format)(this);\n    }\n};\nfunction defaultEvaluate(_fiber) {\n    return exitDie(`Micro.evaluate: Not implemented`);\n}\nconst makePrimitiveProto = (options)=>({\n        ...MicroProto,\n        [identifier]: options.op,\n        [evaluate]: options.eval ?? defaultEvaluate,\n        [successCont]: options.contA,\n        [failureCont]: options.contE,\n        [ensureCont]: options.ensure\n    });\nconst makePrimitive = (options)=>{\n    const Proto = makePrimitiveProto(options);\n    return function() {\n        const self = Object.create(Proto);\n        self[args] = options.single === false ? arguments : arguments[0];\n        return self;\n    };\n};\nconst makeExit = (options)=>{\n    const Proto = {\n        ...makePrimitiveProto(options),\n        [MicroExitTypeId]: MicroExitTypeId,\n        _tag: options.op,\n        get [options.prop] () {\n            return this[args];\n        },\n        toJSON () {\n            return {\n                _id: \"MicroExit\",\n                _tag: options.op,\n                [options.prop]: this[args]\n            };\n        },\n        [_Equal_js__WEBPACK_IMPORTED_MODULE_8__.symbol] (that) {\n            return isMicroExit(that) && that._tag === options.op && _Equal_js__WEBPACK_IMPORTED_MODULE_8__.equals(this[args], that[args]);\n        },\n        [_Hash_js__WEBPACK_IMPORTED_MODULE_9__.symbol] () {\n            return _Hash_js__WEBPACK_IMPORTED_MODULE_9__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_9__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_9__.string(options.op))(_Hash_js__WEBPACK_IMPORTED_MODULE_9__.hash(this[args])));\n        }\n    };\n    return function(value) {\n        const self = Object.create(Proto);\n        self[args] = value;\n        self[successCont] = undefined;\n        self[failureCont] = undefined;\n        self[ensureCont] = undefined;\n        return self;\n    };\n};\n/**\n * Creates a `Micro` effect that will succeed with the specified constant value.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const succeed = /*#__PURE__*/ makeExit({\n    op: \"Success\",\n    prop: \"value\",\n    eval (fiber) {\n        const cont = fiber.getCont(successCont);\n        return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);\n    }\n});\n/**\n * Creates a `Micro` effect that will fail with the specified `MicroCause`.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */ const failCause = /*#__PURE__*/ makeExit({\n    op: \"Failure\",\n    prop: \"cause\",\n    eval (fiber) {\n        let cont = fiber.getCont(failureCont);\n        while(causeIsInterrupt(this[args]) && cont && fiber.interruptible){\n            cont = fiber.getCont(failureCont);\n        }\n        return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);\n    }\n});\n/**\n * Creates a `Micro` effect that fails with the given error.\n *\n * This results in a `Fail` variant of the `MicroCause` type, where the error is\n * tracked at the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const fail = (error)=>failCause(causeFail(error));\n/**\n * Creates a `Micro` effect that succeeds with a lazily evaluated value.\n *\n * If the evaluation of the value throws an error, the effect will fail with a\n * `Die` variant of the `MicroCause` type.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const sync = /*#__PURE__*/ makePrimitive({\n    op: \"Sync\",\n    eval (fiber) {\n        const value = this[args]();\n        const cont = fiber.getCont(successCont);\n        return cont ? cont[successCont](value, fiber) : fiber.yieldWith(exitSucceed(value));\n    }\n});\n/**\n * Lazily creates a `Micro` effect from the given side-effect.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const suspend = /*#__PURE__*/ makePrimitive({\n    op: \"Suspend\",\n    eval (_fiber) {\n        return this[args]();\n    }\n});\n/**\n * Pause the execution of the current `Micro` effect, and resume it on the next\n * scheduler tick.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const yieldNowWith = /*#__PURE__*/ makePrimitive({\n    op: \"Yield\",\n    eval (fiber) {\n        let resumed = false;\n        fiber.getRef(CurrentScheduler).scheduleTask(()=>{\n            if (resumed) return;\n            fiber.evaluate(exitVoid);\n        }, this[args] ?? 0);\n        return fiber.yieldWith(()=>{\n            resumed = true;\n        });\n    }\n});\n/**\n * Pause the execution of the current `Micro` effect, and resume it on the next\n * scheduler tick.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const yieldNow = /*#__PURE__*/ yieldNowWith(0);\n/**\n * Creates a `Micro` effect that will succeed with the value wrapped in `Some`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const succeedSome = (a)=>succeed(_Option_js__WEBPACK_IMPORTED_MODULE_10__.some(a));\n/**\n * Creates a `Micro` effect that succeeds with `None`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const succeedNone = /*#__PURE__*/ succeed(/*#__PURE__*/ _Option_js__WEBPACK_IMPORTED_MODULE_10__.none());\n/**\n * Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const failCauseSync = (evaluate)=>suspend(()=>failCause(evaluate()));\n/**\n * Creates a `Micro` effect that will die with the specified error.\n *\n * This results in a `Die` variant of the `MicroCause` type, where the error is\n * not tracked at the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const die = (defect)=>exitDie(defect);\n/**\n * Creates a `Micro` effect that will fail with the lazily evaluated error.\n *\n * This results in a `Fail` variant of the `MicroCause` type, where the error is\n * tracked at the type level.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */ const failSync = (error)=>suspend(()=>fail(error()));\n/**\n * Converts an `Option` into a `Micro` effect, that will fail with\n * `NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the\n * value of the option.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const fromOption = (option)=>option._tag === \"Some\" ? succeed(option.value) : fail(new NoSuchElementException({}));\n/**\n * Converts an `Either` into a `Micro` effect, that will fail with the left side\n * of the either if it is a `Left`. Otherwise, it will succeed with the right\n * side of the either.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const fromEither = (either)=>either._tag === \"Right\" ? succeed(either.right) : fail(either.left);\nconst void_ = /*#__PURE__*/ succeed(void 0);\n\nconst try_ = (options)=>suspend(()=>{\n        try {\n            return succeed(options.try());\n        } catch (err) {\n            return fail(options.catch(err));\n        }\n    });\n\n/**\n * Wrap a `Promise` into a `Micro` effect.\n *\n * Any errors will result in a `Die` variant of the `MicroCause` type, where the\n * error is not tracked at the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const promise = (evaluate)=>asyncOptions(function(resume, signal) {\n        evaluate(signal).then((a)=>resume(succeed(a)), (e)=>resume(die(e)));\n    }, evaluate.length !== 0);\n/**\n * Wrap a `Promise` into a `Micro` effect. Any errors will be caught and\n * converted into a specific error type.\n *\n * @example\n * ```ts\n * import { Micro } from \"effect\"\n *\n * Micro.tryPromise({\n *   try: () => Promise.resolve(\"success\"),\n *   catch: (cause) => new Error(\"caught\", { cause })\n * })\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const tryPromise = (options)=>asyncOptions(function(resume, signal) {\n        try {\n            options.try(signal).then((a)=>resume(succeed(a)), (e)=>resume(fail(options.catch(e))));\n        } catch (err) {\n            resume(fail(options.catch(err)));\n        }\n    }, options.try.length !== 0);\n/**\n * Create a `Micro` effect using the current `MicroFiber`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const withMicroFiber = /*#__PURE__*/ makePrimitive({\n    op: \"WithMicroFiber\",\n    eval (fiber) {\n        return this[args](fiber);\n    }\n});\n/**\n * Flush any yielded effects that are waiting to be executed.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const yieldFlush = /*#__PURE__*/ withMicroFiber((fiber)=>{\n    fiber.getRef(CurrentScheduler).flush();\n    return exitVoid;\n});\nconst asyncOptions = /*#__PURE__*/ makePrimitive({\n    op: \"Async\",\n    single: false,\n    eval (fiber) {\n        const register = this[args][0];\n        let resumed = false;\n        let yielded = false;\n        const controller = this[args][1] ? new AbortController() : undefined;\n        const onCancel = register((effect)=>{\n            if (resumed) return;\n            resumed = true;\n            if (yielded) {\n                fiber.evaluate(effect);\n            } else {\n                yielded = effect;\n            }\n        }, controller?.signal);\n        if (yielded !== false) return yielded;\n        yielded = true;\n        fiber._yielded = ()=>{\n            resumed = true;\n        };\n        if (controller === undefined && onCancel === undefined) {\n            return Yield;\n        }\n        fiber._stack.push(asyncFinalizer(()=>{\n            resumed = true;\n            controller?.abort();\n            return onCancel ?? exitVoid;\n        }));\n        return Yield;\n    }\n});\nconst asyncFinalizer = /*#__PURE__*/ makePrimitive({\n    op: \"AsyncFinalizer\",\n    ensure (fiber) {\n        if (fiber.interruptible) {\n            fiber.interruptible = false;\n            fiber._stack.push(setInterruptible(true));\n        }\n    },\n    contE (cause, _fiber) {\n        return causeIsInterrupt(cause) ? flatMap(this[args](), ()=>failCause(cause)) : failCause(cause);\n    }\n});\n/**\n * Create a `Micro` effect from an asynchronous computation.\n *\n * You can return a cleanup effect that will be run when the effect is aborted.\n * It is also passed an `AbortSignal` that is triggered when the effect is\n * aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const async = (register)=>asyncOptions(register, register.length >= 2);\n/**\n * A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent\n * the Javascript runtime from exiting.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const never = /*#__PURE__*/ async(function() {\n    const interval = setInterval(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constVoid, 2147483646);\n    return sync(()=>clearInterval(interval));\n});\n/**\n * @since 3.4.0\n * @experimental\n * @category constructors\n */ const gen = (...args)=>suspend(()=>fromIterator(args.length === 1 ? args[0]() : args[1].call(args[0])));\nconst fromIterator = /*#__PURE__*/ makePrimitive({\n    op: \"Iterator\",\n    contA (value, fiber) {\n        const state = this[args].next(value);\n        if (state.done) return succeed(state.value);\n        fiber._stack.push(this);\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_7__.yieldWrapGet)(state.value);\n    },\n    eval (fiber) {\n        return this[successCont](undefined, fiber);\n    }\n});\n// ----------------------------------------------------------------------------\n// mapping & sequencing\n// ----------------------------------------------------------------------------\n/**\n * Create a `Micro` effect that will replace the success value of the given\n * effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const as = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, value)=>map(self, (_)=>value));\n/**\n * Wrap the success value of this `Micro` effect in a `Some`.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const asSome = (self)=>map(self, _Option_js__WEBPACK_IMPORTED_MODULE_10__.some);\n/**\n * Swap the error and success types of the `Micro` effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const flip = (self)=>matchEffect(self, {\n        onFailure: succeed,\n        onSuccess: fail\n    });\n/**\n * A more flexible version of `flatMap` that combines `map` and `flatMap` into a\n * single API.\n *\n * It also lets you directly pass a `Micro` effect, which will be executed after\n * the current effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const andThen = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>flatMap(self, (a)=>{\n        const value = isMicro(f) ? f : typeof f === \"function\" ? f(a) : f;\n        return isMicro(value) ? value : succeed(value);\n    }));\n/**\n * Execute a side effect from the success value of the `Micro` effect.\n *\n * It is similar to the `andThen` api, but the success value is ignored.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const tap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>flatMap(self, (a)=>{\n        const value = isMicro(f) ? f : typeof f === \"function\" ? f(a) : f;\n        return isMicro(value) ? as(value, a) : succeed(a);\n    }));\n/**\n * Replace the success value of the `Micro` effect with `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const asVoid = (self)=>flatMap(self, (_)=>exitVoid);\n/**\n * Access the `MicroExit` of the given `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category mapping & sequencing\n */ const exit = (self)=>matchCause(self, {\n        onFailure: exitFailCause,\n        onSuccess: exitSucceed\n    });\n/**\n * Replace the error type of the given `Micro` with the full `MicroCause` object.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const sandbox = (self)=>catchAllCause(self, fail);\n/**\n * Returns an effect that races all the specified effects,\n * yielding the value of the first effect to succeed with a value. Losers of\n * the race will be interrupted immediately\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */ const raceAll = (all)=>withMicroFiber((parent)=>async((resume)=>{\n            const effects = _Array_js__WEBPACK_IMPORTED_MODULE_11__.fromIterable(all);\n            const len = effects.length;\n            let doneCount = 0;\n            let done = false;\n            const fibers = new Set();\n            const causes = [];\n            const onExit = (exit)=>{\n                doneCount++;\n                if (exit._tag === \"Failure\") {\n                    causes.push(exit.cause);\n                    if (doneCount >= len) {\n                        resume(failCause(causes[0]));\n                    }\n                    return;\n                }\n                done = true;\n                resume(fibers.size === 0 ? exit : flatMap(uninterruptible(fiberInterruptAll(fibers)), ()=>exit));\n            };\n            for(let i = 0; i < len; i++){\n                if (done) break;\n                const fiber = unsafeFork(parent, interruptible(effects[i]), true, true);\n                fibers.add(fiber);\n                fiber.addObserver((exit)=>{\n                    fibers.delete(fiber);\n                    onExit(exit);\n                });\n            }\n            return fiberInterruptAll(fibers);\n        }));\n/**\n * Returns an effect that races all the specified effects,\n * yielding the value of the first effect to succeed or fail. Losers of\n * the race will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */ const raceAllFirst = (all)=>withMicroFiber((parent)=>async((resume)=>{\n            let done = false;\n            const fibers = new Set();\n            const onExit = (exit)=>{\n                done = true;\n                resume(fibers.size === 0 ? exit : flatMap(fiberInterruptAll(fibers), ()=>exit));\n            };\n            for (const effect of all){\n                if (done) break;\n                const fiber = unsafeFork(parent, interruptible(effect), true, true);\n                fibers.add(fiber);\n                fiber.addObserver((exit)=>{\n                    fibers.delete(fiber);\n                    onExit(exit);\n                });\n            }\n            return fiberInterruptAll(fibers);\n        }));\n/**\n * Returns an effect that races two effects, yielding the value of the first\n * effect to succeed. Losers of the race will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */ const race = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>raceAll([\n        self,\n        that\n    ]));\n/**\n * Returns an effect that races two effects, yielding the value of the first\n * effect to succeed *or* fail. Losers of the race will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */ const raceFirst = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>raceAllFirst([\n        self,\n        that\n    ]));\n/**\n * Map the success value of this `Micro` effect to another `Micro` effect, then\n * flatten the result.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const flatMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>{\n    const onSuccess = Object.create(OnSuccessProto);\n    onSuccess[args] = self;\n    onSuccess[successCont] = f;\n    return onSuccess;\n});\nconst OnSuccessProto = /*#__PURE__*/ makePrimitiveProto({\n    op: \"OnSuccess\",\n    eval (fiber) {\n        fiber._stack.push(this);\n        return this[args];\n    }\n});\n// ----------------------------------------------------------------------------\n// mapping & sequencing\n// ----------------------------------------------------------------------------\n/**\n * Flattens any nested `Micro` effects, merging the error and requirement types.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const flatten = (self)=>flatMap(self, _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n/**\n * Transforms the success value of the `Micro` effect with the specified\n * function.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>flatMap(self, (a)=>succeed(f(a))));\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const isMicroExit = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(u, MicroExitTypeId);\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitSucceed = succeed;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitFailCause = failCause;\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitInterrupt = /*#__PURE__*/ exitFailCause(/*#__PURE__*/ causeInterrupt());\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitFail = (e)=>exitFailCause(causeFail(e));\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitDie = (defect)=>exitFailCause(causeDie(defect));\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitIsSuccess = (self)=>self._tag === \"Success\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitIsFailure = (self)=>self._tag === \"Failure\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitIsInterrupt = (self)=>exitIsFailure(self) && self.cause._tag === \"Interrupt\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitIsFail = (self)=>exitIsFailure(self) && self.cause._tag === \"Fail\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitIsDie = (self)=>exitIsFailure(self) && self.cause._tag === \"Die\";\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */ const exitVoid = /*#__PURE__*/ exitSucceed(void 0);\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroExit\n */ const exitVoidAll = (exits)=>{\n    for (const exit of exits){\n        if (exit._tag === \"Failure\") {\n            return exit;\n        }\n    }\n    return exitVoid;\n};\nconst setImmediate = \"setImmediate\" in globalThis ? globalThis.setImmediate : (f)=>setTimeout(f, 0);\n/**\n * @since 3.5.9\n * @experimental\n * @category scheduler\n */ class MicroSchedulerDefault {\n    /**\n   * @since 3.5.9\n   */ scheduleTask(task, _priority) {\n        this.tasks.push(task);\n        if (!this.running) {\n            this.running = true;\n            setImmediate(this.afterScheduled);\n        }\n    }\n    /**\n   * @since 3.5.9\n   */ runTasks() {\n        const tasks = this.tasks;\n        this.tasks = [];\n        for(let i = 0, len = tasks.length; i < len; i++){\n            tasks[i]();\n        }\n    }\n    /**\n   * @since 3.5.9\n   */ shouldYield(fiber) {\n        return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);\n    }\n    /**\n   * @since 3.5.9\n   */ flush() {\n        while(this.tasks.length > 0){\n            this.runTasks();\n        }\n    }\n    constructor(){\n        this.tasks = [];\n        this.running = false;\n        /**\n   * @since 3.5.9\n   */ this.afterScheduled = ()=>{\n            this.running = false;\n            this.runTasks();\n        };\n    }\n}\n/**\n * Access the given `Context.Tag` from the environment.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */ const service = (tag)=>withMicroFiber((fiber)=>succeed(_Context_js__WEBPACK_IMPORTED_MODULE_12__.unsafeGet(fiber.context, tag)));\n/**\n * Access the given `Context.Tag` from the environment, without tracking the\n * dependency at the type level.\n *\n * It will return an `Option` of the service, depending on whether it is\n * available in the environment or not.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */ const serviceOption = (tag)=>withMicroFiber((fiber)=>succeed(_Context_js__WEBPACK_IMPORTED_MODULE_12__.getOption(fiber.context, tag)));\n/**\n * Update the Context with the given mapping function.\n *\n * @since 3.11.0\n * @experimental\n * @category environment\n */ const updateContext = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>withMicroFiber((fiber)=>{\n        const prev = fiber.context;\n        fiber.context = f(prev);\n        return onExit(self, ()=>{\n            fiber.context = prev;\n            return void_;\n        });\n    }));\n/**\n * Update the service for the given `Context.Tag` in the environment.\n *\n * @since 3.11.0\n * @experimental\n * @category environment\n */ const updateService = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, tag, f)=>withMicroFiber((fiber)=>{\n        const prev = _Context_js__WEBPACK_IMPORTED_MODULE_12__.unsafeGet(fiber.context, tag);\n        fiber.context = _Context_js__WEBPACK_IMPORTED_MODULE_12__.add(fiber.context, tag, f(prev));\n        return onExit(self, ()=>{\n            fiber.context = _Context_js__WEBPACK_IMPORTED_MODULE_12__.add(fiber.context, tag, prev);\n            return void_;\n        });\n    }));\n/**\n * Access the current `Context` from the environment.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */ const context = ()=>getContext;\nconst getContext = /*#__PURE__*/ withMicroFiber((fiber)=>succeed(fiber.context));\n/**\n * Merge the given `Context` with the current context.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */ const provideContext = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, provided)=>updateContext(self, _Context_js__WEBPACK_IMPORTED_MODULE_12__.merge(provided)));\n/**\n * Add the provided service to the current context.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */ const provideService = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, tag, service)=>updateContext(self, _Context_js__WEBPACK_IMPORTED_MODULE_12__.add(tag, service)));\n/**\n * Create a service using the provided `Micro` effect, and add it to the\n * current context.\n *\n * @since 3.4.6\n * @experimental\n * @category environment\n */ const provideServiceEffect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, tag, acquire)=>flatMap(acquire, (service)=>provideService(self, tag, service)));\n// ========================================================================\n// References\n// ========================================================================\n/**\n * @since 3.11.0\n * @experimental\n * @category references\n */ class MaxOpsBeforeYield extends /*#__PURE__*/ _Context_js__WEBPACK_IMPORTED_MODULE_12__.Reference()(\"effect/Micro/currentMaxOpsBeforeYield\", {\n    defaultValue: ()=>2048\n}) {\n}\n/**\n * @since 3.11.0\n * @experimental\n * @category environment refs\n */ class CurrentConcurrency extends /*#__PURE__*/ _Context_js__WEBPACK_IMPORTED_MODULE_12__.Reference()(\"effect/Micro/currentConcurrency\", {\n    defaultValue: ()=>\"unbounded\"\n}) {\n}\n/**\n * @since 3.11.0\n * @experimental\n * @category environment refs\n */ class CurrentScheduler extends /*#__PURE__*/ _Context_js__WEBPACK_IMPORTED_MODULE_12__.Reference()(\"effect/Micro/currentScheduler\", {\n    defaultValue: ()=>new MicroSchedulerDefault()\n}) {\n}\n/**\n * If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\n * api to control the concurrency of that `Micro` when it is run.\n *\n * @example\n * ```ts\n * import * as Micro from \"effect/Micro\"\n *\n * Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n *   concurrency: \"inherit\"\n * }).pipe(\n *   Micro.withConcurrency(2) // use a concurrency of 2\n * )\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */ const withConcurrency = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, concurrency)=>provideService(self, CurrentConcurrency, concurrency));\n// ----------------------------------------------------------------------------\n// zipping\n// ----------------------------------------------------------------------------\n/**\n * Combine two `Micro` effects into a single effect that produces a tuple of\n * their results.\n *\n * @since 3.4.0\n * @experimental\n * @category zipping\n */ const zip = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[1]), (self, that, options)=>zipWith(self, that, (a, a2)=>[\n            a,\n            a2\n        ], options));\n/**\n * The `Micro.zipWith` function combines two `Micro` effects and allows you to\n * apply a function to the results of the combined effects, transforming them\n * into a single value.\n *\n * @since 3.4.3\n * @experimental\n * @category zipping\n */ const zipWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[1]), (self, that, f, options)=>options?.concurrent ? map(all([\n        self,\n        that\n    ], {\n        concurrency: 2\n    }), ([a, a2])=>f(a, a2)) : flatMap(self, (a)=>map(that, (a2)=>f(a, a2))));\n// ----------------------------------------------------------------------------\n// filtering & conditionals\n// ----------------------------------------------------------------------------\n/**\n * Filter the specified effect with the provided function, failing with specified\n * `MicroCause` if the predicate fails.\n *\n * In addition to the filtering capabilities discussed earlier, you have the option to further\n * refine and narrow down the type of the success channel by providing a\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */ const filterOrFailCause = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[0]), (self, refinement, orFailWith)=>flatMap(self, (a)=>refinement(a) ? succeed(a) : failCause(orFailWith(a))));\n/**\n * Filter the specified effect with the provided function, failing with specified\n * error if the predicate fails.\n *\n * In addition to the filtering capabilities discussed earlier, you have the option to further\n * refine and narrow down the type of the success channel by providing a\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */ const filterOrFail = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[0]), (self, refinement, orFailWith)=>flatMap(self, (a)=>refinement(a) ? succeed(a) : fail(orFailWith(a))));\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */ const when = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, condition)=>flatMap(isMicro(condition) ? condition : sync(condition), (pass)=>pass ? asSome(self) : succeedNone));\n// ----------------------------------------------------------------------------\n// repetition\n// ----------------------------------------------------------------------------\n/**\n * Repeat the given `Micro` using the provided options.\n *\n * The `while` predicate will be checked after each iteration, and can use the\n * fall `MicroExit` of the effect to determine if the repetition should continue.\n *\n * @since 3.4.6\n * @experimental\n * @category repetition\n */ const repeatExit = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options)=>suspend(()=>{\n        const startedAt = options.schedule ? Date.now() : 0;\n        let attempt = 0;\n        const loop = flatMap(exit(self), (exit)=>{\n            if (options.while !== undefined && !options.while(exit)) {\n                return exit;\n            } else if (options.times !== undefined && attempt >= options.times) {\n                return exit;\n            }\n            attempt++;\n            let delayEffect = yieldNow;\n            if (options.schedule !== undefined) {\n                const elapsed = Date.now() - startedAt;\n                const duration = options.schedule(attempt, elapsed);\n                if (_Option_js__WEBPACK_IMPORTED_MODULE_10__.isNone(duration)) {\n                    return exit;\n                }\n                delayEffect = sleep(duration.value);\n            }\n            return flatMap(delayEffect, ()=>loop);\n        });\n        return loop;\n    }));\n/**\n * Repeat the given `Micro` effect using the provided options. Only successful\n * results will be repeated.\n *\n * @since 3.4.0\n * @experimental\n * @category repetition\n */ const repeat = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[0]), (self, options)=>repeatExit(self, {\n        ...options,\n        while: (exit)=>exit._tag === \"Success\" && (options?.while === undefined || options.while(exit.value))\n    }));\n/**\n * Replicates the given effect `n` times.\n *\n * @since 3.11.0\n * @experimental\n * @category repetition\n */ const replicate = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, n)=>Array.from({\n        length: n\n    }, ()=>self));\n/**\n * Performs this effect the specified number of times and collects the\n * results.\n *\n * @since 3.11.0\n * @category repetition\n */ const replicateEffect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[0]), (self, n, options)=>all(replicate(self, n), options));\n/**\n * Repeat the given `Micro` effect forever, only stopping if the effect fails.\n *\n * @since 3.4.0\n * @experimental\n * @category repetition\n */ const forever = (self)=>repeat(self);\n/**\n * Create a `MicroSchedule` that will stop repeating after the specified number\n * of attempts.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleRecurs = (n)=>(attempt)=>attempt <= n ? _Option_js__WEBPACK_IMPORTED_MODULE_10__.some(0) : _Option_js__WEBPACK_IMPORTED_MODULE_10__.none();\n/**\n * Create a `MicroSchedule` that will generate a constant delay.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleSpaced = (millis)=>()=>_Option_js__WEBPACK_IMPORTED_MODULE_10__.some(millis);\n/**\n * Create a `MicroSchedule` that will generate a delay with an exponential backoff.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleExponential = (baseMillis, factor = 2)=>(attempt)=>_Option_js__WEBPACK_IMPORTED_MODULE_10__.some(Math.pow(factor, attempt) * baseMillis);\n/**\n * Returns a new `MicroSchedule` with an added calculated delay to each delay\n * returned by this schedule.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleAddDelay = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>(attempt, elapsed)=>_Option_js__WEBPACK_IMPORTED_MODULE_10__.map(self(attempt, elapsed), (duration)=>duration + f()));\n/**\n * Transform a `MicroSchedule` to one that will have a delay that will never exceed\n * the specified maximum.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleWithMaxDelay = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, max)=>(attempt, elapsed)=>_Option_js__WEBPACK_IMPORTED_MODULE_10__.map(self(attempt, elapsed), (duration)=>Math.min(duration, max)));\n/**\n * Transform a `MicroSchedule` to one that will stop repeating after the specified\n * amount of time.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleWithMaxElapsed = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, max)=>(attempt, elapsed)=>elapsed < max ? self(attempt, elapsed) : _Option_js__WEBPACK_IMPORTED_MODULE_10__.none());\n/**\n * Combines two `MicroSchedule`s, by recurring if either schedule wants to\n * recur, using the minimum of the two durations between recurrences.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleUnion = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>(attempt, elapsed)=>_Option_js__WEBPACK_IMPORTED_MODULE_10__.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2)=>Math.min(d1, d2)));\n/**\n * Combines two `MicroSchedule`s, by recurring only if both schedules want to\n * recur, using the maximum of the two durations between recurrences.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */ const scheduleIntersect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>(attempt, elapsed)=>_Option_js__WEBPACK_IMPORTED_MODULE_10__.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2)=>Math.max(d1, d2)));\n// ----------------------------------------------------------------------------\n// error handling\n// ----------------------------------------------------------------------------\n/**\n * Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\n * recover from any kind of cause.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const catchAllCause = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>{\n    const onFailure = Object.create(OnFailureProto);\n    onFailure[args] = self;\n    onFailure[failureCont] = f;\n    return onFailure;\n});\nconst OnFailureProto = /*#__PURE__*/ makePrimitiveProto({\n    op: \"OnFailure\",\n    eval (fiber) {\n        fiber._stack.push(this);\n        return this[args];\n    }\n});\n/**\n * Selectively catch a `MicroCause` object of the given `Micro` effect,\n * using the provided predicate to determine if the failure should be caught.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const catchCauseIf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, predicate, f)=>catchAllCause(self, (cause)=>predicate(cause) ? f(cause) : failCause(cause)));\n/**\n * Catch the error of the given `Micro` effect, allowing you to recover from it.\n *\n * It only catches expected errors.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const catchAll = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>catchCauseIf(self, causeIsFail, (cause)=>f(cause.error)));\n/**\n * Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const catchAllDefect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>catchCauseIf(self, causeIsDie, (die)=>f(die.defect)));\n/**\n * Perform a side effect using the full `MicroCause` object of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const tapErrorCause = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>tapErrorCauseIf(self, _Function_js__WEBPACK_IMPORTED_MODULE_1__.constTrue, f));\n/**\n * Perform a side effect using if a `MicroCause` object matches the specified\n * predicate.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const tapErrorCauseIf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, refinement, f)=>catchCauseIf(self, refinement, (cause)=>andThen(f(cause), failCause(cause))));\n/**\n * Perform a side effect from expected errors of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const tapError = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>tapErrorCauseIf(self, causeIsFail, (fail)=>f(fail.error)));\n/**\n * Perform a side effect from unexpected errors of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const tapDefect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>tapErrorCauseIf(self, causeIsDie, (die)=>f(die.defect)));\n/**\n * Catch any expected errors that match the specified predicate.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const catchIf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, predicate, f)=>catchCauseIf(self, (f)=>causeIsFail(f) && predicate(f.error), (fail)=>f(fail.error)));\n/**\n * Recovers from the specified tagged error.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const catchTag = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, k, f)=>catchIf(self, (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isTagged)(k), f));\n/**\n * Transform the full `MicroCause` object of the given `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */ const mapErrorCause = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>catchAllCause(self, (cause)=>failCause(f(cause))));\n/**\n * Transform any expected errors of the given `Micro` effect.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const mapError = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>catchAll(self, (error)=>fail(f(error))));\n/**\n * Elevate any expected errors of the given `Micro` effect to unexpected errors,\n * resulting in an error type of `never`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const orDie = (self)=>catchAll(self, die);\n/**\n * Recover from all errors by succeeding with the given value.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const orElseSucceed = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>catchAll(self, (_)=>sync(f)));\n/**\n * Ignore any expected errors of the given `Micro` effect, returning `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const ignore = (self)=>matchEffect(self, {\n        onFailure: (_)=>void_,\n        onSuccess: (_)=>void_\n    });\n/**\n * Ignore any expected errors of the given `Micro` effect, returning `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const ignoreLogged = (self)=>matchEffect(self, {\n        // eslint-disable-next-line no-console\n        onFailure: (error)=>sync(()=>console.error(error)),\n        onSuccess: (_)=>void_\n    });\n/**\n * Replace the success value of the given `Micro` effect with an `Option`,\n * wrapping the success value in `Some` and returning `None` if the effect fails\n * with an expected error.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const option = (self)=>match(self, {\n        onFailure: _Option_js__WEBPACK_IMPORTED_MODULE_10__.none,\n        onSuccess: _Option_js__WEBPACK_IMPORTED_MODULE_10__.some\n    });\n/**\n * Replace the success value of the given `Micro` effect with an `Either`,\n * wrapping the success value in `Right` and wrapping any expected errors with\n * a `Left`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const either = (self)=>match(self, {\n        onFailure: _Either_js__WEBPACK_IMPORTED_MODULE_13__.left,\n        onSuccess: _Either_js__WEBPACK_IMPORTED_MODULE_13__.right\n    });\n/**\n * Retry the given `Micro` effect using the provided options.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const retry = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)((args)=>isMicro(args[0]), (self, options)=>repeatExit(self, {\n        ...options,\n        while: (exit)=>exit._tag === \"Failure\" && exit.cause._tag === \"Fail\" && (options?.while === undefined || options.while(exit.cause.error))\n    }));\n/**\n * Add a stack trace to any failures that occur in the effect. The trace will be\n * added to the `traces` field of the `MicroCause` object.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */ const withTrace = function() {\n    const prevLimit = globalThis.Error.stackTraceLimit;\n    globalThis.Error.stackTraceLimit = 2;\n    const error = new globalThis.Error();\n    globalThis.Error.stackTraceLimit = prevLimit;\n    function generate(name, cause) {\n        const stack = error.stack;\n        if (!stack) {\n            return cause;\n        }\n        const line = stack.split(\"\\n\")[2]?.trim().replace(/^at /, \"\");\n        if (!line) {\n            return cause;\n        }\n        const lineMatch = line.match(/\\((.*)\\)$/);\n        return causeWithTrace(cause, `at ${name} (${lineMatch ? lineMatch[1] : line})`);\n    }\n    const f = (name)=>(self)=>onError(self, (cause)=>failCause(generate(name, cause)));\n    if (arguments.length === 2) {\n        return f(arguments[1])(arguments[0]);\n    }\n    return f(arguments[0]);\n};\n// ----------------------------------------------------------------------------\n// pattern matching\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */ const matchCauseEffect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options)=>{\n    const primitive = Object.create(OnSuccessAndFailureProto);\n    primitive[args] = self;\n    primitive[successCont] = options.onSuccess;\n    primitive[failureCont] = options.onFailure;\n    return primitive;\n});\nconst OnSuccessAndFailureProto = /*#__PURE__*/ makePrimitiveProto({\n    op: \"OnSuccessAndFailure\",\n    eval (fiber) {\n        fiber._stack.push(this);\n        return this[args];\n    }\n});\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */ const matchCause = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options)=>matchCauseEffect(self, {\n        onFailure: (cause)=>sync(()=>options.onFailure(cause)),\n        onSuccess: (value)=>sync(()=>options.onSuccess(value))\n    }));\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */ const matchEffect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options)=>matchCauseEffect(self, {\n        onFailure: (cause)=>cause._tag === \"Fail\" ? options.onFailure(cause.error) : failCause(cause),\n        onSuccess: options.onSuccess\n    }));\n/**\n * @since 3.4.0\n * @experimental\n * @category pattern matching\n */ const match = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options)=>matchEffect(self, {\n        onFailure: (error)=>sync(()=>options.onFailure(error)),\n        onSuccess: (value)=>sync(()=>options.onSuccess(value))\n    }));\n// ----------------------------------------------------------------------------\n// delays & timeouts\n// ----------------------------------------------------------------------------\n/**\n * Create a `Micro` effect that will sleep for the specified duration.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */ const sleep = (millis)=>async((resume)=>{\n        const timeout = setTimeout(()=>{\n            resume(void_);\n        }, millis);\n        return sync(()=>{\n            clearTimeout(timeout);\n        });\n    });\n/**\n * Returns an effect that will delay the execution of this effect by the\n * specified duration.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */ const delay = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, millis)=>andThen(sleep(millis), self));\n/**\n * Returns an effect that will timeout this effect, that will execute the\n * fallback effect if the timeout elapses before the effect has produced a value.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */ const timeoutOrElse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, options)=>raceFirst(self, andThen(interruptible(sleep(options.duration)), options.onTimeout)));\n/**\n * Returns an effect that will timeout this effect, that will fail with a\n * `TimeoutException` if the timeout elapses before the effect has produced a\n * value.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */ const timeout = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, millis)=>timeoutOrElse(self, {\n        duration: millis,\n        onTimeout: ()=>fail(new TimeoutException())\n    }));\n/**\n * Returns an effect that will timeout this effect, succeeding with a `None`\n * if the timeout elapses before the effect has produced a value; and `Some` of\n * the produced value otherwise.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */ const timeoutOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, millis)=>raceFirst(asSome(self), as(interruptible(sleep(millis)), _Option_js__WEBPACK_IMPORTED_MODULE_10__.none())));\n// ----------------------------------------------------------------------------\n// resources & finalization\n// ----------------------------------------------------------------------------\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const MicroScopeTypeId = /*#__PURE__*/ Symbol.for(\"effect/Micro/MicroScope\");\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const MicroScope = /*#__PURE__*/ _Context_js__WEBPACK_IMPORTED_MODULE_12__.GenericTag(\"effect/Micro/MicroScope\");\nclass MicroScopeImpl {\n    constructor(){\n        this.state = {\n            _tag: \"Open\",\n            finalizers: /*#__PURE__*/ new Set()\n        };\n        this[MicroScopeTypeId] = MicroScopeTypeId;\n    }\n    unsafeAddFinalizer(finalizer) {\n        if (this.state._tag === \"Open\") {\n            this.state.finalizers.add(finalizer);\n        }\n    }\n    addFinalizer(finalizer) {\n        return suspend(()=>{\n            if (this.state._tag === \"Open\") {\n                this.state.finalizers.add(finalizer);\n                return void_;\n            }\n            return finalizer(this.state.exit);\n        });\n    }\n    unsafeRemoveFinalizer(finalizer) {\n        if (this.state._tag === \"Open\") {\n            this.state.finalizers.delete(finalizer);\n        }\n    }\n    close(microExit) {\n        return suspend(()=>{\n            if (this.state._tag === \"Open\") {\n                const finalizers = Array.from(this.state.finalizers).reverse();\n                this.state = {\n                    _tag: \"Closed\",\n                    exit: microExit\n                };\n                return flatMap(forEach(finalizers, (finalizer)=>exit(finalizer(microExit))), exitVoidAll);\n            }\n            return void_;\n        });\n    }\n    get fork() {\n        return sync(()=>{\n            const newScope = new MicroScopeImpl();\n            if (this.state._tag === \"Closed\") {\n                newScope.state = this.state;\n                return newScope;\n            }\n            function fin(exit) {\n                return newScope.close(exit);\n            }\n            this.state.finalizers.add(fin);\n            newScope.unsafeAddFinalizer((_)=>sync(()=>this.unsafeRemoveFinalizer(fin)));\n            return newScope;\n        });\n    }\n}\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const scopeMake = /*#__PURE__*/ sync(()=>new MicroScopeImpl());\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const scopeUnsafeMake = ()=>new MicroScopeImpl();\n/**\n * Access the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const scope = /*#__PURE__*/ service(MicroScope);\n/**\n * Provide a `MicroScope` to an effect.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const provideScope = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, scope)=>provideService(self, MicroScope, scope));\n/**\n * Provide a `MicroScope` to the given effect, closing it after the effect has\n * finished executing.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const scoped = (self)=>suspend(()=>{\n        const scope = new MicroScopeImpl();\n        return onExit(provideService(self, MicroScope, scope), (exit)=>scope.close(exit));\n    });\n/**\n * Create a resource with a cleanup `Micro` effect, ensuring the cleanup is\n * executed when the `MicroScope` is closed.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const acquireRelease = (acquire, release)=>uninterruptible(flatMap(scope, (scope)=>tap(acquire, (a)=>scope.addFinalizer((exit)=>release(a, exit)))));\n/**\n * Add a finalizer to the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const addFinalizer = (finalizer)=>flatMap(scope, (scope)=>scope.addFinalizer(finalizer));\n/**\n * When the `Micro` effect is completed, run the given finalizer effect with the\n * `MicroExit` of the executed effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */ const onExit = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>uninterruptibleMask((restore)=>matchCauseEffect(restore(self), {\n            onFailure: (cause)=>flatMap(f(exitFailCause(cause)), ()=>failCause(cause)),\n            onSuccess: (a)=>flatMap(f(exitSucceed(a)), ()=>succeed(a))\n        })));\n/**\n * Regardless of the result of the this `Micro` effect, run the finalizer effect.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const ensuring = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, finalizer)=>onExit(self, (_)=>finalizer));\n/**\n * When the `Micro` effect is completed, run the given finalizer effect if it\n * matches the specified predicate.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */ const onExitIf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, refinement, f)=>onExit(self, (exit)=>refinement(exit) ? f(exit) : exitVoid));\n/**\n * When the `Micro` effect fails, run the given finalizer effect with the\n * `MicroCause` of the executed effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */ const onError = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>onExitIf(self, exitIsFailure, (exit)=>f(exit.cause)));\n/**\n * If this `Micro` effect is aborted, run the finalizer effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */ const onInterrupt = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, finalizer)=>onExitIf(self, exitIsInterrupt, (_)=>finalizer));\n/**\n * Acquire a resource, use it, and then release the resource when the `use`\n * effect has completed.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */ const acquireUseRelease = (acquire, use, release)=>uninterruptibleMask((restore)=>flatMap(acquire, (a)=>flatMap(exit(restore(use(a))), (exit)=>andThen(release(a, exit), exit))));\n// ----------------------------------------------------------------------------\n// interruption\n// ----------------------------------------------------------------------------\n/**\n * Abort the current `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category interruption\n */ const interrupt = /*#__PURE__*/ failCause(/*#__PURE__*/ causeInterrupt());\n/**\n * Flag the effect as uninterruptible, which means that when the effect is\n * interrupted, it will be allowed to continue running until completion.\n *\n * @since 3.4.0\n * @experimental\n * @category flags\n */ const uninterruptible = (self)=>withMicroFiber((fiber)=>{\n        if (!fiber.interruptible) return self;\n        fiber.interruptible = false;\n        fiber._stack.push(setInterruptible(true));\n        return self;\n    });\nconst setInterruptible = /*#__PURE__*/ makePrimitive({\n    op: \"SetInterruptible\",\n    ensure (fiber) {\n        fiber.interruptible = this[args];\n        if (fiber._interrupted && fiber.interruptible) {\n            return ()=>exitInterrupt;\n        }\n    }\n});\n/**\n * Flag the effect as interruptible, which means that when the effect is\n * interrupted, it will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category flags\n */ const interruptible = (self)=>withMicroFiber((fiber)=>{\n        if (fiber.interruptible) return self;\n        fiber.interruptible = true;\n        fiber._stack.push(setInterruptible(false));\n        if (fiber._interrupted) return exitInterrupt;\n        return self;\n    });\n/**\n * Wrap the given `Micro` effect in an uninterruptible region, preventing the\n * effect from being aborted.\n *\n * You can use the `restore` function to restore a `Micro` effect to the\n * interruptibility state before the `uninterruptibleMask` was applied.\n *\n * @example\n * ```ts\n * import * as Micro from \"effect/Micro\"\n *\n * Micro.uninterruptibleMask((restore) =>\n *   Micro.sleep(1000).pipe( // uninterruptible\n *     Micro.andThen(restore(Micro.sleep(1000))) // interruptible\n *   )\n * )\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category interruption\n */ const uninterruptibleMask = (f)=>withMicroFiber((fiber)=>{\n        if (!fiber.interruptible) return f(_Function_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n        fiber.interruptible = false;\n        fiber._stack.push(setInterruptible(true));\n        return f(interruptible);\n    });\n/**\n * Runs all the provided effects in sequence respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */ const all = (arg, options)=>{\n    if (Array.isArray(arg) || (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isIterable)(arg)) {\n        return forEach(arg, _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity, options);\n    } else if (options?.discard) {\n        return forEach(Object.values(arg), _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity, options);\n    }\n    return suspend(()=>{\n        const out = {};\n        return as(forEach(Object.entries(arg), ([key, effect])=>map(effect, (value)=>{\n                out[key] = value;\n            }), {\n            discard: true,\n            concurrency: options?.concurrency\n        }), out);\n    });\n};\n/**\n * @since 3.11.0\n * @experimental\n * @category collecting & elements\n */ const whileLoop = /*#__PURE__*/ makePrimitive({\n    op: \"While\",\n    contA (value, fiber) {\n        this[args].step(value);\n        if (this[args].while()) {\n            fiber._stack.push(this);\n            return this[args].body();\n        }\n        return exitVoid;\n    },\n    eval (fiber) {\n        if (this[args].while()) {\n            fiber._stack.push(this);\n            return this[args].body();\n        }\n        return exitVoid;\n    }\n});\n/**\n * For each element of the provided iterable, run the effect and collect the\n * results.\n *\n * If the `discard` option is set to `true`, the results will be discarded and\n * the effect will return `void`.\n *\n * The `concurrency` option can be set to control how many effects are run\n * concurrently. By default, the effects are run sequentially.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */ const forEach = (iterable, f, options)=>withMicroFiber((parent)=>{\n        const concurrencyOption = options?.concurrency === \"inherit\" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;\n        const concurrency = concurrencyOption === \"unbounded\" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);\n        const items = _Array_js__WEBPACK_IMPORTED_MODULE_11__.fromIterable(iterable);\n        let length = items.length;\n        if (length === 0) {\n            return options?.discard ? void_ : succeed([]);\n        }\n        const out = options?.discard ? undefined : new Array(length);\n        let index = 0;\n        if (concurrency === 1) {\n            return as(whileLoop({\n                while: ()=>index < items.length,\n                body: ()=>f(items[index], index),\n                step: out ? (b)=>out[index++] = b : (_)=>index++\n            }), out);\n        }\n        return async((resume)=>{\n            const fibers = new Set();\n            let result = undefined;\n            let inProgress = 0;\n            let doneCount = 0;\n            let pumping = false;\n            let interrupted = false;\n            function pump() {\n                pumping = true;\n                while(inProgress < concurrency && index < length){\n                    const currentIndex = index;\n                    const item = items[currentIndex];\n                    index++;\n                    inProgress++;\n                    try {\n                        const child = unsafeFork(parent, f(item, currentIndex), true, true);\n                        fibers.add(child);\n                        child.addObserver((exit)=>{\n                            fibers.delete(child);\n                            if (interrupted) {\n                                return;\n                            } else if (exit._tag === \"Failure\") {\n                                if (result === undefined) {\n                                    result = exit;\n                                    length = index;\n                                    fibers.forEach((fiber)=>fiber.unsafeInterrupt());\n                                }\n                            } else if (out !== undefined) {\n                                out[currentIndex] = exit.value;\n                            }\n                            doneCount++;\n                            inProgress--;\n                            if (doneCount === length) {\n                                resume(result ?? succeed(out));\n                            } else if (!pumping && inProgress < concurrency) {\n                                pump();\n                            }\n                        });\n                    } catch (err) {\n                        result = exitDie(err);\n                        length = index;\n                        fibers.forEach((fiber)=>fiber.unsafeInterrupt());\n                    }\n                }\n                pumping = false;\n            }\n            pump();\n            return suspend(()=>{\n                interrupted = true;\n                index = length;\n                return fiberInterruptAll(fibers);\n            });\n        });\n    });\n/**\n * Effectfully filter the elements of the provided iterable.\n *\n * Use the `concurrency` option to control how many elements are processed\n * concurrently.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */ const filter = (iterable, f, options)=>filterMap(iterable, (a)=>map(f(a), (pass)=>{\n            pass = options?.negate ? !pass : pass;\n            return pass ? _Option_js__WEBPACK_IMPORTED_MODULE_10__.some(a) : _Option_js__WEBPACK_IMPORTED_MODULE_10__.none();\n        }), options);\n/**\n * Effectfully filter the elements of the provided iterable.\n *\n * Use the `concurrency` option to control how many elements are processed\n * concurrently.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */ const filterMap = (iterable, f, options)=>suspend(()=>{\n        const out = [];\n        return as(forEach(iterable, (a)=>map(f(a), (o)=>{\n                if (o._tag === \"Some\") {\n                    out.push(o.value);\n                }\n            }), {\n            discard: true,\n            concurrency: options?.concurrency\n        }), out);\n    });\n// ----------------------------------------------------------------------------\n// do notation\n// ----------------------------------------------------------------------------\n/**\n * Start a do notation block.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */ const Do = /*#__PURE__*/ succeed({});\n/**\n * Bind the success value of this `Micro` effect to the provided name.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */ const bindTo = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_14__.bindTo(map);\n/**\n * Bind the success value of this `Micro` effect to the provided name.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */ const bind = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_14__.bind(map, flatMap);\nconst let_ = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_14__.let_(map);\n\n// ----------------------------------------------------------------------------\n// fibers & forking\n// ----------------------------------------------------------------------------\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * When the parent `Micro` finishes, this `Micro` will be aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */ const fork = (self)=>withMicroFiber((fiber)=>{\n        fiberMiddleware.interruptChildren ??= fiberInterruptChildren;\n        return succeed(unsafeFork(fiber, self));\n    });\nconst unsafeFork = (parent, effect, immediate = false, daemon = false)=>{\n    const child = new MicroFiberImpl(parent.context, parent.interruptible);\n    if (!daemon) {\n        parent.children().add(child);\n        child.addObserver(()=>parent.children().delete(child));\n    }\n    if (immediate) {\n        child.evaluate(effect);\n    } else {\n        parent.getRef(CurrentScheduler).scheduleTask(()=>child.evaluate(effect), 0);\n    }\n    return child;\n};\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * It will not be aborted when the parent `Micro` finishes.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */ const forkDaemon = (self)=>withMicroFiber((fiber)=>succeed(unsafeFork(fiber, self, false, true)));\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * The lifetime of the handle will be attached to the provided `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */ const forkIn = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, scope)=>uninterruptibleMask((restore)=>flatMap(scope.fork, (scope)=>tap(restore(forkDaemon(onExit(self, (exit)=>scope.close(exit)))), (fiber)=>scope.addFinalizer((_)=>fiberInterrupt(fiber))))));\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * The lifetime of the handle will be attached to the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */ const forkScoped = (self)=>flatMap(scope, (scope)=>forkIn(self, scope));\n// ----------------------------------------------------------------------------\n// execution\n// ----------------------------------------------------------------------------\n/**\n * Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,\n * or aborted.\n *\n * You can listen for the result by adding an observer using the handle's\n * `addObserver` method.\n *\n * @example\n * ```ts\n * import * as Micro from \"effect/Micro\"\n *\n * const handle = Micro.succeed(42).pipe(\n *   Micro.delay(1000),\n *   Micro.runFork\n * )\n *\n * handle.addObserver((exit) => {\n *   console.log(exit)\n * })\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */ const runFork = (effect, options)=>{\n    const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));\n    fiber.evaluate(effect);\n    if (options?.signal) {\n        if (options.signal.aborted) {\n            fiber.unsafeInterrupt();\n        } else {\n            const abort = ()=>fiber.unsafeInterrupt();\n            options.signal.addEventListener(\"abort\", abort, {\n                once: true\n            });\n            fiber.addObserver(()=>options.signal.removeEventListener(\"abort\", abort));\n        }\n    }\n    return fiber;\n};\n/**\n * Execute the `Micro` effect and return a `Promise` that resolves with the\n * `MicroExit` of the computation.\n *\n * @since 3.4.6\n * @experimental\n * @category execution\n */ const runPromiseExit = (effect, options)=>new Promise((resolve, _reject)=>{\n        const handle = runFork(effect, options);\n        handle.addObserver(resolve);\n    });\n/**\n * Execute the `Micro` effect and return a `Promise` that resolves with the\n * successful value of the computation.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */ const runPromise = (effect, options)=>runPromiseExit(effect, options).then((exit)=>{\n        if (exit._tag === \"Failure\") {\n            throw exit.cause;\n        }\n        return exit.value;\n    });\n/**\n * Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.\n *\n * If any asynchronous effects are encountered, the function will return a\n * `CauseDie` containing the `MicroFiber`.\n *\n * @since 3.4.6\n * @experimental\n * @category execution\n */ const runSyncExit = (effect)=>{\n    const scheduler = new MicroSchedulerDefault();\n    const fiber = runFork(effect, {\n        scheduler\n    });\n    scheduler.flush();\n    return fiber._exit ?? exitDie(fiber);\n};\n/**\n * Attempt to execute the `Micro` effect synchronously and return the success\n * value.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */ const runSync = (effect)=>{\n    const exit = runSyncExit(effect);\n    if (exit._tag === \"Failure\") throw exit.cause;\n    return exit.value;\n};\nconst YieldableError = /*#__PURE__*/ function() {\n    class YieldableError extends globalThis.Error {\n    }\n    Object.assign(YieldableError.prototype, MicroProto, _internal_effectable_js__WEBPACK_IMPORTED_MODULE_15__.StructuralPrototype, {\n        [identifier]: \"Failure\",\n        [evaluate] () {\n            return fail(this);\n        },\n        toString () {\n            return this.message ? `${this.name}: ${this.message}` : this.name;\n        },\n        toJSON () {\n            return {\n                ...this\n            };\n        },\n        [_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.NodeInspectSymbol] () {\n            const stack = this.stack;\n            if (stack) {\n                return `${this.toString()}\\n${stack.split(\"\\n\").slice(1).join(\"\\n\")}`;\n            }\n            return this.toString();\n        }\n    });\n    return YieldableError;\n}();\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */ const Error = /*#__PURE__*/ function() {\n    return class extends YieldableError {\n        constructor(args){\n            super();\n            if (args) {\n                Object.assign(this, args);\n            }\n        }\n    };\n}();\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */ const TaggedError = (tag)=>{\n    class Base extends Error {\n        constructor(...args){\n            super(...args);\n            this._tag = tag;\n        }\n    }\n    ;\n    Base.prototype.name = tag;\n    return Base;\n};\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 3.4.4\n * @experimental\n * @category errors\n */ class NoSuchElementException extends /*#__PURE__*/ TaggedError(\"NoSuchElementException\") {\n}\n/**\n * Represents a checked exception which occurs when a timeout occurs.\n *\n * @since 3.4.4\n * @experimental\n * @category errors\n */ class TimeoutException extends /*#__PURE__*/ TaggedError(\"TimeoutException\") {\n} //# sourceMappingURL=Micro.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL01pY3JvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ2lDO0FBQ007QUFDTTtBQUNSO0FBQ0Y7QUFDaUM7QUFDdEI7QUFDYjtBQUM0QztBQUNyQjtBQUNGO0FBQ1E7QUFDekI7QUFDUTtBQUNxQjtBQUNDO0FBQ3BFOzs7O0NBSUMsR0FDTSxNQUFNeUIsU0FBUyxXQUFXLEdBQUVDLE9BQU9DLEdBQUcsQ0FBQyxnQkFBZ0I7QUFDOUQ7Ozs7Q0FJQyxHQUNNLE1BQU1DLGtCQUFrQixXQUFXLEdBQUVGLE9BQU9DLEdBQUcsQ0FBQywwQkFBMEI7QUFDakY7Ozs7Q0FJQyxHQUNNLE1BQU1FLFVBQVVDLENBQUFBLElBQUssT0FBT0EsTUFBTSxZQUFZQSxNQUFNLFFBQVFMLFVBQVVLLEVBQUU7QUFDL0UsK0VBQStFO0FBQy9FLGFBQWE7QUFDYiwrRUFBK0U7QUFDL0U7Ozs7Q0FJQyxHQUNNLE1BQU1DLG1CQUFtQixXQUFXLEdBQUVMLE9BQU9DLEdBQUcsQ0FBQywyQkFBMkI7QUFDbkY7Ozs7Q0FJQyxHQUNNLE1BQU1LLGVBQWVDLENBQUFBLE9BQVFkLDBEQUFXQSxDQUFDYyxNQUFNRixrQkFBa0I7QUFDeEUsTUFBTUcscUJBQXFCO0lBQ3pCQyxJQUFJM0Isa0RBQVFBO0FBQ2Q7QUFDQSxNQUFNNEIsdUJBQXVCQyxXQUFXQyxLQUFLO0lBSTNDQyxZQUFZQyxJQUFJLEVBQUVDLGFBQWEsRUFBRUMsTUFBTSxDQUFFO1FBQ3ZDLE1BQU1DLFlBQVksQ0FBQyxXQUFX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SUFBSUEsT0FBTztnQkFDVCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNRLFFBQVEsR0FBRyxFQUFFLEVBQUVSLE1BQU1FLEtBQUssQ0FBQyxNQUFNRSxLQUFLLENBQUMsR0FBR0MsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN2RTtZQUNBLE9BQU8sSUFBSSxDQUFDRyxRQUFRO1FBQ3RCO0lBQ0Y7SUFDQSxPQUFPZ2E7QUFDVDtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNaGIsUUFBUSxXQUFXLEdBQUU7SUFDaEMsT0FBTyxjQUFjZ2I7UUFDbkIvYSxZQUFZNEcsSUFBSSxDQUFFO1lBQ2hCLEtBQUs7WUFDTCxJQUFJQSxNQUFNO2dCQUNSb0IsT0FBT2dULE1BQU0sQ0FBQyxJQUFJLEVBQUVwVTtZQUN0QjtRQUNGO0lBQ0Y7QUFDRixJQUFJO0FBQ0o7Ozs7Q0FJQyxHQUNNLE1BQU1zVSxjQUFjaE0sQ0FBQUE7SUFDekIsTUFBTWlNLGFBQWFwYjs7O2lCQUNqQkUsT0FBT2lQOztJQUNUOztJQUVBaU0sS0FBS0YsU0FBUyxDQUFDNWEsSUFBSSxHQUFHNk87SUFDdEIsT0FBT2lNO0FBQ1QsRUFBRTtBQUNGOzs7Ozs7O0NBT0MsR0FDTSxNQUFNdlIsK0JBQStCLFdBQVcsR0FBRXNSLFlBQVk7QUFBMkI7QUFDaEc7Ozs7OztDQU1DLEdBQ00sTUFBTXZGLHlCQUF5QixXQUFXLEdBQUV1RixZQUFZO0FBQXFCLEVBQ3BGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vTWljcm8uanM/YWQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgbGlnaHR3ZWlnaHQgYWx0ZXJuYXRpdmUgdG8gdGhlIGBFZmZlY3RgIGRhdGEgdHlwZSwgd2l0aCBhIHN1YnNldCBvZiB0aGUgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuaW1wb3J0ICogYXMgQXJyIGZyb20gXCIuL0FycmF5LmpzXCI7XG5pbXBvcnQgKiBhcyBDb250ZXh0IGZyb20gXCIuL0NvbnRleHQuanNcIjtcbmltcG9ydCAqIGFzIEVmZmVjdGFibGUgZnJvbSBcIi4vRWZmZWN0YWJsZS5qc1wiO1xuaW1wb3J0ICogYXMgRWl0aGVyIGZyb20gXCIuL0VpdGhlci5qc1wiO1xuaW1wb3J0ICogYXMgRXF1YWwgZnJvbSBcIi4vRXF1YWwuanNcIjtcbmltcG9ydCB7IGNvbnN0VHJ1ZSwgY29uc3RWb2lkLCBkdWFsLCBpZGVudGl0eSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCIuL0dsb2JhbFZhbHVlLmpzXCI7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gXCIuL0hhc2guanNcIjtcbmltcG9ydCB7IGZvcm1hdCwgTm9kZUluc3BlY3RTeW1ib2wsIHRvU3RyaW5nVW5rbm93biB9IGZyb20gXCIuL0luc3BlY3RhYmxlLmpzXCI7XG5pbXBvcnQgKiBhcyBJbnRlcm5hbENvbnRleHQgZnJvbSBcIi4vaW50ZXJuYWwvY29udGV4dC5qc1wiO1xuaW1wb3J0ICogYXMgZG9Ob3RhdGlvbiBmcm9tIFwiLi9pbnRlcm5hbC9kb05vdGF0aW9uLmpzXCI7XG5pbXBvcnQgeyBTdHJ1Y3R1cmFsUHJvdG90eXBlIH0gZnJvbSBcIi4vaW50ZXJuYWwvZWZmZWN0YWJsZS5qc1wiO1xuaW1wb3J0ICogYXMgT3B0aW9uIGZyb20gXCIuL09wdGlvbi5qc1wiO1xuaW1wb3J0IHsgcGlwZUFyZ3VtZW50cyB9IGZyb20gXCIuL1BpcGVhYmxlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNJdGVyYWJsZSwgaXNUYWdnZWQgfSBmcm9tIFwiLi9QcmVkaWNhdGUuanNcIjtcbmltcG9ydCB7IFNpbmdsZVNob3RHZW4sIFlpZWxkV3JhcCwgeWllbGRXcmFwR2V0IH0gZnJvbSBcIi4vVXRpbHMuanNcIjtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgdHlwZSBpZHNcbiAqL1xuZXhwb3J0IGNvbnN0IFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvXCIpO1xuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IE1pY3JvRXhpdFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL01pY3JvRXhpdFwiKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc01pY3JvID0gdSA9PiB0eXBlb2YgdSA9PT0gXCJvYmplY3RcIiAmJiB1ICE9PSBudWxsICYmIFR5cGVJZCBpbiB1O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTWljcm9DYXVzZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb0NhdXNlVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9DYXVzZVwiKTtcbi8qKlxuICogQHNpbmNlIDMuNi42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc01pY3JvQ2F1c2UgPSBzZWxmID0+IGhhc1Byb3BlcnR5KHNlbGYsIE1pY3JvQ2F1c2VUeXBlSWQpO1xuY29uc3QgbWljcm9DYXVzZVZhcmlhbmNlID0ge1xuICBfRTogaWRlbnRpdHlcbn07XG5jbGFzcyBNaWNyb0NhdXNlSW1wbCBleHRlbmRzIGdsb2JhbFRoaXMuRXJyb3Ige1xuICBfdGFnO1xuICB0cmFjZXM7XG4gIFtNaWNyb0NhdXNlVHlwZUlkXTtcbiAgY29uc3RydWN0b3IoX3RhZywgb3JpZ2luYWxFcnJvciwgdHJhY2VzKSB7XG4gICAgY29uc3QgY2F1c2VOYW1lID0gYE1pY3JvQ2F1c2UuJHtfdGFnfWA7XG4gICAgbGV0IG5hbWU7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgbGV0IHN0YWNrO1xuICAgIGlmIChvcmlnaW5hbEVycm9yIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvcikge1xuICAgICAgbmFtZSA9IGAoJHtjYXVzZU5hbWV9KSAke29yaWdpbmFsRXJyb3IubmFtZX1gO1xuICAgICAgbWVzc2FnZSA9IG9yaWdpbmFsRXJyb3IubWVzc2FnZTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuICAgICAgc3RhY2sgPSBvcmlnaW5hbEVycm9yLnN0YWNrID8gYCgke2NhdXNlTmFtZX0pICR7b3JpZ2luYWxFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgwLCBtZXNzYWdlTGluZXMgKyAzKS5qb2luKFwiXFxuXCIpfWAgOiBgJHtuYW1lfTogJHttZXNzYWdlfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBjYXVzZU5hbWU7XG4gICAgICBtZXNzYWdlID0gdG9TdHJpbmdVbmtub3duKG9yaWdpbmFsRXJyb3IsIDApO1xuICAgICAgc3RhY2sgPSBgJHtuYW1lfTogJHttZXNzYWdlfWA7XG4gICAgfVxuICAgIGlmICh0cmFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2sgKz0gYFxcbiAgICAke3RyYWNlcy5qb2luKFwiXFxuICAgIFwiKX1gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLl90YWcgPSBfdGFnO1xuICAgIHRoaXMudHJhY2VzID0gdHJhY2VzO1xuICAgIHRoaXNbTWljcm9DYXVzZVR5cGVJZF0gPSBtaWNyb0NhdXNlVmFyaWFuY2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gIH1cbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gcGlwZUFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrO1xuICB9XG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s7XG4gIH1cbn1cbmNsYXNzIEZhaWwgZXh0ZW5kcyBNaWNyb0NhdXNlSW1wbCB7XG4gIGVycm9yO1xuICBjb25zdHJ1Y3RvcihlcnJvciwgdHJhY2VzID0gW10pIHtcbiAgICBzdXBlcihcIkZhaWxcIiwgZXJyb3IsIHRyYWNlcyk7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICB9XG59XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvQ2F1c2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdXNlRmFpbCA9IChlcnJvciwgdHJhY2VzID0gW10pID0+IG5ldyBGYWlsKGVycm9yLCB0cmFjZXMpO1xuY2xhc3MgRGllIGV4dGVuZHMgTWljcm9DYXVzZUltcGwge1xuICBkZWZlY3Q7XG4gIGNvbnN0cnVjdG9yKGRlZmVjdCwgdHJhY2VzID0gW10pIHtcbiAgICBzdXBlcihcIkRpZVwiLCBkZWZlY3QsIHRyYWNlcyk7XG4gICAgdGhpcy5kZWZlY3QgPSBkZWZlY3Q7XG4gIH1cbn1cbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9DYXVzZVxuICovXG5leHBvcnQgY29uc3QgY2F1c2VEaWUgPSAoZGVmZWN0LCB0cmFjZXMgPSBbXSkgPT4gbmV3IERpZShkZWZlY3QsIHRyYWNlcyk7XG5jbGFzcyBJbnRlcnJ1cHQgZXh0ZW5kcyBNaWNyb0NhdXNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHRyYWNlcyA9IFtdKSB7XG4gICAgc3VwZXIoXCJJbnRlcnJ1cHRcIiwgXCJpbnRlcnJ1cHRlZFwiLCB0cmFjZXMpO1xuICB9XG59XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvQ2F1c2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdXNlSW50ZXJydXB0ID0gKHRyYWNlcyA9IFtdKSA9PiBuZXcgSW50ZXJydXB0KHRyYWNlcyk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvQ2F1c2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdXNlSXNGYWlsID0gc2VsZiA9PiBzZWxmLl90YWcgPT09IFwiRmFpbFwiO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXVzZUlzRGllID0gc2VsZiA9PiBzZWxmLl90YWcgPT09IFwiRGllXCI7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvQ2F1c2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdXNlSXNJbnRlcnJ1cHQgPSBzZWxmID0+IHNlbGYuX3RhZyA9PT0gXCJJbnRlcnJ1cHRcIjtcbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9DYXVzZVxuICovXG5leHBvcnQgY29uc3QgY2F1c2VTcXVhc2ggPSBzZWxmID0+IHNlbGYuX3RhZyA9PT0gXCJGYWlsXCIgPyBzZWxmLmVycm9yIDogc2VsZi5fdGFnID09PSBcIkRpZVwiID8gc2VsZi5kZWZlY3QgOiBzZWxmO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0NhdXNlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXVzZVdpdGhUcmFjZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0cmFjZSkgPT4ge1xuICBjb25zdCB0cmFjZXMgPSBbLi4uc2VsZi50cmFjZXMsIHRyYWNlXTtcbiAgc3dpdGNoIChzZWxmLl90YWcpIHtcbiAgICBjYXNlIFwiRGllXCI6XG4gICAgICByZXR1cm4gY2F1c2VEaWUoc2VsZi5kZWZlY3QsIHRyYWNlcyk7XG4gICAgY2FzZSBcIkludGVycnVwdFwiOlxuICAgICAgcmV0dXJuIGNhdXNlSW50ZXJydXB0KHRyYWNlcyk7XG4gICAgY2FzZSBcIkZhaWxcIjpcbiAgICAgIHJldHVybiBjYXVzZUZhaWwoc2VsZi5lcnJvciwgdHJhY2VzKTtcbiAgfVxufSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBNaWNyb0ZpYmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0ZpYmVyXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb0ZpYmVyVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9GaWJlclwiKTtcbmNvbnN0IGZpYmVyVmFyaWFuY2UgPSB7XG4gIF9BOiBpZGVudGl0eSxcbiAgX0U6IGlkZW50aXR5XG59O1xuY2xhc3MgTWljcm9GaWJlckltcGwge1xuICBjb250ZXh0O1xuICBpbnRlcnJ1cHRpYmxlO1xuICBbTWljcm9GaWJlclR5cGVJZF07XG4gIF9zdGFjayA9IFtdO1xuICBfb2JzZXJ2ZXJzID0gW107XG4gIF9leGl0O1xuICBfY2hpbGRyZW47XG4gIGN1cnJlbnRPcENvdW50ID0gMDtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJydXB0aWJsZSA9IHRydWUpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuaW50ZXJydXB0aWJsZSA9IGludGVycnVwdGlibGU7XG4gICAgdGhpc1tNaWNyb0ZpYmVyVHlwZUlkXSA9IGZpYmVyVmFyaWFuY2U7XG4gIH1cbiAgZ2V0UmVmKHJlZikge1xuICAgIHJldHVybiBJbnRlcm5hbENvbnRleHQudW5zYWZlR2V0UmVmZXJlbmNlKHRoaXMuY29udGV4dCwgcmVmKTtcbiAgfVxuICBhZGRPYnNlcnZlcihjYikge1xuICAgIGlmICh0aGlzLl9leGl0KSB7XG4gICAgICBjYih0aGlzLl9leGl0KTtcbiAgICAgIHJldHVybiBjb25zdFZvaWQ7XG4gICAgfVxuICAgIHRoaXMuX29ic2VydmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZihjYik7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF9pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICB1bnNhZmVJbnRlcnJ1cHQoKSB7XG4gICAgaWYgKHRoaXMuX2V4aXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmludGVycnVwdGlibGUpIHtcbiAgICAgIHRoaXMuZXZhbHVhdGUoZXhpdEludGVycnVwdCk7XG4gICAgfVxuICB9XG4gIHVuc2FmZVBvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4aXQ7XG4gIH1cbiAgZXZhbHVhdGUoZWZmZWN0KSB7XG4gICAgaWYgKHRoaXMuX2V4aXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3lpZWxkZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgeWllbGRlZCA9IHRoaXMuX3lpZWxkZWQ7XG4gICAgICB0aGlzLl95aWVsZGVkID0gdW5kZWZpbmVkO1xuICAgICAgeWllbGRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBleGl0ID0gdGhpcy5ydW5Mb29wKGVmZmVjdCk7XG4gICAgaWYgKGV4aXQgPT09IFlpZWxkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSBpbnRlcnJ1cHRDaGlsZHJlbiBtaWRkbHdhcmUgaXMgYWRkZWQgaW4gTWljcm8uZm9yaywgc28gaXQgY2FuIGJlXG4gICAgLy8gdHJlZS1zaGFrZW4gaWYgbm90IHVzZWRcbiAgICBjb25zdCBpbnRlcnJ1cHRDaGlsZHJlbiA9IGZpYmVyTWlkZGxld2FyZS5pbnRlcnJ1cHRDaGlsZHJlbiAmJiBmaWJlck1pZGRsZXdhcmUuaW50ZXJydXB0Q2hpbGRyZW4odGhpcyk7XG4gICAgaWYgKGludGVycnVwdENoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlKGZsYXRNYXAoaW50ZXJydXB0Q2hpbGRyZW4sICgpID0+IGV4aXQpKTtcbiAgICB9XG4gICAgdGhpcy5fZXhpdCA9IGV4aXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX29ic2VydmVyc1tpXShleGl0KTtcbiAgICB9XG4gICAgdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcnVuTG9vcChlZmZlY3QpIHtcbiAgICBsZXQgeWllbGRpbmcgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudCA9IGVmZmVjdDtcbiAgICB0aGlzLmN1cnJlbnRPcENvdW50ID0gMDtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50T3BDb3VudCsrO1xuICAgICAgICBpZiAoIXlpZWxkaW5nICYmIHRoaXMuZ2V0UmVmKEN1cnJlbnRTY2hlZHVsZXIpLnNob3VsZFlpZWxkKHRoaXMpKSB7XG4gICAgICAgICAgeWllbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBjdXJyZW50O1xuICAgICAgICAgIGN1cnJlbnQgPSBmbGF0TWFwKHlpZWxkTm93LCAoKSA9PiBwcmV2KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtldmFsdWF0ZV0odGhpcyk7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBZaWVsZCkge1xuICAgICAgICAgIGNvbnN0IHlpZWxkZWQgPSB0aGlzLl95aWVsZGVkO1xuICAgICAgICAgIGlmIChNaWNyb0V4aXRUeXBlSWQgaW4geWllbGRlZCkge1xuICAgICAgICAgICAgdGhpcy5feWllbGRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gWWllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFoYXNQcm9wZXJ0eShjdXJyZW50LCBldmFsdWF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXREaWUoYE1pY3JvRmliZXIucnVuTG9vcDogTm90IGEgdmFsaWQgZWZmZWN0OiAke1N0cmluZyhjdXJyZW50KX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGl0RGllKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q29udChzeW1ib2wpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qgb3AgPSB0aGlzLl9zdGFjay5wb3AoKTtcbiAgICAgIGlmICghb3ApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBjb250ID0gb3BbZW5zdXJlQ29udF0gJiYgb3BbZW5zdXJlQ29udF0odGhpcyk7XG4gICAgICBpZiAoY29udCkgcmV0dXJuIHtcbiAgICAgICAgW3N5bWJvbF06IGNvbnRcbiAgICAgIH07XG4gICAgICBpZiAob3Bbc3ltYm9sXSkgcmV0dXJuIG9wO1xuICAgIH1cbiAgfVxuICAvLyBjYW5jZWwgdGhlIHlpZWxkZWQgb3BlcmF0aW9uLCBvciBmb3IgdGhlIHlpZWxkZWQgZXhpdCB2YWx1ZVxuICBfeWllbGRlZCA9IHVuZGVmaW5lZDtcbiAgeWllbGRXaXRoKHZhbHVlKSB7XG4gICAgdGhpcy5feWllbGRlZCA9IHZhbHVlO1xuICAgIHJldHVybiBZaWVsZDtcbiAgfVxuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4gPz89IG5ldyBTZXQoKTtcbiAgfVxufVxuY29uc3QgZmliZXJNaWRkbGV3YXJlID0gLyojX19QVVJFX18qL2dsb2JhbFZhbHVlKFwiZWZmZWN0L01pY3JvL2ZpYmVyTWlkZGxld2FyZVwiLCAoKSA9PiAoe1xuICBpbnRlcnJ1cHRDaGlsZHJlbjogdW5kZWZpbmVkXG59KSk7XG5jb25zdCBmaWJlckludGVycnVwdENoaWxkcmVuID0gZmliZXIgPT4ge1xuICBpZiAoZmliZXIuX2NoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgZmliZXIuX2NoaWxkcmVuLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmaWJlckludGVycnVwdEFsbChmaWJlci5fY2hpbGRyZW4pO1xufTtcbi8qKlxuICogQHNpbmNlIDMuMTEuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRmliZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGZpYmVyQXdhaXQgPSBzZWxmID0+IGFzeW5jKHJlc3VtZSA9PiBzeW5jKHNlbGYuYWRkT2JzZXJ2ZXIoZXhpdCA9PiByZXN1bWUoc3VjY2VlZChleGl0KSkpKSk7XG4vKipcbiAqIEBzaW5jZSAzLjExLjJcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0ZpYmVyXG4gKi9cbmV4cG9ydCBjb25zdCBmaWJlckpvaW4gPSBzZWxmID0+IGZsYXR0ZW4oZmliZXJBd2FpdChzZWxmKSk7XG4vKipcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0ZpYmVyXG4gKi9cbmV4cG9ydCBjb25zdCBmaWJlckludGVycnVwdCA9IHNlbGYgPT4gc3VzcGVuZCgoKSA9PiB7XG4gIHNlbGYudW5zYWZlSW50ZXJydXB0KCk7XG4gIHJldHVybiBhc1ZvaWQoZmliZXJBd2FpdChzZWxmKSk7XG59KTtcbi8qKlxuICogQHNpbmNlIDMuMTEuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRmliZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGZpYmVySW50ZXJydXB0QWxsID0gZmliZXJzID0+IHN1c3BlbmQoKCkgPT4ge1xuICBmb3IgKGNvbnN0IGZpYmVyIG9mIGZpYmVycykgZmliZXIudW5zYWZlSW50ZXJydXB0KCk7XG4gIGNvbnN0IGl0ZXIgPSBmaWJlcnNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICBjb25zdCB3YWl0ID0gc3VzcGVuZCgoKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGl0ZXIubmV4dCgpO1xuICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgIGlmIChyZXN1bHQudmFsdWUudW5zYWZlUG9sbCgpKSB7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXIubmV4dCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpYmVyID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIGFzeW5jKHJlc3VtZSA9PiB7XG4gICAgICAgIGZpYmVyLmFkZE9ic2VydmVyKF8gPT4ge1xuICAgICAgICAgIHJlc3VtZSh3YWl0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXRWb2lkO1xuICB9KTtcbiAgcmV0dXJuIHdhaXQ7XG59KTtcbmNvbnN0IGlkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9pZGVudGlmaWVyXCIpO1xuY29uc3QgYXJncyA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL2FyZ3NcIik7XG5jb25zdCBldmFsdWF0ZSA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L01pY3JvL2V2YWx1YXRlXCIpO1xuY29uc3Qgc3VjY2Vzc0NvbnQgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9NaWNyby9zdWNjZXNzQ29udFwiKTtcbmNvbnN0IGZhaWx1cmVDb250ID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vZmFpbHVyZUNvbnRcIik7XG5jb25zdCBlbnN1cmVDb250ID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vZW5zdXJlQ29udFwiKTtcbmNvbnN0IFlpZWxkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vWWllbGRcIik7XG5jb25zdCBtaWNyb1ZhcmlhbmNlID0ge1xuICBfQTogaWRlbnRpdHksXG4gIF9FOiBpZGVudGl0eSxcbiAgX1I6IGlkZW50aXR5XG59O1xuY29uc3QgTWljcm9Qcm90byA9IHtcbiAgLi4uRWZmZWN0YWJsZS5FZmZlY3RQcm90b3R5cGUsXG4gIF9vcDogXCJNaWNyb1wiLFxuICBbVHlwZUlkXTogbWljcm9WYXJpYW5jZSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gcGlwZUFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IFNpbmdsZVNob3RHZW4obmV3IFlpZWxkV3JhcCh0aGlzKSk7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIk1pY3JvXCIsXG4gICAgICBvcDogdGhpc1tpZGVudGlmaWVyXSxcbiAgICAgIC4uLihhcmdzIGluIHRoaXMgPyB7XG4gICAgICAgIGFyZ3M6IHRoaXNbYXJnc11cbiAgICAgIH0gOiB1bmRlZmluZWQpXG4gICAgfTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzKTtcbiAgfSxcbiAgW05vZGVJbnNwZWN0U3ltYm9sXSgpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMpO1xuICB9XG59O1xuZnVuY3Rpb24gZGVmYXVsdEV2YWx1YXRlKF9maWJlcikge1xuICByZXR1cm4gZXhpdERpZShgTWljcm8uZXZhbHVhdGU6IE5vdCBpbXBsZW1lbnRlZGApO1xufVxuY29uc3QgbWFrZVByaW1pdGl2ZVByb3RvID0gb3B0aW9ucyA9PiAoe1xuICAuLi5NaWNyb1Byb3RvLFxuICBbaWRlbnRpZmllcl06IG9wdGlvbnMub3AsXG4gIFtldmFsdWF0ZV06IG9wdGlvbnMuZXZhbCA/PyBkZWZhdWx0RXZhbHVhdGUsXG4gIFtzdWNjZXNzQ29udF06IG9wdGlvbnMuY29udEEsXG4gIFtmYWlsdXJlQ29udF06IG9wdGlvbnMuY29udEUsXG4gIFtlbnN1cmVDb250XTogb3B0aW9ucy5lbnN1cmVcbn0pO1xuY29uc3QgbWFrZVByaW1pdGl2ZSA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCBQcm90byA9IG1ha2VQcmltaXRpdmVQcm90byhvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZWxmID0gT2JqZWN0LmNyZWF0ZShQcm90byk7XG4gICAgc2VsZlthcmdzXSA9IG9wdGlvbnMuc2luZ2xlID09PSBmYWxzZSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn07XG5jb25zdCBtYWtlRXhpdCA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCBQcm90byA9IHtcbiAgICAuLi5tYWtlUHJpbWl0aXZlUHJvdG8ob3B0aW9ucyksXG4gICAgW01pY3JvRXhpdFR5cGVJZF06IE1pY3JvRXhpdFR5cGVJZCxcbiAgICBfdGFnOiBvcHRpb25zLm9wLFxuICAgIGdldCBbb3B0aW9ucy5wcm9wXSgpIHtcbiAgICAgIHJldHVybiB0aGlzW2FyZ3NdO1xuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2lkOiBcIk1pY3JvRXhpdFwiLFxuICAgICAgICBfdGFnOiBvcHRpb25zLm9wLFxuICAgICAgICBbb3B0aW9ucy5wcm9wXTogdGhpc1thcmdzXVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICAgIHJldHVybiBpc01pY3JvRXhpdCh0aGF0KSAmJiB0aGF0Ll90YWcgPT09IG9wdGlvbnMub3AgJiYgRXF1YWwuZXF1YWxzKHRoaXNbYXJnc10sIHRoYXRbYXJnc10pO1xuICAgIH0sXG4gICAgW0hhc2guc3ltYm9sXSgpIHtcbiAgICAgIHJldHVybiBIYXNoLmNhY2hlZCh0aGlzLCBIYXNoLmNvbWJpbmUoSGFzaC5zdHJpbmcob3B0aW9ucy5vcCkpKEhhc2guaGFzaCh0aGlzW2FyZ3NdKSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGNvbnN0IHNlbGYgPSBPYmplY3QuY3JlYXRlKFByb3RvKTtcbiAgICBzZWxmW2FyZ3NdID0gdmFsdWU7XG4gICAgc2VsZltzdWNjZXNzQ29udF0gPSB1bmRlZmluZWQ7XG4gICAgc2VsZltmYWlsdXJlQ29udF0gPSB1bmRlZmluZWQ7XG4gICAgc2VsZltlbnN1cmVDb250XSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBgTWljcm9gIGVmZmVjdCB0aGF0IHdpbGwgc3VjY2VlZCB3aXRoIHRoZSBzcGVjaWZpZWQgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzdWNjZWVkID0gLyojX19QVVJFX18qL21ha2VFeGl0KHtcbiAgb3A6IFwiU3VjY2Vzc1wiLFxuICBwcm9wOiBcInZhbHVlXCIsXG4gIGV2YWwoZmliZXIpIHtcbiAgICBjb25zdCBjb250ID0gZmliZXIuZ2V0Q29udChzdWNjZXNzQ29udCk7XG4gICAgcmV0dXJuIGNvbnQgPyBjb250W3N1Y2Nlc3NDb250XSh0aGlzW2FyZ3NdLCBmaWJlcikgOiBmaWJlci55aWVsZFdpdGgodGhpcyk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgc3BlY2lmaWVkIGBNaWNyb0NhdXNlYC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZhaWxDYXVzZSA9IC8qI19fUFVSRV9fKi9tYWtlRXhpdCh7XG4gIG9wOiBcIkZhaWx1cmVcIixcbiAgcHJvcDogXCJjYXVzZVwiLFxuICBldmFsKGZpYmVyKSB7XG4gICAgbGV0IGNvbnQgPSBmaWJlci5nZXRDb250KGZhaWx1cmVDb250KTtcbiAgICB3aGlsZSAoY2F1c2VJc0ludGVycnVwdCh0aGlzW2FyZ3NdKSAmJiBjb250ICYmIGZpYmVyLmludGVycnVwdGlibGUpIHtcbiAgICAgIGNvbnQgPSBmaWJlci5nZXRDb250KGZhaWx1cmVDb250KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnQgPyBjb250W2ZhaWx1cmVDb250XSh0aGlzW2FyZ3NdLCBmaWJlcikgOiBmaWJlci55aWVsZFdpdGgodGhpcyk7XG4gIH1cbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCBmYWlscyB3aXRoIHRoZSBnaXZlbiBlcnJvci5cbiAqXG4gKiBUaGlzIHJlc3VsdHMgaW4gYSBgRmFpbGAgdmFyaWFudCBvZiB0aGUgYE1pY3JvQ2F1c2VgIHR5cGUsIHdoZXJlIHRoZSBlcnJvciBpc1xuICogdHJhY2tlZCBhdCB0aGUgdHlwZSBsZXZlbC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZhaWwgPSBlcnJvciA9PiBmYWlsQ2F1c2UoY2F1c2VGYWlsKGVycm9yKSk7XG4vKipcbiAqIENyZWF0ZXMgYSBgTWljcm9gIGVmZmVjdCB0aGF0IHN1Y2NlZWRzIHdpdGggYSBsYXppbHkgZXZhbHVhdGVkIHZhbHVlLlxuICpcbiAqIElmIHRoZSBldmFsdWF0aW9uIG9mIHRoZSB2YWx1ZSB0aHJvd3MgYW4gZXJyb3IsIHRoZSBlZmZlY3Qgd2lsbCBmYWlsIHdpdGggYVxuICogYERpZWAgdmFyaWFudCBvZiB0aGUgYE1pY3JvQ2F1c2VgIHR5cGUuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzeW5jID0gLyojX19QVVJFX18qL21ha2VQcmltaXRpdmUoe1xuICBvcDogXCJTeW5jXCIsXG4gIGV2YWwoZmliZXIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXNbYXJnc10oKTtcbiAgICBjb25zdCBjb250ID0gZmliZXIuZ2V0Q29udChzdWNjZXNzQ29udCk7XG4gICAgcmV0dXJuIGNvbnQgPyBjb250W3N1Y2Nlc3NDb250XSh2YWx1ZSwgZmliZXIpIDogZmliZXIueWllbGRXaXRoKGV4aXRTdWNjZWVkKHZhbHVlKSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBMYXppbHkgY3JlYXRlcyBhIGBNaWNyb2AgZWZmZWN0IGZyb20gdGhlIGdpdmVuIHNpZGUtZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3Qgc3VzcGVuZCA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlKHtcbiAgb3A6IFwiU3VzcGVuZFwiLFxuICBldmFsKF9maWJlcikge1xuICAgIHJldHVybiB0aGlzW2FyZ3NdKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBQYXVzZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjdXJyZW50IGBNaWNyb2AgZWZmZWN0LCBhbmQgcmVzdW1lIGl0IG9uIHRoZSBuZXh0XG4gKiBzY2hlZHVsZXIgdGljay5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHlpZWxkTm93V2l0aCA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlKHtcbiAgb3A6IFwiWWllbGRcIixcbiAgZXZhbChmaWJlcikge1xuICAgIGxldCByZXN1bWVkID0gZmFsc2U7XG4gICAgZmliZXIuZ2V0UmVmKEN1cnJlbnRTY2hlZHVsZXIpLnNjaGVkdWxlVGFzaygoKSA9PiB7XG4gICAgICBpZiAocmVzdW1lZCkgcmV0dXJuO1xuICAgICAgZmliZXIuZXZhbHVhdGUoZXhpdFZvaWQpO1xuICAgIH0sIHRoaXNbYXJnc10gPz8gMCk7XG4gICAgcmV0dXJuIGZpYmVyLnlpZWxkV2l0aCgoKSA9PiB7XG4gICAgICByZXN1bWVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxufSk7XG4vKipcbiAqIFBhdXNlIHRoZSBleGVjdXRpb24gb2YgdGhlIGN1cnJlbnQgYE1pY3JvYCBlZmZlY3QsIGFuZCByZXN1bWUgaXQgb24gdGhlIG5leHRcbiAqIHNjaGVkdWxlciB0aWNrLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgeWllbGROb3cgPSAvKiNfX1BVUkVfXyoveWllbGROb3dXaXRoKDApO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIHN1Y2NlZWQgd2l0aCB0aGUgdmFsdWUgd3JhcHBlZCBpbiBgU29tZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBzdWNjZWVkU29tZSA9IGEgPT4gc3VjY2VlZChPcHRpb24uc29tZShhKSk7XG4vKipcbiAqIENyZWF0ZXMgYSBgTWljcm9gIGVmZmVjdCB0aGF0IHN1Y2NlZWRzIHdpdGggYE5vbmVgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3Qgc3VjY2VlZE5vbmUgPSAvKiNfX1BVUkVfXyovc3VjY2VlZCggLyojX19QVVJFX18qL09wdGlvbi5ub25lKCkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgbGF6aWx5IGV2YWx1YXRlZCBgTWljcm9DYXVzZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBmYWlsQ2F1c2VTeW5jID0gZXZhbHVhdGUgPT4gc3VzcGVuZCgoKSA9PiBmYWlsQ2F1c2UoZXZhbHVhdGUoKSkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGRpZSB3aXRoIHRoZSBzcGVjaWZpZWQgZXJyb3IuXG4gKlxuICogVGhpcyByZXN1bHRzIGluIGEgYERpZWAgdmFyaWFudCBvZiB0aGUgYE1pY3JvQ2F1c2VgIHR5cGUsIHdoZXJlIHRoZSBlcnJvciBpc1xuICogbm90IHRyYWNrZWQgYXQgdGhlIHR5cGUgbGV2ZWwuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBkaWUgPSBkZWZlY3QgPT4gZXhpdERpZShkZWZlY3QpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgbGF6aWx5IGV2YWx1YXRlZCBlcnJvci5cbiAqXG4gKiBUaGlzIHJlc3VsdHMgaW4gYSBgRmFpbGAgdmFyaWFudCBvZiB0aGUgYE1pY3JvQ2F1c2VgIHR5cGUsIHdoZXJlIHRoZSBlcnJvciBpc1xuICogdHJhY2tlZCBhdCB0aGUgdHlwZSBsZXZlbC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZhaWxTeW5jID0gZXJyb3IgPT4gc3VzcGVuZCgoKSA9PiBmYWlsKGVycm9yKCkpKTtcbi8qKlxuICogQ29udmVydHMgYW4gYE9wdGlvbmAgaW50byBhIGBNaWNyb2AgZWZmZWN0LCB0aGF0IHdpbGwgZmFpbCB3aXRoXG4gKiBgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbmAgaWYgdGhlIG9wdGlvbiBpcyBgTm9uZWAuIE90aGVyd2lzZSwgaXQgd2lsbCBzdWNjZWVkIHdpdGggdGhlXG4gKiB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgZnJvbU9wdGlvbiA9IG9wdGlvbiA9PiBvcHRpb24uX3RhZyA9PT0gXCJTb21lXCIgPyBzdWNjZWVkKG9wdGlvbi52YWx1ZSkgOiBmYWlsKG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKHt9KSk7XG4vKipcbiAqIENvbnZlcnRzIGFuIGBFaXRoZXJgIGludG8gYSBgTWljcm9gIGVmZmVjdCwgdGhhdCB3aWxsIGZhaWwgd2l0aCB0aGUgbGVmdCBzaWRlXG4gKiBvZiB0aGUgZWl0aGVyIGlmIGl0IGlzIGEgYExlZnRgLiBPdGhlcndpc2UsIGl0IHdpbGwgc3VjY2VlZCB3aXRoIHRoZSByaWdodFxuICogc2lkZSBvZiB0aGUgZWl0aGVyLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgZnJvbUVpdGhlciA9IGVpdGhlciA9PiBlaXRoZXIuX3RhZyA9PT0gXCJSaWdodFwiID8gc3VjY2VlZChlaXRoZXIucmlnaHQpIDogZmFpbChlaXRoZXIubGVmdCk7XG5jb25zdCB2b2lkXyA9IC8qI19fUFVSRV9fKi9zdWNjZWVkKHZvaWQgMCk7XG5leHBvcnQge1xuLyoqXG4gKiBBIGBNaWNyb2AgZWZmZWN0IHRoYXQgd2lsbCBzdWNjZWVkIHdpdGggYHZvaWRgIChgdW5kZWZpbmVkYCkuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbnZvaWRfIGFzIHZvaWQgfTtcbmNvbnN0IHRyeV8gPSBvcHRpb25zID0+IHN1c3BlbmQoKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBzdWNjZWVkKG9wdGlvbnMudHJ5KCkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFpbChvcHRpb25zLmNhdGNoKGVycikpO1xuICB9XG59KTtcbmV4cG9ydCB7XG4vKipcbiAqIFRoZSBgTWljcm9gIGVxdWl2YWxlbnQgb2YgYSB0cnkgLyBjYXRjaCBibG9jaywgd2hpY2ggYWxsb3dzIHlvdSB0byBtYXBcbiAqIHRocm93biBlcnJvcnMgdG8gYSBzcGVjaWZpYyBlcnJvciB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTWljcm8gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBNaWNyby50cnkoe1xuICogICB0cnk6ICgpID0+IHRocm93IG5ldyBFcnJvcihcImJvb21cIiksXG4gKiAgIGNhdGNoOiAoY2F1c2UpID0+IG5ldyBFcnJvcihcImNhdWdodFwiLCB7IGNhdXNlIH0pXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbnRyeV8gYXMgdHJ5IH07XG4vKipcbiAqIFdyYXAgYSBgUHJvbWlzZWAgaW50byBhIGBNaWNyb2AgZWZmZWN0LlxuICpcbiAqIEFueSBlcnJvcnMgd2lsbCByZXN1bHQgaW4gYSBgRGllYCB2YXJpYW50IG9mIHRoZSBgTWljcm9DYXVzZWAgdHlwZSwgd2hlcmUgdGhlXG4gKiBlcnJvciBpcyBub3QgdHJhY2tlZCBhdCB0aGUgdHlwZSBsZXZlbC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHByb21pc2UgPSBldmFsdWF0ZSA9PiBhc3luY09wdGlvbnMoZnVuY3Rpb24gKHJlc3VtZSwgc2lnbmFsKSB7XG4gIGV2YWx1YXRlKHNpZ25hbCkudGhlbihhID0+IHJlc3VtZShzdWNjZWVkKGEpKSwgZSA9PiByZXN1bWUoZGllKGUpKSk7XG59LCBldmFsdWF0ZS5sZW5ndGggIT09IDApO1xuLyoqXG4gKiBXcmFwIGEgYFByb21pc2VgIGludG8gYSBgTWljcm9gIGVmZmVjdC4gQW55IGVycm9ycyB3aWxsIGJlIGNhdWdodCBhbmRcbiAqIGNvbnZlcnRlZCBpbnRvIGEgc3BlY2lmaWMgZXJyb3IgdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE1pY3JvIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogTWljcm8udHJ5UHJvbWlzZSh7XG4gKiAgIHRyeTogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFwic3VjY2Vzc1wiKSxcbiAqICAgY2F0Y2g6IChjYXVzZSkgPT4gbmV3IEVycm9yKFwiY2F1Z2h0XCIsIHsgY2F1c2UgfSlcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyeVByb21pc2UgPSBvcHRpb25zID0+IGFzeW5jT3B0aW9ucyhmdW5jdGlvbiAocmVzdW1lLCBzaWduYWwpIHtcbiAgdHJ5IHtcbiAgICBvcHRpb25zLnRyeShzaWduYWwpLnRoZW4oYSA9PiByZXN1bWUoc3VjY2VlZChhKSksIGUgPT4gcmVzdW1lKGZhaWwob3B0aW9ucy5jYXRjaChlKSkpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmVzdW1lKGZhaWwob3B0aW9ucy5jYXRjaChlcnIpKSk7XG4gIH1cbn0sIG9wdGlvbnMudHJ5Lmxlbmd0aCAhPT0gMCk7XG4vKipcbiAqIENyZWF0ZSBhIGBNaWNyb2AgZWZmZWN0IHVzaW5nIHRoZSBjdXJyZW50IGBNaWNyb0ZpYmVyYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHdpdGhNaWNyb0ZpYmVyID0gLyojX19QVVJFX18qL21ha2VQcmltaXRpdmUoe1xuICBvcDogXCJXaXRoTWljcm9GaWJlclwiLFxuICBldmFsKGZpYmVyKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJnc10oZmliZXIpO1xuICB9XG59KTtcbi8qKlxuICogRmx1c2ggYW55IHlpZWxkZWQgZWZmZWN0cyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIGV4ZWN1dGVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgeWllbGRGbHVzaCA9IC8qI19fUFVSRV9fKi93aXRoTWljcm9GaWJlcihmaWJlciA9PiB7XG4gIGZpYmVyLmdldFJlZihDdXJyZW50U2NoZWR1bGVyKS5mbHVzaCgpO1xuICByZXR1cm4gZXhpdFZvaWQ7XG59KTtcbmNvbnN0IGFzeW5jT3B0aW9ucyA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlKHtcbiAgb3A6IFwiQXN5bmNcIixcbiAgc2luZ2xlOiBmYWxzZSxcbiAgZXZhbChmaWJlcikge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gdGhpc1thcmdzXVswXTtcbiAgICBsZXQgcmVzdW1lZCA9IGZhbHNlO1xuICAgIGxldCB5aWVsZGVkID0gZmFsc2U7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHRoaXNbYXJnc11bMV0gPyBuZXcgQWJvcnRDb250cm9sbGVyKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25DYW5jZWwgPSByZWdpc3RlcihlZmZlY3QgPT4ge1xuICAgICAgaWYgKHJlc3VtZWQpIHJldHVybjtcbiAgICAgIHJlc3VtZWQgPSB0cnVlO1xuICAgICAgaWYgKHlpZWxkZWQpIHtcbiAgICAgICAgZmliZXIuZXZhbHVhdGUoZWZmZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkZWQgPSBlZmZlY3Q7XG4gICAgICB9XG4gICAgfSwgY29udHJvbGxlcj8uc2lnbmFsKTtcbiAgICBpZiAoeWllbGRlZCAhPT0gZmFsc2UpIHJldHVybiB5aWVsZGVkO1xuICAgIHlpZWxkZWQgPSB0cnVlO1xuICAgIGZpYmVyLl95aWVsZGVkID0gKCkgPT4ge1xuICAgICAgcmVzdW1lZCA9IHRydWU7XG4gICAgfTtcbiAgICBpZiAoY29udHJvbGxlciA9PT0gdW5kZWZpbmVkICYmIG9uQ2FuY2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBZaWVsZDtcbiAgICB9XG4gICAgZmliZXIuX3N0YWNrLnB1c2goYXN5bmNGaW5hbGl6ZXIoKCkgPT4ge1xuICAgICAgcmVzdW1lZCA9IHRydWU7XG4gICAgICBjb250cm9sbGVyPy5hYm9ydCgpO1xuICAgICAgcmV0dXJuIG9uQ2FuY2VsID8/IGV4aXRWb2lkO1xuICAgIH0pKTtcbiAgICByZXR1cm4gWWllbGQ7XG4gIH1cbn0pO1xuY29uc3QgYXN5bmNGaW5hbGl6ZXIgPSAvKiNfX1BVUkVfXyovbWFrZVByaW1pdGl2ZSh7XG4gIG9wOiBcIkFzeW5jRmluYWxpemVyXCIsXG4gIGVuc3VyZShmaWJlcikge1xuICAgIGlmIChmaWJlci5pbnRlcnJ1cHRpYmxlKSB7XG4gICAgICBmaWJlci5pbnRlcnJ1cHRpYmxlID0gZmFsc2U7XG4gICAgICBmaWJlci5fc3RhY2sucHVzaChzZXRJbnRlcnJ1cHRpYmxlKHRydWUpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRFKGNhdXNlLCBfZmliZXIpIHtcbiAgICByZXR1cm4gY2F1c2VJc0ludGVycnVwdChjYXVzZSkgPyBmbGF0TWFwKHRoaXNbYXJnc10oKSwgKCkgPT4gZmFpbENhdXNlKGNhdXNlKSkgOiBmYWlsQ2F1c2UoY2F1c2UpO1xuICB9XG59KTtcbi8qKlxuICogQ3JlYXRlIGEgYE1pY3JvYCBlZmZlY3QgZnJvbSBhbiBhc3luY2hyb25vdXMgY29tcHV0YXRpb24uXG4gKlxuICogWW91IGNhbiByZXR1cm4gYSBjbGVhbnVwIGVmZmVjdCB0aGF0IHdpbGwgYmUgcnVuIHdoZW4gdGhlIGVmZmVjdCBpcyBhYm9ydGVkLlxuICogSXQgaXMgYWxzbyBwYXNzZWQgYW4gYEFib3J0U2lnbmFsYCB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBlZmZlY3QgaXNcbiAqIGFib3J0ZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBhc3luYyA9IHJlZ2lzdGVyID0+IGFzeW5jT3B0aW9ucyhyZWdpc3RlciwgcmVnaXN0ZXIubGVuZ3RoID49IDIpO1xuLyoqXG4gKiBBIGBNaWNyb2AgdGhhdCB3aWxsIG5ldmVyIHN1Y2NlZWQgb3IgZmFpbC4gSXQgd3JhcHMgYHNldEludGVydmFsYCB0byBwcmV2ZW50XG4gKiB0aGUgSmF2YXNjcmlwdCBydW50aW1lIGZyb20gZXhpdGluZy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IG5ldmVyID0gLyojX19QVVJFX18qL2FzeW5jKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjb25zdFZvaWQsIDIxNDc0ODM2NDYpO1xuICByZXR1cm4gc3luYygoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKSk7XG59KTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW4gPSAoLi4uYXJncykgPT4gc3VzcGVuZCgoKSA9PiBmcm9tSXRlcmF0b3IoYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdKCkgOiBhcmdzWzFdLmNhbGwoYXJnc1swXSkpKTtcbmNvbnN0IGZyb21JdGVyYXRvciA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlKHtcbiAgb3A6IFwiSXRlcmF0b3JcIixcbiAgY29udEEodmFsdWUsIGZpYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzW2FyZ3NdLm5leHQodmFsdWUpO1xuICAgIGlmIChzdGF0ZS5kb25lKSByZXR1cm4gc3VjY2VlZChzdGF0ZS52YWx1ZSk7XG4gICAgZmliZXIuX3N0YWNrLnB1c2godGhpcyk7XG4gICAgcmV0dXJuIHlpZWxkV3JhcEdldChzdGF0ZS52YWx1ZSk7XG4gIH0sXG4gIGV2YWwoZmliZXIpIHtcbiAgICByZXR1cm4gdGhpc1tzdWNjZXNzQ29udF0odW5kZWZpbmVkLCBmaWJlcik7XG4gIH1cbn0pO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbWFwcGluZyAmIHNlcXVlbmNpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQ3JlYXRlIGEgYE1pY3JvYCBlZmZlY3QgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhlIGdpdmVuXG4gKiBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFzID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHZhbHVlKSA9PiBtYXAoc2VsZiwgXyA9PiB2YWx1ZSkpO1xuLyoqXG4gKiBXcmFwIHRoZSBzdWNjZXNzIHZhbHVlIG9mIHRoaXMgYE1pY3JvYCBlZmZlY3QgaW4gYSBgU29tZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFzU29tZSA9IHNlbGYgPT4gbWFwKHNlbGYsIE9wdGlvbi5zb21lKTtcbi8qKlxuICogU3dhcCB0aGUgZXJyb3IgYW5kIHN1Y2Nlc3MgdHlwZXMgb2YgdGhlIGBNaWNyb2AgZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IG1hcHBpbmcgJiBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBmbGlwID0gc2VsZiA9PiBtYXRjaEVmZmVjdChzZWxmLCB7XG4gIG9uRmFpbHVyZTogc3VjY2VlZCxcbiAgb25TdWNjZXNzOiBmYWlsXG59KTtcbi8qKlxuICogQSBtb3JlIGZsZXhpYmxlIHZlcnNpb24gb2YgYGZsYXRNYXBgIHRoYXQgY29tYmluZXMgYG1hcGAgYW5kIGBmbGF0TWFwYCBpbnRvIGFcbiAqIHNpbmdsZSBBUEkuXG4gKlxuICogSXQgYWxzbyBsZXRzIHlvdSBkaXJlY3RseSBwYXNzIGEgYE1pY3JvYCBlZmZlY3QsIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXJcbiAqIHRoZSBjdXJyZW50IGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgYW5kVGhlbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBmbGF0TWFwKHNlbGYsIGEgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGlzTWljcm8oZikgPyBmIDogdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIiA/IGYoYSkgOiBmO1xuICByZXR1cm4gaXNNaWNybyh2YWx1ZSkgPyB2YWx1ZSA6IHN1Y2NlZWQodmFsdWUpO1xufSkpO1xuLyoqXG4gKiBFeGVjdXRlIGEgc2lkZSBlZmZlY3QgZnJvbSB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGUgYE1pY3JvYCBlZmZlY3QuXG4gKlxuICogSXQgaXMgc2ltaWxhciB0byB0aGUgYGFuZFRoZW5gIGFwaSwgYnV0IHRoZSBzdWNjZXNzIHZhbHVlIGlzIGlnbm9yZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbWFwcGluZyAmIHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBmbGF0TWFwKHNlbGYsIGEgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGlzTWljcm8oZikgPyBmIDogdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIiA/IGYoYSkgOiBmO1xuICByZXR1cm4gaXNNaWNybyh2YWx1ZSkgPyBhcyh2YWx1ZSwgYSkgOiBzdWNjZWVkKGEpO1xufSkpO1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBzdWNjZXNzIHZhbHVlIG9mIHRoZSBgTWljcm9gIGVmZmVjdCB3aXRoIGB2b2lkYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgYXNWb2lkID0gc2VsZiA9PiBmbGF0TWFwKHNlbGYsIF8gPT4gZXhpdFZvaWQpO1xuLyoqXG4gKiBBY2Nlc3MgdGhlIGBNaWNyb0V4aXRgIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgZXhpdCA9IHNlbGYgPT4gbWF0Y2hDYXVzZShzZWxmLCB7XG4gIG9uRmFpbHVyZTogZXhpdEZhaWxDYXVzZSxcbiAgb25TdWNjZXNzOiBleGl0U3VjY2VlZFxufSk7XG4vKipcbiAqIFJlcGxhY2UgdGhlIGVycm9yIHR5cGUgb2YgdGhlIGdpdmVuIGBNaWNyb2Agd2l0aCB0aGUgZnVsbCBgTWljcm9DYXVzZWAgb2JqZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IG1hcHBpbmcgJiBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzYW5kYm94ID0gc2VsZiA9PiBjYXRjaEFsbENhdXNlKHNlbGYsIGZhaWwpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHJhY2VzIGFsbCB0aGUgc3BlY2lmaWVkIGVmZmVjdHMsXG4gKiB5aWVsZGluZyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVmZmVjdCB0byBzdWNjZWVkIHdpdGggYSB2YWx1ZS4gTG9zZXJzIG9mXG4gKiB0aGUgcmFjZSB3aWxsIGJlIGludGVycnVwdGVkIGltbWVkaWF0ZWx5XG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgcmFjZUFsbCA9IGFsbCA9PiB3aXRoTWljcm9GaWJlcihwYXJlbnQgPT4gYXN5bmMocmVzdW1lID0+IHtcbiAgY29uc3QgZWZmZWN0cyA9IEFyci5mcm9tSXRlcmFibGUoYWxsKTtcbiAgY29uc3QgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG4gIGxldCBkb25lQ291bnQgPSAwO1xuICBsZXQgZG9uZSA9IGZhbHNlO1xuICBjb25zdCBmaWJlcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGNhdXNlcyA9IFtdO1xuICBjb25zdCBvbkV4aXQgPSBleGl0ID0+IHtcbiAgICBkb25lQ291bnQrKztcbiAgICBpZiAoZXhpdC5fdGFnID09PSBcIkZhaWx1cmVcIikge1xuICAgICAgY2F1c2VzLnB1c2goZXhpdC5jYXVzZSk7XG4gICAgICBpZiAoZG9uZUNvdW50ID49IGxlbikge1xuICAgICAgICByZXN1bWUoZmFpbENhdXNlKGNhdXNlc1swXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZXN1bWUoZmliZXJzLnNpemUgPT09IDAgPyBleGl0IDogZmxhdE1hcCh1bmludGVycnVwdGlibGUoZmliZXJJbnRlcnJ1cHRBbGwoZmliZXJzKSksICgpID0+IGV4aXQpKTtcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChkb25lKSBicmVhaztcbiAgICBjb25zdCBmaWJlciA9IHVuc2FmZUZvcmsocGFyZW50LCBpbnRlcnJ1cHRpYmxlKGVmZmVjdHNbaV0pLCB0cnVlLCB0cnVlKTtcbiAgICBmaWJlcnMuYWRkKGZpYmVyKTtcbiAgICBmaWJlci5hZGRPYnNlcnZlcihleGl0ID0+IHtcbiAgICAgIGZpYmVycy5kZWxldGUoZmliZXIpO1xuICAgICAgb25FeGl0KGV4aXQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmaWJlckludGVycnVwdEFsbChmaWJlcnMpO1xufSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHJhY2VzIGFsbCB0aGUgc3BlY2lmaWVkIGVmZmVjdHMsXG4gKiB5aWVsZGluZyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVmZmVjdCB0byBzdWNjZWVkIG9yIGZhaWwuIExvc2VycyBvZlxuICogdGhlIHJhY2Ugd2lsbCBiZSBpbnRlcnJ1cHRlZCBpbW1lZGlhdGVseS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByYWNlQWxsRmlyc3QgPSBhbGwgPT4gd2l0aE1pY3JvRmliZXIocGFyZW50ID0+IGFzeW5jKHJlc3VtZSA9PiB7XG4gIGxldCBkb25lID0gZmFsc2U7XG4gIGNvbnN0IGZpYmVycyA9IG5ldyBTZXQoKTtcbiAgY29uc3Qgb25FeGl0ID0gZXhpdCA9PiB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVzdW1lKGZpYmVycy5zaXplID09PSAwID8gZXhpdCA6IGZsYXRNYXAoZmliZXJJbnRlcnJ1cHRBbGwoZmliZXJzKSwgKCkgPT4gZXhpdCkpO1xuICB9O1xuICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBhbGwpIHtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgY29uc3QgZmliZXIgPSB1bnNhZmVGb3JrKHBhcmVudCwgaW50ZXJydXB0aWJsZShlZmZlY3QpLCB0cnVlLCB0cnVlKTtcbiAgICBmaWJlcnMuYWRkKGZpYmVyKTtcbiAgICBmaWJlci5hZGRPYnNlcnZlcihleGl0ID0+IHtcbiAgICAgIGZpYmVycy5kZWxldGUoZmliZXIpO1xuICAgICAgb25FeGl0KGV4aXQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmaWJlckludGVycnVwdEFsbChmaWJlcnMpO1xufSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHJhY2VzIHR3byBlZmZlY3RzLCB5aWVsZGluZyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0XG4gKiBlZmZlY3QgdG8gc3VjY2VlZC4gTG9zZXJzIG9mIHRoZSByYWNlIHdpbGwgYmUgaW50ZXJydXB0ZWQgaW1tZWRpYXRlbHkuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgcmFjZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiByYWNlQWxsKFtzZWxmLCB0aGF0XSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHJhY2VzIHR3byBlZmZlY3RzLCB5aWVsZGluZyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0XG4gKiBlZmZlY3QgdG8gc3VjY2VlZCAqb3IqIGZhaWwuIExvc2VycyBvZiB0aGUgcmFjZSB3aWxsIGJlIGludGVycnVwdGVkIGltbWVkaWF0ZWx5LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHJhY2VGaXJzdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiByYWNlQWxsRmlyc3QoW3NlbGYsIHRoYXRdKSk7XG4vKipcbiAqIE1hcCB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGlzIGBNaWNyb2AgZWZmZWN0IHRvIGFub3RoZXIgYE1pY3JvYCBlZmZlY3QsIHRoZW5cbiAqIGZsYXR0ZW4gdGhlIHJlc3VsdC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IG9uU3VjY2VzcyA9IE9iamVjdC5jcmVhdGUoT25TdWNjZXNzUHJvdG8pO1xuICBvblN1Y2Nlc3NbYXJnc10gPSBzZWxmO1xuICBvblN1Y2Nlc3Nbc3VjY2Vzc0NvbnRdID0gZjtcbiAgcmV0dXJuIG9uU3VjY2Vzcztcbn0pO1xuY29uc3QgT25TdWNjZXNzUHJvdG8gPSAvKiNfX1BVUkVfXyovbWFrZVByaW1pdGl2ZVByb3RvKHtcbiAgb3A6IFwiT25TdWNjZXNzXCIsXG4gIGV2YWwoZmliZXIpIHtcbiAgICBmaWJlci5fc3RhY2sucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gdGhpc1thcmdzXTtcbiAgfVxufSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBtYXBwaW5nICYgc2VxdWVuY2luZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBGbGF0dGVucyBhbnkgbmVzdGVkIGBNaWNyb2AgZWZmZWN0cywgbWVyZ2luZyB0aGUgZXJyb3IgYW5kIHJlcXVpcmVtZW50IHR5cGVzLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IG1hcHBpbmcgJiBzZXF1ZW5jaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gc2VsZiA9PiBmbGF0TWFwKHNlbGYsIGlkZW50aXR5KTtcbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGUgYE1pY3JvYCBlZmZlY3Qgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtYXBwaW5nICYgc2VxdWVuY2luZ1xuICovXG5leHBvcnQgY29uc3QgbWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiBzdWNjZWVkKGYoYSkpKSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgaXNNaWNyb0V4aXQgPSB1ID0+IGhhc1Byb3BlcnR5KHUsIE1pY3JvRXhpdFR5cGVJZCk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdFN1Y2NlZWQgPSBzdWNjZWVkO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRGYWlsQ2F1c2UgPSBmYWlsQ2F1c2U7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdEludGVycnVwdCA9IC8qI19fUFVSRV9fKi9leGl0RmFpbENhdXNlKCAvKiNfX1BVUkVfXyovY2F1c2VJbnRlcnJ1cHQoKSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdEZhaWwgPSBlID0+IGV4aXRGYWlsQ2F1c2UoY2F1c2VGYWlsKGUpKTtcbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9FeGl0XG4gKi9cbmV4cG9ydCBjb25zdCBleGl0RGllID0gZGVmZWN0ID0+IGV4aXRGYWlsQ2F1c2UoY2F1c2VEaWUoZGVmZWN0KSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdElzU3VjY2VzcyA9IHNlbGYgPT4gc2VsZi5fdGFnID09PSBcIlN1Y2Nlc3NcIjtcbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgTWljcm9FeGl0XG4gKi9cbmV4cG9ydCBjb25zdCBleGl0SXNGYWlsdXJlID0gc2VsZiA9PiBzZWxmLl90YWcgPT09IFwiRmFpbHVyZVwiO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRJc0ludGVycnVwdCA9IHNlbGYgPT4gZXhpdElzRmFpbHVyZShzZWxmKSAmJiBzZWxmLmNhdXNlLl90YWcgPT09IFwiSW50ZXJydXB0XCI7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdElzRmFpbCA9IHNlbGYgPT4gZXhpdElzRmFpbHVyZShzZWxmKSAmJiBzZWxmLmNhdXNlLl90YWcgPT09IFwiRmFpbFwiO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBNaWNyb0V4aXRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4aXRJc0RpZSA9IHNlbGYgPT4gZXhpdElzRmFpbHVyZShzZWxmKSAmJiBzZWxmLmNhdXNlLl90YWcgPT09IFwiRGllXCI7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdFZvaWQgPSAvKiNfX1BVUkVfXyovZXhpdFN1Y2NlZWQodm9pZCAwKTtcbi8qKlxuICogQHNpbmNlIDMuMTEuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IE1pY3JvRXhpdFxuICovXG5leHBvcnQgY29uc3QgZXhpdFZvaWRBbGwgPSBleGl0cyA9PiB7XG4gIGZvciAoY29uc3QgZXhpdCBvZiBleGl0cykge1xuICAgIGlmIChleGl0Ll90YWcgPT09IFwiRmFpbHVyZVwiKSB7XG4gICAgICByZXR1cm4gZXhpdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4aXRWb2lkO1xufTtcbmNvbnN0IHNldEltbWVkaWF0ZSA9IFwic2V0SW1tZWRpYXRlXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuc2V0SW1tZWRpYXRlIDogZiA9PiBzZXRUaW1lb3V0KGYsIDApO1xuLyoqXG4gKiBAc2luY2UgMy41LjlcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzY2hlZHVsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE1pY3JvU2NoZWR1bGVyRGVmYXVsdCB7XG4gIHRhc2tzID0gW107XG4gIHJ1bm5pbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEBzaW5jZSAzLjUuOVxuICAgKi9cbiAgc2NoZWR1bGVUYXNrKHRhc2ssIF9wcmlvcml0eSkge1xuICAgIHRoaXMudGFza3MucHVzaCh0YXNrKTtcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHNldEltbWVkaWF0ZSh0aGlzLmFmdGVyU2NoZWR1bGVkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAzLjUuOVxuICAgKi9cbiAgYWZ0ZXJTY2hlZHVsZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ydW5UYXNrcygpO1xuICB9O1xuICAvKipcbiAgICogQHNpbmNlIDMuNS45XG4gICAqL1xuICBydW5UYXNrcygpIHtcbiAgICBjb25zdCB0YXNrcyA9IHRoaXMudGFza3M7XG4gICAgdGhpcy50YXNrcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0YXNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFza3NbaV0oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAzLjUuOVxuICAgKi9cbiAgc2hvdWxkWWllbGQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIuY3VycmVudE9wQ291bnQgPj0gZmliZXIuZ2V0UmVmKE1heE9wc0JlZm9yZVlpZWxkKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDMuNS45XG4gICAqL1xuICBmbHVzaCgpIHtcbiAgICB3aGlsZSAodGhpcy50YXNrcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnJ1blRhc2tzKCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEFjY2VzcyB0aGUgZ2l2ZW4gYENvbnRleHQuVGFnYCBmcm9tIHRoZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgY29uc3Qgc2VydmljZSA9IHRhZyA9PiB3aXRoTWljcm9GaWJlcihmaWJlciA9PiBzdWNjZWVkKENvbnRleHQudW5zYWZlR2V0KGZpYmVyLmNvbnRleHQsIHRhZykpKTtcbi8qKlxuICogQWNjZXNzIHRoZSBnaXZlbiBgQ29udGV4dC5UYWdgIGZyb20gdGhlIGVudmlyb25tZW50LCB3aXRob3V0IHRyYWNraW5nIHRoZVxuICogZGVwZW5kZW5jeSBhdCB0aGUgdHlwZSBsZXZlbC5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBhbiBgT3B0aW9uYCBvZiB0aGUgc2VydmljZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXNcbiAqIGF2YWlsYWJsZSBpbiB0aGUgZW52aXJvbm1lbnQgb3Igbm90LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBzZXJ2aWNlT3B0aW9uID0gdGFnID0+IHdpdGhNaWNyb0ZpYmVyKGZpYmVyID0+IHN1Y2NlZWQoQ29udGV4dC5nZXRPcHRpb24oZmliZXIuY29udGV4dCwgdGFnKSkpO1xuLyoqXG4gKiBVcGRhdGUgdGhlIENvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gbWFwcGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xMS4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gd2l0aE1pY3JvRmliZXIoZmliZXIgPT4ge1xuICBjb25zdCBwcmV2ID0gZmliZXIuY29udGV4dDtcbiAgZmliZXIuY29udGV4dCA9IGYocHJldik7XG4gIHJldHVybiBvbkV4aXQoc2VsZiwgKCkgPT4ge1xuICAgIGZpYmVyLmNvbnRleHQgPSBwcmV2O1xuICAgIHJldHVybiB2b2lkXztcbiAgfSk7XG59KSk7XG4vKipcbiAqIFVwZGF0ZSB0aGUgc2VydmljZSBmb3IgdGhlIGdpdmVuIGBDb250ZXh0LlRhZ2AgaW4gdGhlIGVudmlyb25tZW50LlxuICpcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlU2VydmljZSA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCB0YWcsIGYpID0+IHdpdGhNaWNyb0ZpYmVyKGZpYmVyID0+IHtcbiAgY29uc3QgcHJldiA9IENvbnRleHQudW5zYWZlR2V0KGZpYmVyLmNvbnRleHQsIHRhZyk7XG4gIGZpYmVyLmNvbnRleHQgPSBDb250ZXh0LmFkZChmaWJlci5jb250ZXh0LCB0YWcsIGYocHJldikpO1xuICByZXR1cm4gb25FeGl0KHNlbGYsICgpID0+IHtcbiAgICBmaWJlci5jb250ZXh0ID0gQ29udGV4dC5hZGQoZmliZXIuY29udGV4dCwgdGFnLCBwcmV2KTtcbiAgICByZXR1cm4gdm9pZF87XG4gIH0pO1xufSkpO1xuLyoqXG4gKiBBY2Nlc3MgdGhlIGN1cnJlbnQgYENvbnRleHRgIGZyb20gdGhlIGVudmlyb25tZW50LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZXh0ID0gKCkgPT4gZ2V0Q29udGV4dDtcbmNvbnN0IGdldENvbnRleHQgPSAvKiNfX1BVUkVfXyovd2l0aE1pY3JvRmliZXIoZmliZXIgPT4gc3VjY2VlZChmaWJlci5jb250ZXh0KSk7XG4vKipcbiAqIE1lcmdlIHRoZSBnaXZlbiBgQ29udGV4dGAgd2l0aCB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBwcm92aWRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcm92aWRlZCkgPT4gdXBkYXRlQ29udGV4dChzZWxmLCBDb250ZXh0Lm1lcmdlKHByb3ZpZGVkKSkpO1xuLyoqXG4gKiBBZGQgdGhlIHByb3ZpZGVkIHNlcnZpY2UgdG8gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgY29uc3QgcHJvdmlkZVNlcnZpY2UgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGFnLCBzZXJ2aWNlKSA9PiB1cGRhdGVDb250ZXh0KHNlbGYsIENvbnRleHQuYWRkKHRhZywgc2VydmljZSkpKTtcbi8qKlxuICogQ3JlYXRlIGEgc2VydmljZSB1c2luZyB0aGUgcHJvdmlkZWQgYE1pY3JvYCBlZmZlY3QsIGFuZCBhZGQgaXQgdG8gdGhlXG4gKiBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHByb3ZpZGVTZXJ2aWNlRWZmZWN0ID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRhZywgYWNxdWlyZSkgPT4gZmxhdE1hcChhY3F1aXJlLCBzZXJ2aWNlID0+IHByb3ZpZGVTZXJ2aWNlKHNlbGYsIHRhZywgc2VydmljZSkpKTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUmVmZXJlbmNlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKipcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZWZlcmVuY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXhPcHNCZWZvcmVZaWVsZCBleHRlbmRzIC8qI19fUFVSRV9fKi9Db250ZXh0LlJlZmVyZW5jZSgpKFwiZWZmZWN0L01pY3JvL2N1cnJlbnRNYXhPcHNCZWZvcmVZaWVsZFwiLCB7XG4gIGRlZmF1bHRWYWx1ZTogKCkgPT4gMjA0OFxufSkge31cbi8qKlxuICogQHNpbmNlIDMuMTEuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50IHJlZnNcbiAqL1xuZXhwb3J0IGNsYXNzIEN1cnJlbnRDb25jdXJyZW5jeSBleHRlbmRzIC8qI19fUFVSRV9fKi9Db250ZXh0LlJlZmVyZW5jZSgpKFwiZWZmZWN0L01pY3JvL2N1cnJlbnRDb25jdXJyZW5jeVwiLCB7XG4gIGRlZmF1bHRWYWx1ZTogKCkgPT4gXCJ1bmJvdW5kZWRcIlxufSkge31cbi8qKlxuICogQHNpbmNlIDMuMTEuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVudmlyb25tZW50IHJlZnNcbiAqL1xuZXhwb3J0IGNsYXNzIEN1cnJlbnRTY2hlZHVsZXIgZXh0ZW5kcyAvKiNfX1BVUkVfXyovQ29udGV4dC5SZWZlcmVuY2UoKShcImVmZmVjdC9NaWNyby9jdXJyZW50U2NoZWR1bGVyXCIsIHtcbiAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgTWljcm9TY2hlZHVsZXJEZWZhdWx0KClcbn0pIHt9XG4vKipcbiAqIElmIHlvdSBoYXZlIGEgYE1pY3JvYCB0aGF0IHVzZXMgYGNvbmN1cnJlbmN5OiBcImluaGVyaXRcImAsIHlvdSBjYW4gdXNlIHRoaXNcbiAqIGFwaSB0byBjb250cm9sIHRoZSBjb25jdXJyZW5jeSBvZiB0aGF0IGBNaWNyb2Agd2hlbiBpdCBpcyBydW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgKiBhcyBNaWNybyBmcm9tIFwiZWZmZWN0L01pY3JvXCJcbiAqXG4gKiBNaWNyby5mb3JFYWNoKFsxLCAyLCAzXSwgKG4pID0+IE1pY3JvLnN1Y2NlZWQobiksIHtcbiAqICAgY29uY3VycmVuY3k6IFwiaW5oZXJpdFwiXG4gKiB9KS5waXBlKFxuICogICBNaWNyby53aXRoQ29uY3VycmVuY3koMikgLy8gdXNlIGEgY29uY3VycmVuY3kgb2YgMlxuICogKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZW52aXJvbm1lbnQgcmVmc1xuICovXG5leHBvcnQgY29uc3Qgd2l0aENvbmN1cnJlbmN5ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGNvbmN1cnJlbmN5KSA9PiBwcm92aWRlU2VydmljZShzZWxmLCBDdXJyZW50Q29uY3VycmVuY3ksIGNvbmN1cnJlbmN5KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB6aXBwaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIENvbWJpbmUgdHdvIGBNaWNyb2AgZWZmZWN0cyBpbnRvIGEgc2luZ2xlIGVmZmVjdCB0aGF0IHByb2R1Y2VzIGEgdHVwbGUgb2ZcbiAqIHRoZWlyIHJlc3VsdHMuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgemlwcGluZ1xuICovXG5leHBvcnQgY29uc3QgemlwID0gLyojX19QVVJFX18qL2R1YWwoYXJncyA9PiBpc01pY3JvKGFyZ3NbMV0pLCAoc2VsZiwgdGhhdCwgb3B0aW9ucykgPT4gemlwV2l0aChzZWxmLCB0aGF0LCAoYSwgYTIpID0+IFthLCBhMl0sIG9wdGlvbnMpKTtcbi8qKlxuICogVGhlIGBNaWNyby56aXBXaXRoYCBmdW5jdGlvbiBjb21iaW5lcyB0d28gYE1pY3JvYCBlZmZlY3RzIGFuZCBhbGxvd3MgeW91IHRvXG4gKiBhcHBseSBhIGZ1bmN0aW9uIHRvIHRoZSByZXN1bHRzIG9mIHRoZSBjb21iaW5lZCBlZmZlY3RzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICogaW50byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAc2luY2UgMy40LjNcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSB6aXBwaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB6aXBXaXRoID0gLyojX19QVVJFX18qL2R1YWwoYXJncyA9PiBpc01pY3JvKGFyZ3NbMV0pLCAoc2VsZiwgdGhhdCwgZiwgb3B0aW9ucykgPT4gb3B0aW9ucz8uY29uY3VycmVudFxuLy8gVXNlIGBhbGxgIGV4Y2x1c2l2ZWx5IGZvciBjb25jdXJyZW50IGNhc2VzLCBhcyBpdCBpbnRyb2R1Y2VzIGFkZGl0aW9uYWwgb3ZlcmhlYWQgZHVlIHRvIHRoZSBtYW5hZ2VtZW50IG9mIGNvbmN1cnJlbmN5XG4/IG1hcChhbGwoW3NlbGYsIHRoYXRdLCB7XG4gIGNvbmN1cnJlbmN5OiAyXG59KSwgKFthLCBhMl0pID0+IGYoYSwgYTIpKSA6IGZsYXRNYXAoc2VsZiwgYSA9PiBtYXAodGhhdCwgYTIgPT4gZihhLCBhMikpKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogRmlsdGVyIHRoZSBzcGVjaWZpZWQgZWZmZWN0IHdpdGggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCBmYWlsaW5nIHdpdGggc3BlY2lmaWVkXG4gKiBgTWljcm9DYXVzZWAgaWYgdGhlIHByZWRpY2F0ZSBmYWlscy5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgZmlsdGVyaW5nIGNhcGFiaWxpdGllcyBkaXNjdXNzZWQgZWFybGllciwgeW91IGhhdmUgdGhlIG9wdGlvbiB0byBmdXJ0aGVyXG4gKiByZWZpbmUgYW5kIG5hcnJvdyBkb3duIHRoZSB0eXBlIG9mIHRoZSBzdWNjZXNzIGNoYW5uZWwgYnkgcHJvdmlkaW5nIGFcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck9yRmFpbENhdXNlID0gLyojX19QVVJFX18qL2R1YWwoYXJncyA9PiBpc01pY3JvKGFyZ3NbMF0pLCAoc2VsZiwgcmVmaW5lbWVudCwgb3JGYWlsV2l0aCkgPT4gZmxhdE1hcChzZWxmLCBhID0+IHJlZmluZW1lbnQoYSkgPyBzdWNjZWVkKGEpIDogZmFpbENhdXNlKG9yRmFpbFdpdGgoYSkpKSk7XG4vKipcbiAqIEZpbHRlciB0aGUgc3BlY2lmaWVkIGVmZmVjdCB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgZmFpbGluZyB3aXRoIHNwZWNpZmllZFxuICogZXJyb3IgaWYgdGhlIHByZWRpY2F0ZSBmYWlscy5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgZmlsdGVyaW5nIGNhcGFiaWxpdGllcyBkaXNjdXNzZWQgZWFybGllciwgeW91IGhhdmUgdGhlIG9wdGlvbiB0byBmdXJ0aGVyXG4gKiByZWZpbmUgYW5kIG5hcnJvdyBkb3duIHRoZSB0eXBlIG9mIHRoZSBzdWNjZXNzIGNoYW5uZWwgYnkgcHJvdmlkaW5nIGFcbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmcgJiBjb25kaXRpb25hbHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck9yRmFpbCA9IC8qI19fUFVSRV9fKi9kdWFsKGFyZ3MgPT4gaXNNaWNybyhhcmdzWzBdKSwgKHNlbGYsIHJlZmluZW1lbnQsIG9yRmFpbFdpdGgpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiByZWZpbmVtZW50KGEpID8gc3VjY2VlZChhKSA6IGZhaWwob3JGYWlsV2l0aChhKSkpKTtcbi8qKlxuICogVGhlIG1vcmFsIGVxdWl2YWxlbnQgb2YgYGlmIChwKSBleHBgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGZpbHRlcmluZyAmIGNvbmRpdGlvbmFsc1xuICovXG5leHBvcnQgY29uc3Qgd2hlbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBjb25kaXRpb24pID0+IGZsYXRNYXAoaXNNaWNybyhjb25kaXRpb24pID8gY29uZGl0aW9uIDogc3luYyhjb25kaXRpb24pLCBwYXNzID0+IHBhc3MgPyBhc1NvbWUoc2VsZikgOiBzdWNjZWVkTm9uZSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmVwZXRpdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBSZXBlYXQgdGhlIGdpdmVuIGBNaWNyb2AgdXNpbmcgdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gKlxuICogVGhlIGB3aGlsZWAgcHJlZGljYXRlIHdpbGwgYmUgY2hlY2tlZCBhZnRlciBlYWNoIGl0ZXJhdGlvbiwgYW5kIGNhbiB1c2UgdGhlXG4gKiBmYWxsIGBNaWNyb0V4aXRgIG9mIHRoZSBlZmZlY3QgdG8gZGV0ZXJtaW5lIGlmIHRoZSByZXBldGl0aW9uIHNob3VsZCBjb250aW51ZS5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXBldGl0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZXBlYXRFeGl0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9wdGlvbnMpID0+IHN1c3BlbmQoKCkgPT4ge1xuICBjb25zdCBzdGFydGVkQXQgPSBvcHRpb25zLnNjaGVkdWxlID8gRGF0ZS5ub3coKSA6IDA7XG4gIGxldCBhdHRlbXB0ID0gMDtcbiAgY29uc3QgbG9vcCA9IGZsYXRNYXAoZXhpdChzZWxmKSwgZXhpdCA9PiB7XG4gICAgaWYgKG9wdGlvbnMud2hpbGUgIT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy53aGlsZShleGl0KSkge1xuICAgICAgcmV0dXJuIGV4aXQ7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnRpbWVzICE9PSB1bmRlZmluZWQgJiYgYXR0ZW1wdCA+PSBvcHRpb25zLnRpbWVzKSB7XG4gICAgICByZXR1cm4gZXhpdDtcbiAgICB9XG4gICAgYXR0ZW1wdCsrO1xuICAgIGxldCBkZWxheUVmZmVjdCA9IHlpZWxkTm93O1xuICAgIGlmIChvcHRpb25zLnNjaGVkdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gc3RhcnRlZEF0O1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBvcHRpb25zLnNjaGVkdWxlKGF0dGVtcHQsIGVsYXBzZWQpO1xuICAgICAgaWYgKE9wdGlvbi5pc05vbmUoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBleGl0O1xuICAgICAgfVxuICAgICAgZGVsYXlFZmZlY3QgPSBzbGVlcChkdXJhdGlvbi52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmbGF0TWFwKGRlbGF5RWZmZWN0LCAoKSA9PiBsb29wKTtcbiAgfSk7XG4gIHJldHVybiBsb29wO1xufSkpO1xuLyoqXG4gKiBSZXBlYXQgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0IHVzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zLiBPbmx5IHN1Y2Nlc3NmdWxcbiAqIHJlc3VsdHMgd2lsbCBiZSByZXBlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXBldGl0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZXBlYXQgPSAvKiNfX1BVUkVfXyovZHVhbChhcmdzID0+IGlzTWljcm8oYXJnc1swXSksIChzZWxmLCBvcHRpb25zKSA9PiByZXBlYXRFeGl0KHNlbGYsIHtcbiAgLi4ub3B0aW9ucyxcbiAgd2hpbGU6IGV4aXQgPT4gZXhpdC5fdGFnID09PSBcIlN1Y2Nlc3NcIiAmJiAob3B0aW9ucz8ud2hpbGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndoaWxlKGV4aXQudmFsdWUpKVxufSkpO1xuLyoqXG4gKiBSZXBsaWNhdGVzIHRoZSBnaXZlbiBlZmZlY3QgYG5gIHRpbWVzLlxuICpcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXBldGl0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsaWNhdGUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbikgPT4gQXJyYXkuZnJvbSh7XG4gIGxlbmd0aDogblxufSwgKCkgPT4gc2VsZikpO1xuLyoqXG4gKiBQZXJmb3JtcyB0aGlzIGVmZmVjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcyBhbmQgY29sbGVjdHMgdGhlXG4gKiByZXN1bHRzLlxuICpcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBjYXRlZ29yeSByZXBldGl0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsaWNhdGVFZmZlY3QgPSAvKiNfX1BVUkVfXyovZHVhbChhcmdzID0+IGlzTWljcm8oYXJnc1swXSksIChzZWxmLCBuLCBvcHRpb25zKSA9PiBhbGwocmVwbGljYXRlKHNlbGYsIG4pLCBvcHRpb25zKSk7XG4vKipcbiAqIFJlcGVhdCB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QgZm9yZXZlciwgb25seSBzdG9wcGluZyBpZiB0aGUgZWZmZWN0IGZhaWxzLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlcGV0aXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvcmV2ZXIgPSBzZWxmID0+IHJlcGVhdChzZWxmKTtcbi8qKlxuICogQ3JlYXRlIGEgYE1pY3JvU2NoZWR1bGVgIHRoYXQgd2lsbCBzdG9wIHJlcGVhdGluZyBhZnRlciB0aGUgc3BlY2lmaWVkIG51bWJlclxuICogb2YgYXR0ZW1wdHMuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVSZWN1cnMgPSBuID0+IGF0dGVtcHQgPT4gYXR0ZW1wdCA8PSBuID8gT3B0aW9uLnNvbWUoMCkgOiBPcHRpb24ubm9uZSgpO1xuLyoqXG4gKiBDcmVhdGUgYSBgTWljcm9TY2hlZHVsZWAgdGhhdCB3aWxsIGdlbmVyYXRlIGEgY29uc3RhbnQgZGVsYXkuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVTcGFjZWQgPSBtaWxsaXMgPT4gKCkgPT4gT3B0aW9uLnNvbWUobWlsbGlzKTtcbi8qKlxuICogQ3JlYXRlIGEgYE1pY3JvU2NoZWR1bGVgIHRoYXQgd2lsbCBnZW5lcmF0ZSBhIGRlbGF5IHdpdGggYW4gZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzY2hlZHVsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZUV4cG9uZW50aWFsID0gKGJhc2VNaWxsaXMsIGZhY3RvciA9IDIpID0+IGF0dGVtcHQgPT4gT3B0aW9uLnNvbWUoTWF0aC5wb3coZmFjdG9yLCBhdHRlbXB0KSAqIGJhc2VNaWxsaXMpO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBNaWNyb1NjaGVkdWxlYCB3aXRoIGFuIGFkZGVkIGNhbGN1bGF0ZWQgZGVsYXkgdG8gZWFjaCBkZWxheVxuICogcmV0dXJuZWQgYnkgdGhpcyBzY2hlZHVsZS5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzY2hlZHVsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZUFkZERlbGF5ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IChhdHRlbXB0LCBlbGFwc2VkKSA9PiBPcHRpb24ubWFwKHNlbGYoYXR0ZW1wdCwgZWxhcHNlZCksIGR1cmF0aW9uID0+IGR1cmF0aW9uICsgZigpKSk7XG4vKipcbiAqIFRyYW5zZm9ybSBhIGBNaWNyb1NjaGVkdWxlYCB0byBvbmUgdGhhdCB3aWxsIGhhdmUgYSBkZWxheSB0aGF0IHdpbGwgbmV2ZXIgZXhjZWVkXG4gKiB0aGUgc3BlY2lmaWVkIG1heGltdW0uXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgc2NoZWR1bGluZ1xuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVXaXRoTWF4RGVsYXkgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbWF4KSA9PiAoYXR0ZW1wdCwgZWxhcHNlZCkgPT4gT3B0aW9uLm1hcChzZWxmKGF0dGVtcHQsIGVsYXBzZWQpLCBkdXJhdGlvbiA9PiBNYXRoLm1pbihkdXJhdGlvbiwgbWF4KSkpO1xuLyoqXG4gKiBUcmFuc2Zvcm0gYSBgTWljcm9TY2hlZHVsZWAgdG8gb25lIHRoYXQgd2lsbCBzdG9wIHJlcGVhdGluZyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gKiBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzY2hlZHVsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZVdpdGhNYXhFbGFwc2VkID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG1heCkgPT4gKGF0dGVtcHQsIGVsYXBzZWQpID0+IGVsYXBzZWQgPCBtYXggPyBzZWxmKGF0dGVtcHQsIGVsYXBzZWQpIDogT3B0aW9uLm5vbmUoKSk7XG4vKipcbiAqIENvbWJpbmVzIHR3byBgTWljcm9TY2hlZHVsZWBzLCBieSByZWN1cnJpbmcgaWYgZWl0aGVyIHNjaGVkdWxlIHdhbnRzIHRvXG4gKiByZWN1ciwgdXNpbmcgdGhlIG1pbmltdW0gb2YgdGhlIHR3byBkdXJhdGlvbnMgYmV0d2VlbiByZWN1cnJlbmNlcy5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzY2hlZHVsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZVVuaW9uID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IChhdHRlbXB0LCBlbGFwc2VkKSA9PiBPcHRpb24uemlwV2l0aChzZWxmKGF0dGVtcHQsIGVsYXBzZWQpLCB0aGF0KGF0dGVtcHQsIGVsYXBzZWQpLCAoZDEsIGQyKSA9PiBNYXRoLm1pbihkMSwgZDIpKSk7XG4vKipcbiAqIENvbWJpbmVzIHR3byBgTWljcm9TY2hlZHVsZWBzLCBieSByZWN1cnJpbmcgb25seSBpZiBib3RoIHNjaGVkdWxlcyB3YW50IHRvXG4gKiByZWN1ciwgdXNpbmcgdGhlIG1heGltdW0gb2YgdGhlIHR3byBkdXJhdGlvbnMgYmV0d2VlbiByZWN1cnJlbmNlcy5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBzY2hlZHVsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZUludGVyc2VjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiAoYXR0ZW1wdCwgZWxhcHNlZCkgPT4gT3B0aW9uLnppcFdpdGgoc2VsZihhdHRlbXB0LCBlbGFwc2VkKSwgdGhhdChhdHRlbXB0LCBlbGFwc2VkKSwgKGQxLCBkMikgPT4gTWF0aC5tYXgoZDEsIGQyKSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZXJyb3IgaGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQ2F0Y2ggdGhlIGZ1bGwgYE1pY3JvQ2F1c2VgIG9iamVjdCBvZiB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QsIGFsbG93aW5nIHlvdSB0b1xuICogcmVjb3ZlciBmcm9tIGFueSBraW5kIG9mIGNhdXNlLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjYXRjaEFsbENhdXNlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgY29uc3Qgb25GYWlsdXJlID0gT2JqZWN0LmNyZWF0ZShPbkZhaWx1cmVQcm90byk7XG4gIG9uRmFpbHVyZVthcmdzXSA9IHNlbGY7XG4gIG9uRmFpbHVyZVtmYWlsdXJlQ29udF0gPSBmO1xuICByZXR1cm4gb25GYWlsdXJlO1xufSk7XG5jb25zdCBPbkZhaWx1cmVQcm90byA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlUHJvdG8oe1xuICBvcDogXCJPbkZhaWx1cmVcIixcbiAgZXZhbChmaWJlcikge1xuICAgIGZpYmVyLl9zdGFjay5wdXNoKHRoaXMpO1xuICAgIHJldHVybiB0aGlzW2FyZ3NdO1xuICB9XG59KTtcbi8qKlxuICogU2VsZWN0aXZlbHkgY2F0Y2ggYSBgTWljcm9DYXVzZWAgb2JqZWN0IG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCxcbiAqIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmYWlsdXJlIHNob3VsZCBiZSBjYXVnaHQuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdGNoQ2F1c2VJZiA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBwcmVkaWNhdGUsIGYpID0+IGNhdGNoQWxsQ2F1c2Uoc2VsZiwgY2F1c2UgPT4gcHJlZGljYXRlKGNhdXNlKSA/IGYoY2F1c2UpIDogZmFpbENhdXNlKGNhdXNlKSkpO1xuLyoqXG4gKiBDYXRjaCB0aGUgZXJyb3Igb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0LCBhbGxvd2luZyB5b3UgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICpcbiAqIEl0IG9ubHkgY2F0Y2hlcyBleHBlY3RlZCBlcnJvcnMuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNhdGNoQWxsID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGNhdGNoQ2F1c2VJZihzZWxmLCBjYXVzZUlzRmFpbCwgY2F1c2UgPT4gZihjYXVzZS5lcnJvcikpKTtcbi8qKlxuICogQ2F0Y2ggYW55IHVuZXhwZWN0ZWQgZXJyb3JzIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCwgYWxsb3dpbmcgeW91IHRvIHJlY292ZXIgZnJvbSB0aGVtLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjYXRjaEFsbERlZmVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBjYXRjaENhdXNlSWYoc2VsZiwgY2F1c2VJc0RpZSwgZGllID0+IGYoZGllLmRlZmVjdCkpKTtcbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IHVzaW5nIHRoZSBmdWxsIGBNaWNyb0NhdXNlYCBvYmplY3Qgb2YgdGhlIGdpdmVuIGBNaWNyb2AuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcEVycm9yQ2F1c2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gdGFwRXJyb3JDYXVzZUlmKHNlbGYsIGNvbnN0VHJ1ZSwgZikpO1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgdXNpbmcgaWYgYSBgTWljcm9DYXVzZWAgb2JqZWN0IG1hdGNoZXMgdGhlIHNwZWNpZmllZFxuICogcHJlZGljYXRlLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0YXBFcnJvckNhdXNlSWYgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgcmVmaW5lbWVudCwgZikgPT4gY2F0Y2hDYXVzZUlmKHNlbGYsIHJlZmluZW1lbnQsIGNhdXNlID0+IGFuZFRoZW4oZihjYXVzZSksIGZhaWxDYXVzZShjYXVzZSkpKSk7XG4vKipcbiAqIFBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmcm9tIGV4cGVjdGVkIGVycm9ycyBvZiB0aGUgZ2l2ZW4gYE1pY3JvYC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgdGFwRXJyb3IgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gdGFwRXJyb3JDYXVzZUlmKHNlbGYsIGNhdXNlSXNGYWlsLCBmYWlsID0+IGYoZmFpbC5lcnJvcikpKTtcbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZyb20gdW5leHBlY3RlZCBlcnJvcnMgb2YgdGhlIGdpdmVuIGBNaWNyb2AuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcERlZmVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB0YXBFcnJvckNhdXNlSWYoc2VsZiwgY2F1c2VJc0RpZSwgZGllID0+IGYoZGllLmRlZmVjdCkpKTtcbi8qKlxuICogQ2F0Y2ggYW55IGV4cGVjdGVkIGVycm9ycyB0aGF0IG1hdGNoIHRoZSBzcGVjaWZpZWQgcHJlZGljYXRlLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBjYXRjaElmID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHByZWRpY2F0ZSwgZikgPT4gY2F0Y2hDYXVzZUlmKHNlbGYsIGYgPT4gY2F1c2VJc0ZhaWwoZikgJiYgcHJlZGljYXRlKGYuZXJyb3IpLCBmYWlsID0+IGYoZmFpbC5lcnJvcikpKTtcbi8qKlxuICogUmVjb3ZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBlcnJvci5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgY2F0Y2hUYWcgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgaywgZikgPT4gY2F0Y2hJZihzZWxmLCBpc1RhZ2dlZChrKSwgZikpO1xuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGZ1bGwgYE1pY3JvQ2F1c2VgIG9iamVjdCBvZiB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcEVycm9yQ2F1c2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gY2F0Y2hBbGxDYXVzZShzZWxmLCBjYXVzZSA9PiBmYWlsQ2F1c2UoZihjYXVzZSkpKSk7XG4vKipcbiAqIFRyYW5zZm9ybSBhbnkgZXhwZWN0ZWQgZXJyb3JzIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgbWFwRXJyb3IgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gY2F0Y2hBbGwoc2VsZiwgZXJyb3IgPT4gZmFpbChmKGVycm9yKSkpKTtcbi8qKlxuICogRWxldmF0ZSBhbnkgZXhwZWN0ZWQgZXJyb3JzIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCB0byB1bmV4cGVjdGVkIGVycm9ycyxcbiAqIHJlc3VsdGluZyBpbiBhbiBlcnJvciB0eXBlIG9mIGBuZXZlcmAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG9yRGllID0gc2VsZiA9PiBjYXRjaEFsbChzZWxmLCBkaWUpO1xuLyoqXG4gKiBSZWNvdmVyIGZyb20gYWxsIGVycm9ycyBieSBzdWNjZWVkaW5nIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBvckVsc2VTdWNjZWVkID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGNhdGNoQWxsKHNlbGYsIF8gPT4gc3luYyhmKSkpO1xuLyoqXG4gKiBJZ25vcmUgYW55IGV4cGVjdGVkIGVycm9ycyBvZiB0aGUgZ2l2ZW4gYE1pY3JvYCBlZmZlY3QsIHJldHVybmluZyBgdm9pZGAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGlnbm9yZSA9IHNlbGYgPT4gbWF0Y2hFZmZlY3Qoc2VsZiwge1xuICBvbkZhaWx1cmU6IF8gPT4gdm9pZF8sXG4gIG9uU3VjY2VzczogXyA9PiB2b2lkX1xufSk7XG4vKipcbiAqIElnbm9yZSBhbnkgZXhwZWN0ZWQgZXJyb3JzIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCwgcmV0dXJuaW5nIGB2b2lkYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgaWdub3JlTG9nZ2VkID0gc2VsZiA9PiBtYXRjaEVmZmVjdChzZWxmLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIG9uRmFpbHVyZTogZXJyb3IgPT4gc3luYygoKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKSksXG4gIG9uU3VjY2VzczogXyA9PiB2b2lkX1xufSk7XG4vKipcbiAqIFJlcGxhY2UgdGhlIHN1Y2Nlc3MgdmFsdWUgb2YgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0IHdpdGggYW4gYE9wdGlvbmAsXG4gKiB3cmFwcGluZyB0aGUgc3VjY2VzcyB2YWx1ZSBpbiBgU29tZWAgYW5kIHJldHVybmluZyBgTm9uZWAgaWYgdGhlIGVmZmVjdCBmYWlsc1xuICogd2l0aCBhbiBleHBlY3RlZCBlcnJvci5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3Qgb3B0aW9uID0gc2VsZiA9PiBtYXRjaChzZWxmLCB7XG4gIG9uRmFpbHVyZTogT3B0aW9uLm5vbmUsXG4gIG9uU3VjY2VzczogT3B0aW9uLnNvbWVcbn0pO1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBzdWNjZXNzIHZhbHVlIG9mIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCB3aXRoIGFuIGBFaXRoZXJgLFxuICogd3JhcHBpbmcgdGhlIHN1Y2Nlc3MgdmFsdWUgaW4gYFJpZ2h0YCBhbmQgd3JhcHBpbmcgYW55IGV4cGVjdGVkIGVycm9ycyB3aXRoXG4gKiBhIGBMZWZ0YC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3QgZWl0aGVyID0gc2VsZiA9PiBtYXRjaChzZWxmLCB7XG4gIG9uRmFpbHVyZTogRWl0aGVyLmxlZnQsXG4gIG9uU3VjY2VzczogRWl0aGVyLnJpZ2h0XG59KTtcbi8qKlxuICogUmV0cnkgdGhlIGdpdmVuIGBNaWNyb2AgZWZmZWN0IHVzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByZXRyeSA9IC8qI19fUFVSRV9fKi9kdWFsKGFyZ3MgPT4gaXNNaWNybyhhcmdzWzBdKSwgKHNlbGYsIG9wdGlvbnMpID0+IHJlcGVhdEV4aXQoc2VsZiwge1xuICAuLi5vcHRpb25zLFxuICB3aGlsZTogZXhpdCA9PiBleGl0Ll90YWcgPT09IFwiRmFpbHVyZVwiICYmIGV4aXQuY2F1c2UuX3RhZyA9PT0gXCJGYWlsXCIgJiYgKG9wdGlvbnM/LndoaWxlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy53aGlsZShleGl0LmNhdXNlLmVycm9yKSlcbn0pKTtcbi8qKlxuICogQWRkIGEgc3RhY2sgdHJhY2UgdG8gYW55IGZhaWx1cmVzIHRoYXQgb2NjdXIgaW4gdGhlIGVmZmVjdC4gVGhlIHRyYWNlIHdpbGwgYmVcbiAqIGFkZGVkIHRvIHRoZSBgdHJhY2VzYCBmaWVsZCBvZiB0aGUgYE1pY3JvQ2F1c2VgIG9iamVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgY29uc3Qgd2l0aFRyYWNlID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBwcmV2TGltaXQgPSBnbG9iYWxUaGlzLkVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgZ2xvYmFsVGhpcy5FcnJvci5zdGFja1RyYWNlTGltaXQgPSAyO1xuICBjb25zdCBlcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gIGdsb2JhbFRoaXMuRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gcHJldkxpbWl0O1xuICBmdW5jdGlvbiBnZW5lcmF0ZShuYW1lLCBjYXVzZSkge1xuICAgIGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgaWYgKCFzdGFjaykge1xuICAgICAgcmV0dXJuIGNhdXNlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lID0gc3RhY2suc3BsaXQoXCJcXG5cIilbMl0/LnRyaW0oKS5yZXBsYWNlKC9eYXQgLywgXCJcIik7XG4gICAgaWYgKCFsaW5lKSB7XG4gICAgICByZXR1cm4gY2F1c2U7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVNYXRjaCA9IGxpbmUubWF0Y2goL1xcKCguKilcXCkkLyk7XG4gICAgcmV0dXJuIGNhdXNlV2l0aFRyYWNlKGNhdXNlLCBgYXQgJHtuYW1lfSAoJHtsaW5lTWF0Y2ggPyBsaW5lTWF0Y2hbMV0gOiBsaW5lfSlgKTtcbiAgfVxuICBjb25zdCBmID0gbmFtZSA9PiBzZWxmID0+IG9uRXJyb3Ioc2VsZiwgY2F1c2UgPT4gZmFpbENhdXNlKGdlbmVyYXRlKG5hbWUsIGNhdXNlKSkpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBmKGFyZ3VtZW50c1sxXSkoYXJndW1lbnRzWzBdKTtcbiAgfVxuICByZXR1cm4gZihhcmd1bWVudHNbMF0pO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHBhdHRlcm4gbWF0Y2hpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcGF0dGVybiBtYXRjaGluZ1xuICovXG5leHBvcnQgY29uc3QgbWF0Y2hDYXVzZUVmZmVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByaW1pdGl2ZSA9IE9iamVjdC5jcmVhdGUoT25TdWNjZXNzQW5kRmFpbHVyZVByb3RvKTtcbiAgcHJpbWl0aXZlW2FyZ3NdID0gc2VsZjtcbiAgcHJpbWl0aXZlW3N1Y2Nlc3NDb250XSA9IG9wdGlvbnMub25TdWNjZXNzO1xuICBwcmltaXRpdmVbZmFpbHVyZUNvbnRdID0gb3B0aW9ucy5vbkZhaWx1cmU7XG4gIHJldHVybiBwcmltaXRpdmU7XG59KTtcbmNvbnN0IE9uU3VjY2Vzc0FuZEZhaWx1cmVQcm90byA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlUHJvdG8oe1xuICBvcDogXCJPblN1Y2Nlc3NBbmRGYWlsdXJlXCIsXG4gIGV2YWwoZmliZXIpIHtcbiAgICBmaWJlci5fc3RhY2sucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gdGhpc1thcmdzXTtcbiAgfVxufSk7XG4vKipcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHBhdHRlcm4gbWF0Y2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoQ2F1c2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWF0Y2hDYXVzZUVmZmVjdChzZWxmLCB7XG4gIG9uRmFpbHVyZTogY2F1c2UgPT4gc3luYygoKSA9PiBvcHRpb25zLm9uRmFpbHVyZShjYXVzZSkpLFxuICBvblN1Y2Nlc3M6IHZhbHVlID0+IHN5bmMoKCkgPT4gb3B0aW9ucy5vblN1Y2Nlc3ModmFsdWUpKVxufSkpO1xuLyoqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaEVmZmVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvcHRpb25zKSA9PiBtYXRjaENhdXNlRWZmZWN0KHNlbGYsIHtcbiAgb25GYWlsdXJlOiBjYXVzZSA9PiBjYXVzZS5fdGFnID09PSBcIkZhaWxcIiA/IG9wdGlvbnMub25GYWlsdXJlKGNhdXNlLmVycm9yKSA6IGZhaWxDYXVzZShjYXVzZSksXG4gIG9uU3VjY2Vzczogb3B0aW9ucy5vblN1Y2Nlc3Ncbn0pKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcGF0dGVybiBtYXRjaGluZ1xuICovXG5leHBvcnQgY29uc3QgbWF0Y2ggPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWF0Y2hFZmZlY3Qoc2VsZiwge1xuICBvbkZhaWx1cmU6IGVycm9yID0+IHN5bmMoKCkgPT4gb3B0aW9ucy5vbkZhaWx1cmUoZXJyb3IpKSxcbiAgb25TdWNjZXNzOiB2YWx1ZSA9PiBzeW5jKCgpID0+IG9wdGlvbnMub25TdWNjZXNzKHZhbHVlKSlcbn0pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGRlbGF5cyAmIHRpbWVvdXRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIENyZWF0ZSBhIGBNaWNyb2AgZWZmZWN0IHRoYXQgd2lsbCBzbGVlcCBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkZWxheXMgJiB0aW1lb3V0c1xuICovXG5leHBvcnQgY29uc3Qgc2xlZXAgPSBtaWxsaXMgPT4gYXN5bmMocmVzdW1lID0+IHtcbiAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHJlc3VtZSh2b2lkXyk7XG4gIH0sIG1pbGxpcyk7XG4gIHJldHVybiBzeW5jKCgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIH0pO1xufSk7XG4vKipcbiAqIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgZWZmZWN0IGJ5IHRoZVxuICogc3BlY2lmaWVkIGR1cmF0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRlbGF5cyAmIHRpbWVvdXRzXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxheSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBtaWxsaXMpID0+IGFuZFRoZW4oc2xlZXAobWlsbGlzKSwgc2VsZikpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHdpbGwgdGltZW91dCB0aGlzIGVmZmVjdCwgdGhhdCB3aWxsIGV4ZWN1dGUgdGhlXG4gKiBmYWxsYmFjayBlZmZlY3QgaWYgdGhlIHRpbWVvdXQgZWxhcHNlcyBiZWZvcmUgdGhlIGVmZmVjdCBoYXMgcHJvZHVjZWQgYSB2YWx1ZS5cbiAqXG4gKiBJZiB0aGUgdGltZW91dCBlbGFwc2VzLCB0aGUgcnVubmluZyBlZmZlY3Qgd2lsbCBiZSBzYWZlbHkgaW50ZXJydXB0ZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZGVsYXlzICYgdGltZW91dHNcbiAqL1xuZXhwb3J0IGNvbnN0IHRpbWVvdXRPckVsc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gcmFjZUZpcnN0KHNlbGYsIGFuZFRoZW4oaW50ZXJydXB0aWJsZShzbGVlcChvcHRpb25zLmR1cmF0aW9uKSksIG9wdGlvbnMub25UaW1lb3V0KSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHdpbGwgdGltZW91dCB0aGlzIGVmZmVjdCwgdGhhdCB3aWxsIGZhaWwgd2l0aCBhXG4gKiBgVGltZW91dEV4Y2VwdGlvbmAgaWYgdGhlIHRpbWVvdXQgZWxhcHNlcyBiZWZvcmUgdGhlIGVmZmVjdCBoYXMgcHJvZHVjZWQgYVxuICogdmFsdWUuXG4gKlxuICogSWYgdGhlIHRpbWVvdXQgZWxhcHNlcywgdGhlIHJ1bm5pbmcgZWZmZWN0IHdpbGwgYmUgc2FmZWx5IGludGVycnVwdGVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRlbGF5cyAmIHRpbWVvdXRzXG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG1pbGxpcykgPT4gdGltZW91dE9yRWxzZShzZWxmLCB7XG4gIGR1cmF0aW9uOiBtaWxsaXMsXG4gIG9uVGltZW91dDogKCkgPT4gZmFpbChuZXcgVGltZW91dEV4Y2VwdGlvbigpKVxufSkpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IHdpbGwgdGltZW91dCB0aGlzIGVmZmVjdCwgc3VjY2VlZGluZyB3aXRoIGEgYE5vbmVgXG4gKiBpZiB0aGUgdGltZW91dCBlbGFwc2VzIGJlZm9yZSB0aGUgZWZmZWN0IGhhcyBwcm9kdWNlZCBhIHZhbHVlOyBhbmQgYFNvbWVgIG9mXG4gKiB0aGUgcHJvZHVjZWQgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIElmIHRoZSB0aW1lb3V0IGVsYXBzZXMsIHRoZSBydW5uaW5nIGVmZmVjdCB3aWxsIGJlIHNhZmVseSBpbnRlcnJ1cHRlZC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBkZWxheXMgJiB0aW1lb3V0c1xuICovXG5leHBvcnQgY29uc3QgdGltZW91dE9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBtaWxsaXMpID0+IHJhY2VGaXJzdChhc1NvbWUoc2VsZiksIGFzKGludGVycnVwdGlibGUoc2xlZXAobWlsbGlzKSksIE9wdGlvbi5ub25lKCkpKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb1Njb3BlVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvTWljcm8vTWljcm9TY29wZVwiKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBNaWNyb1Njb3BlID0gLyojX19QVVJFX18qL0NvbnRleHQuR2VuZXJpY1RhZyhcImVmZmVjdC9NaWNyby9NaWNyb1Njb3BlXCIpO1xuY2xhc3MgTWljcm9TY29wZUltcGwge1xuICBbTWljcm9TY29wZVR5cGVJZF07XG4gIHN0YXRlID0ge1xuICAgIF90YWc6IFwiT3BlblwiLFxuICAgIGZpbmFsaXplcnM6IC8qI19fUFVSRV9fKi9uZXcgU2V0KClcbiAgfTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpc1tNaWNyb1Njb3BlVHlwZUlkXSA9IE1pY3JvU2NvcGVUeXBlSWQ7XG4gIH1cbiAgdW5zYWZlQWRkRmluYWxpemVyKGZpbmFsaXplcikge1xuICAgIGlmICh0aGlzLnN0YXRlLl90YWcgPT09IFwiT3BlblwiKSB7XG4gICAgICB0aGlzLnN0YXRlLmZpbmFsaXplcnMuYWRkKGZpbmFsaXplcik7XG4gICAgfVxuICB9XG4gIGFkZEZpbmFsaXplcihmaW5hbGl6ZXIpIHtcbiAgICByZXR1cm4gc3VzcGVuZCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5fdGFnID09PSBcIk9wZW5cIikge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbmFsaXplcnMuYWRkKGZpbmFsaXplcik7XG4gICAgICAgIHJldHVybiB2b2lkXztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5hbGl6ZXIodGhpcy5zdGF0ZS5leGl0KTtcbiAgICB9KTtcbiAgfVxuICB1bnNhZmVSZW1vdmVGaW5hbGl6ZXIoZmluYWxpemVyKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX3RhZyA9PT0gXCJPcGVuXCIpIHtcbiAgICAgIHRoaXMuc3RhdGUuZmluYWxpemVycy5kZWxldGUoZmluYWxpemVyKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UobWljcm9FeGl0KSB7XG4gICAgcmV0dXJuIHN1c3BlbmQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuX3RhZyA9PT0gXCJPcGVuXCIpIHtcbiAgICAgICAgY29uc3QgZmluYWxpemVycyA9IEFycmF5LmZyb20odGhpcy5zdGF0ZS5maW5hbGl6ZXJzKS5yZXZlcnNlKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgX3RhZzogXCJDbG9zZWRcIixcbiAgICAgICAgICBleGl0OiBtaWNyb0V4aXRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAoZm9yRWFjaChmaW5hbGl6ZXJzLCBmaW5hbGl6ZXIgPT4gZXhpdChmaW5hbGl6ZXIobWljcm9FeGl0KSkpLCBleGl0Vm9pZEFsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZF87XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZvcmsoKSB7XG4gICAgcmV0dXJuIHN5bmMoKCkgPT4ge1xuICAgICAgY29uc3QgbmV3U2NvcGUgPSBuZXcgTWljcm9TY29wZUltcGwoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLl90YWcgPT09IFwiQ2xvc2VkXCIpIHtcbiAgICAgICAgbmV3U2NvcGUuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICByZXR1cm4gbmV3U2NvcGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmaW4oZXhpdCkge1xuICAgICAgICByZXR1cm4gbmV3U2NvcGUuY2xvc2UoZXhpdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmZpbmFsaXplcnMuYWRkKGZpbik7XG4gICAgICBuZXdTY29wZS51bnNhZmVBZGRGaW5hbGl6ZXIoXyA9PiBzeW5jKCgpID0+IHRoaXMudW5zYWZlUmVtb3ZlRmluYWxpemVyKGZpbikpKTtcbiAgICAgIHJldHVybiBuZXdTY29wZTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3BlTWFrZSA9IC8qI19fUFVSRV9fKi9zeW5jKCgpID0+IG5ldyBNaWNyb1Njb3BlSW1wbCgpKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzY29wZVVuc2FmZU1ha2UgPSAoKSA9PiBuZXcgTWljcm9TY29wZUltcGwoKTtcbi8qKlxuICogQWNjZXNzIHRoZSBjdXJyZW50IGBNaWNyb1Njb3BlYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3BlID0gLyojX19QVVJFX18qL3NlcnZpY2UoTWljcm9TY29wZSk7XG4vKipcbiAqIFByb3ZpZGUgYSBgTWljcm9TY29wZWAgdG8gYW4gZWZmZWN0LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlc291cmNlcyAmIGZpbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3QgcHJvdmlkZVNjb3BlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHNjb3BlKSA9PiBwcm92aWRlU2VydmljZShzZWxmLCBNaWNyb1Njb3BlLCBzY29wZSkpO1xuLyoqXG4gKiBQcm92aWRlIGEgYE1pY3JvU2NvcGVgIHRvIHRoZSBnaXZlbiBlZmZlY3QsIGNsb3NpbmcgaXQgYWZ0ZXIgdGhlIGVmZmVjdCBoYXNcbiAqIGZpbmlzaGVkIGV4ZWN1dGluZy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjb3BlZCA9IHNlbGYgPT4gc3VzcGVuZCgoKSA9PiB7XG4gIGNvbnN0IHNjb3BlID0gbmV3IE1pY3JvU2NvcGVJbXBsKCk7XG4gIHJldHVybiBvbkV4aXQocHJvdmlkZVNlcnZpY2Uoc2VsZiwgTWljcm9TY29wZSwgc2NvcGUpLCBleGl0ID0+IHNjb3BlLmNsb3NlKGV4aXQpKTtcbn0pO1xuLyoqXG4gKiBDcmVhdGUgYSByZXNvdXJjZSB3aXRoIGEgY2xlYW51cCBgTWljcm9gIGVmZmVjdCwgZW5zdXJpbmcgdGhlIGNsZWFudXAgaXNcbiAqIGV4ZWN1dGVkIHdoZW4gdGhlIGBNaWNyb1Njb3BlYCBpcyBjbG9zZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhY3F1aXJlUmVsZWFzZSA9IChhY3F1aXJlLCByZWxlYXNlKSA9PiB1bmludGVycnVwdGlibGUoZmxhdE1hcChzY29wZSwgc2NvcGUgPT4gdGFwKGFjcXVpcmUsIGEgPT4gc2NvcGUuYWRkRmluYWxpemVyKGV4aXQgPT4gcmVsZWFzZShhLCBleGl0KSkpKSk7XG4vKipcbiAqIEFkZCBhIGZpbmFsaXplciB0byB0aGUgY3VycmVudCBgTWljcm9TY29wZWAuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRGaW5hbGl6ZXIgPSBmaW5hbGl6ZXIgPT4gZmxhdE1hcChzY29wZSwgc2NvcGUgPT4gc2NvcGUuYWRkRmluYWxpemVyKGZpbmFsaXplcikpO1xuLyoqXG4gKiBXaGVuIHRoZSBgTWljcm9gIGVmZmVjdCBpcyBjb21wbGV0ZWQsIHJ1biB0aGUgZ2l2ZW4gZmluYWxpemVyIGVmZmVjdCB3aXRoIHRoZVxuICogYE1pY3JvRXhpdGAgb2YgdGhlIGV4ZWN1dGVkIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG9uRXhpdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB1bmludGVycnVwdGlibGVNYXNrKHJlc3RvcmUgPT4gbWF0Y2hDYXVzZUVmZmVjdChyZXN0b3JlKHNlbGYpLCB7XG4gIG9uRmFpbHVyZTogY2F1c2UgPT4gZmxhdE1hcChmKGV4aXRGYWlsQ2F1c2UoY2F1c2UpKSwgKCkgPT4gZmFpbENhdXNlKGNhdXNlKSksXG4gIG9uU3VjY2VzczogYSA9PiBmbGF0TWFwKGYoZXhpdFN1Y2NlZWQoYSkpLCAoKSA9PiBzdWNjZWVkKGEpKVxufSkpKTtcbi8qKlxuICogUmVnYXJkbGVzcyBvZiB0aGUgcmVzdWx0IG9mIHRoZSB0aGlzIGBNaWNyb2AgZWZmZWN0LCBydW4gdGhlIGZpbmFsaXplciBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnN1cmluZyA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmaW5hbGl6ZXIpID0+IG9uRXhpdChzZWxmLCBfID0+IGZpbmFsaXplcikpO1xuLyoqXG4gKiBXaGVuIHRoZSBgTWljcm9gIGVmZmVjdCBpcyBjb21wbGV0ZWQsIHJ1biB0aGUgZ2l2ZW4gZmluYWxpemVyIGVmZmVjdCBpZiBpdFxuICogbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG9uRXhpdElmID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHJlZmluZW1lbnQsIGYpID0+IG9uRXhpdChzZWxmLCBleGl0ID0+IHJlZmluZW1lbnQoZXhpdCkgPyBmKGV4aXQpIDogZXhpdFZvaWQpKTtcbi8qKlxuICogV2hlbiB0aGUgYE1pY3JvYCBlZmZlY3QgZmFpbHMsIHJ1biB0aGUgZ2l2ZW4gZmluYWxpemVyIGVmZmVjdCB3aXRoIHRoZVxuICogYE1pY3JvQ2F1c2VgIG9mIHRoZSBleGVjdXRlZCBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgcmVzb3VyY2VzICYgZmluYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBvbkVycm9yID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IG9uRXhpdElmKHNlbGYsIGV4aXRJc0ZhaWx1cmUsIGV4aXQgPT4gZihleGl0LmNhdXNlKSkpO1xuLyoqXG4gKiBJZiB0aGlzIGBNaWNyb2AgZWZmZWN0IGlzIGFib3J0ZWQsIHJ1biB0aGUgZmluYWxpemVyIGVmZmVjdC5cbiAqXG4gKiBAc2luY2UgMy40LjZcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSByZXNvdXJjZXMgJiBmaW5hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG9uSW50ZXJydXB0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGZpbmFsaXplcikgPT4gb25FeGl0SWYoc2VsZiwgZXhpdElzSW50ZXJydXB0LCBfID0+IGZpbmFsaXplcikpO1xuLyoqXG4gKiBBY3F1aXJlIGEgcmVzb3VyY2UsIHVzZSBpdCwgYW5kIHRoZW4gcmVsZWFzZSB0aGUgcmVzb3VyY2Ugd2hlbiB0aGUgYHVzZWBcbiAqIGVmZmVjdCBoYXMgY29tcGxldGVkLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IHJlc291cmNlcyAmIGZpbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3QgYWNxdWlyZVVzZVJlbGVhc2UgPSAoYWNxdWlyZSwgdXNlLCByZWxlYXNlKSA9PiB1bmludGVycnVwdGlibGVNYXNrKHJlc3RvcmUgPT4gZmxhdE1hcChhY3F1aXJlLCBhID0+IGZsYXRNYXAoZXhpdChyZXN0b3JlKHVzZShhKSkpLCBleGl0ID0+IGFuZFRoZW4ocmVsZWFzZShhLCBleGl0KSwgZXhpdCkpKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbnRlcnJ1cHRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQWJvcnQgdGhlIGN1cnJlbnQgYE1pY3JvYCBlZmZlY3QuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgaW50ZXJydXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnJ1cHQgPSAvKiNfX1BVUkVfXyovZmFpbENhdXNlKCAvKiNfX1BVUkVfXyovY2F1c2VJbnRlcnJ1cHQoKSk7XG4vKipcbiAqIEZsYWcgdGhlIGVmZmVjdCBhcyB1bmludGVycnVwdGlibGUsIHdoaWNoIG1lYW5zIHRoYXQgd2hlbiB0aGUgZWZmZWN0IGlzXG4gKiBpbnRlcnJ1cHRlZCwgaXQgd2lsbCBiZSBhbGxvd2VkIHRvIGNvbnRpbnVlIHJ1bm5pbmcgdW50aWwgY29tcGxldGlvbi5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmbGFnc1xuICovXG5leHBvcnQgY29uc3QgdW5pbnRlcnJ1cHRpYmxlID0gc2VsZiA9PiB3aXRoTWljcm9GaWJlcihmaWJlciA9PiB7XG4gIGlmICghZmliZXIuaW50ZXJydXB0aWJsZSkgcmV0dXJuIHNlbGY7XG4gIGZpYmVyLmludGVycnVwdGlibGUgPSBmYWxzZTtcbiAgZmliZXIuX3N0YWNrLnB1c2goc2V0SW50ZXJydXB0aWJsZSh0cnVlKSk7XG4gIHJldHVybiBzZWxmO1xufSk7XG5jb25zdCBzZXRJbnRlcnJ1cHRpYmxlID0gLyojX19QVVJFX18qL21ha2VQcmltaXRpdmUoe1xuICBvcDogXCJTZXRJbnRlcnJ1cHRpYmxlXCIsXG4gIGVuc3VyZShmaWJlcikge1xuICAgIGZpYmVyLmludGVycnVwdGlibGUgPSB0aGlzW2FyZ3NdO1xuICAgIGlmIChmaWJlci5faW50ZXJydXB0ZWQgJiYgZmliZXIuaW50ZXJydXB0aWJsZSkge1xuICAgICAgcmV0dXJuICgpID0+IGV4aXRJbnRlcnJ1cHQ7XG4gICAgfVxuICB9XG59KTtcbi8qKlxuICogRmxhZyB0aGUgZWZmZWN0IGFzIGludGVycnVwdGlibGUsIHdoaWNoIG1lYW5zIHRoYXQgd2hlbiB0aGUgZWZmZWN0IGlzXG4gKiBpbnRlcnJ1cHRlZCwgaXQgd2lsbCBiZSBpbnRlcnJ1cHRlZCBpbW1lZGlhdGVseS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmbGFnc1xuICovXG5leHBvcnQgY29uc3QgaW50ZXJydXB0aWJsZSA9IHNlbGYgPT4gd2l0aE1pY3JvRmliZXIoZmliZXIgPT4ge1xuICBpZiAoZmliZXIuaW50ZXJydXB0aWJsZSkgcmV0dXJuIHNlbGY7XG4gIGZpYmVyLmludGVycnVwdGlibGUgPSB0cnVlO1xuICBmaWJlci5fc3RhY2sucHVzaChzZXRJbnRlcnJ1cHRpYmxlKGZhbHNlKSk7XG4gIGlmIChmaWJlci5faW50ZXJydXB0ZWQpIHJldHVybiBleGl0SW50ZXJydXB0O1xuICByZXR1cm4gc2VsZjtcbn0pO1xuLyoqXG4gKiBXcmFwIHRoZSBnaXZlbiBgTWljcm9gIGVmZmVjdCBpbiBhbiB1bmludGVycnVwdGlibGUgcmVnaW9uLCBwcmV2ZW50aW5nIHRoZVxuICogZWZmZWN0IGZyb20gYmVpbmcgYWJvcnRlZC5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGUgYHJlc3RvcmVgIGZ1bmN0aW9uIHRvIHJlc3RvcmUgYSBgTWljcm9gIGVmZmVjdCB0byB0aGVcbiAqIGludGVycnVwdGliaWxpdHkgc3RhdGUgYmVmb3JlIHRoZSBgdW5pbnRlcnJ1cHRpYmxlTWFza2Agd2FzIGFwcGxpZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgKiBhcyBNaWNybyBmcm9tIFwiZWZmZWN0L01pY3JvXCJcbiAqXG4gKiBNaWNyby51bmludGVycnVwdGlibGVNYXNrKChyZXN0b3JlKSA9PlxuICogICBNaWNyby5zbGVlcCgxMDAwKS5waXBlKCAvLyB1bmludGVycnVwdGlibGVcbiAqICAgICBNaWNyby5hbmRUaGVuKHJlc3RvcmUoTWljcm8uc2xlZXAoMTAwMCkpKSAvLyBpbnRlcnJ1cHRpYmxlXG4gKiAgIClcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGludGVycnVwdGlvblxuICovXG5leHBvcnQgY29uc3QgdW5pbnRlcnJ1cHRpYmxlTWFzayA9IGYgPT4gd2l0aE1pY3JvRmliZXIoZmliZXIgPT4ge1xuICBpZiAoIWZpYmVyLmludGVycnVwdGlibGUpIHJldHVybiBmKGlkZW50aXR5KTtcbiAgZmliZXIuaW50ZXJydXB0aWJsZSA9IGZhbHNlO1xuICBmaWJlci5fc3RhY2sucHVzaChzZXRJbnRlcnJ1cHRpYmxlKHRydWUpKTtcbiAgcmV0dXJuIGYoaW50ZXJydXB0aWJsZSk7XG59KTtcbi8qKlxuICogUnVucyBhbGwgdGhlIHByb3ZpZGVkIGVmZmVjdHMgaW4gc2VxdWVuY2UgcmVzcGVjdGluZyB0aGUgc3RydWN0dXJlIHByb3ZpZGVkIGluIGlucHV0LlxuICpcbiAqIFN1cHBvcnRzIG11bHRpcGxlIGFyZ3VtZW50cywgYSBzaW5nbGUgYXJndW1lbnQgdHVwbGUgLyBhcnJheSBvciByZWNvcmQgLyBzdHJ1Y3QuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29sbGVjdGluZyAmIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSAoYXJnLCBvcHRpb25zKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgaXNJdGVyYWJsZShhcmcpKSB7XG4gICAgcmV0dXJuIGZvckVhY2goYXJnLCBpZGVudGl0eSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucz8uZGlzY2FyZCkge1xuICAgIHJldHVybiBmb3JFYWNoKE9iamVjdC52YWx1ZXMoYXJnKSwgaWRlbnRpdHksIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBzdXNwZW5kKCgpID0+IHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICByZXR1cm4gYXMoZm9yRWFjaChPYmplY3QuZW50cmllcyhhcmcpLCAoW2tleSwgZWZmZWN0XSkgPT4gbWFwKGVmZmVjdCwgdmFsdWUgPT4ge1xuICAgICAgb3V0W2tleV0gPSB2YWx1ZTtcbiAgICB9KSwge1xuICAgICAgZGlzY2FyZDogdHJ1ZSxcbiAgICAgIGNvbmN1cnJlbmN5OiBvcHRpb25zPy5jb25jdXJyZW5jeVxuICAgIH0pLCBvdXQpO1xuICB9KTtcbn07XG4vKipcbiAqIEBzaW5jZSAzLjExLjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb2xsZWN0aW5nICYgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IHdoaWxlTG9vcCA9IC8qI19fUFVSRV9fKi9tYWtlUHJpbWl0aXZlKHtcbiAgb3A6IFwiV2hpbGVcIixcbiAgY29udEEodmFsdWUsIGZpYmVyKSB7XG4gICAgdGhpc1thcmdzXS5zdGVwKHZhbHVlKTtcbiAgICBpZiAodGhpc1thcmdzXS53aGlsZSgpKSB7XG4gICAgICBmaWJlci5fc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzW2FyZ3NdLmJvZHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXRWb2lkO1xuICB9LFxuICBldmFsKGZpYmVyKSB7XG4gICAgaWYgKHRoaXNbYXJnc10ud2hpbGUoKSkge1xuICAgICAgZmliZXIuX3N0YWNrLnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gdGhpc1thcmdzXS5ib2R5KCk7XG4gICAgfVxuICAgIHJldHVybiBleGl0Vm9pZDtcbiAgfVxufSk7XG4vKipcbiAqIEZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHByb3ZpZGVkIGl0ZXJhYmxlLCBydW4gdGhlIGVmZmVjdCBhbmQgY29sbGVjdCB0aGVcbiAqIHJlc3VsdHMuXG4gKlxuICogSWYgdGhlIGBkaXNjYXJkYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBkaXNjYXJkZWQgYW5kXG4gKiB0aGUgZWZmZWN0IHdpbGwgcmV0dXJuIGB2b2lkYC5cbiAqXG4gKiBUaGUgYGNvbmN1cnJlbmN5YCBvcHRpb24gY2FuIGJlIHNldCB0byBjb250cm9sIGhvdyBtYW55IGVmZmVjdHMgYXJlIHJ1blxuICogY29uY3VycmVudGx5LiBCeSBkZWZhdWx0LCB0aGUgZWZmZWN0cyBhcmUgcnVuIHNlcXVlbnRpYWxseS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBjb2xsZWN0aW5nICYgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoaXRlcmFibGUsIGYsIG9wdGlvbnMpID0+IHdpdGhNaWNyb0ZpYmVyKHBhcmVudCA9PiB7XG4gIGNvbnN0IGNvbmN1cnJlbmN5T3B0aW9uID0gb3B0aW9ucz8uY29uY3VycmVuY3kgPT09IFwiaW5oZXJpdFwiID8gcGFyZW50LmdldFJlZihDdXJyZW50Q29uY3VycmVuY3kpIDogb3B0aW9ucz8uY29uY3VycmVuY3kgPz8gMTtcbiAgY29uc3QgY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeU9wdGlvbiA9PT0gXCJ1bmJvdW5kZWRcIiA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE1hdGgubWF4KDEsIGNvbmN1cnJlbmN5T3B0aW9uKTtcbiAgY29uc3QgaXRlbXMgPSBBcnIuZnJvbUl0ZXJhYmxlKGl0ZXJhYmxlKTtcbiAgbGV0IGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvcHRpb25zPy5kaXNjYXJkID8gdm9pZF8gOiBzdWNjZWVkKFtdKTtcbiAgfVxuICBjb25zdCBvdXQgPSBvcHRpb25zPy5kaXNjYXJkID8gdW5kZWZpbmVkIDogbmV3IEFycmF5KGxlbmd0aCk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGlmIChjb25jdXJyZW5jeSA9PT0gMSkge1xuICAgIHJldHVybiBhcyh3aGlsZUxvb3Aoe1xuICAgICAgd2hpbGU6ICgpID0+IGluZGV4IDwgaXRlbXMubGVuZ3RoLFxuICAgICAgYm9keTogKCkgPT4gZihpdGVtc1tpbmRleF0sIGluZGV4KSxcbiAgICAgIHN0ZXA6IG91dCA/IGIgPT4gb3V0W2luZGV4KytdID0gYiA6IF8gPT4gaW5kZXgrK1xuICAgIH0pLCBvdXQpO1xuICB9XG4gIHJldHVybiBhc3luYyhyZXN1bWUgPT4ge1xuICAgIGNvbnN0IGZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIGxldCBpblByb2dyZXNzID0gMDtcbiAgICBsZXQgZG9uZUNvdW50ID0gMDtcbiAgICBsZXQgcHVtcGluZyA9IGZhbHNlO1xuICAgIGxldCBpbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICBwdW1waW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpblByb2dyZXNzIDwgY29uY3VycmVuY3kgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBpblByb2dyZXNzKys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSB1bnNhZmVGb3JrKHBhcmVudCwgZihpdGVtLCBjdXJyZW50SW5kZXgpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBmaWJlcnMuYWRkKGNoaWxkKTtcbiAgICAgICAgICBjaGlsZC5hZGRPYnNlcnZlcihleGl0ID0+IHtcbiAgICAgICAgICAgIGZpYmVycy5kZWxldGUoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGludGVycnVwdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhpdC5fdGFnID09PSBcIkZhaWx1cmVcIikge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleGl0O1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGZpYmVycy5mb3JFYWNoKGZpYmVyID0+IGZpYmVyLnVuc2FmZUludGVycnVwdCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdXRbY3VycmVudEluZGV4XSA9IGV4aXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lQ291bnQrKztcbiAgICAgICAgICAgIGluUHJvZ3Jlc3MtLTtcbiAgICAgICAgICAgIGlmIChkb25lQ291bnQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bWUocmVzdWx0ID8/IHN1Y2NlZWQob3V0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwdW1waW5nICYmIGluUHJvZ3Jlc3MgPCBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICBwdW1wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3VsdCA9IGV4aXREaWUoZXJyKTtcbiAgICAgICAgICBsZW5ndGggPSBpbmRleDtcbiAgICAgICAgICBmaWJlcnMuZm9yRWFjaChmaWJlciA9PiBmaWJlci51bnNhZmVJbnRlcnJ1cHQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHB1bXBpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcHVtcCgpO1xuICAgIHJldHVybiBzdXNwZW5kKCgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIGZpYmVySW50ZXJydXB0QWxsKGZpYmVycyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4vKipcbiAqIEVmZmVjdGZ1bGx5IGZpbHRlciB0aGUgZWxlbWVudHMgb2YgdGhlIHByb3ZpZGVkIGl0ZXJhYmxlLlxuICpcbiAqIFVzZSB0aGUgYGNvbmN1cnJlbmN5YCBvcHRpb24gdG8gY29udHJvbCBob3cgbWFueSBlbGVtZW50cyBhcmUgcHJvY2Vzc2VkXG4gKiBjb25jdXJyZW50bHkuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgY29sbGVjdGluZyAmIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXIgPSAoaXRlcmFibGUsIGYsIG9wdGlvbnMpID0+IGZpbHRlck1hcChpdGVyYWJsZSwgYSA9PiBtYXAoZihhKSwgcGFzcyA9PiB7XG4gIHBhc3MgPSBvcHRpb25zPy5uZWdhdGUgPyAhcGFzcyA6IHBhc3M7XG4gIHJldHVybiBwYXNzID8gT3B0aW9uLnNvbWUoYSkgOiBPcHRpb24ubm9uZSgpO1xufSksIG9wdGlvbnMpO1xuLyoqXG4gKiBFZmZlY3RmdWxseSBmaWx0ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBwcm92aWRlZCBpdGVyYWJsZS5cbiAqXG4gKiBVc2UgdGhlIGBjb25jdXJyZW5jeWAgb3B0aW9uIHRvIGNvbnRyb2wgaG93IG1hbnkgZWxlbWVudHMgYXJlIHByb2Nlc3NlZFxuICogY29uY3VycmVudGx5LlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGNvbGxlY3RpbmcgJiBlbGVtZW50c1xuICovXG5leHBvcnQgY29uc3QgZmlsdGVyTWFwID0gKGl0ZXJhYmxlLCBmLCBvcHRpb25zKSA9PiBzdXNwZW5kKCgpID0+IHtcbiAgY29uc3Qgb3V0ID0gW107XG4gIHJldHVybiBhcyhmb3JFYWNoKGl0ZXJhYmxlLCBhID0+IG1hcChmKGEpLCBvID0+IHtcbiAgICBpZiAoby5fdGFnID09PSBcIlNvbWVcIikge1xuICAgICAgb3V0LnB1c2goby52YWx1ZSk7XG4gICAgfVxuICB9KSwge1xuICAgIGRpc2NhcmQ6IHRydWUsXG4gICAgY29uY3VycmVuY3k6IG9wdGlvbnM/LmNvbmN1cnJlbmN5XG4gIH0pLCBvdXQpO1xufSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkbyBub3RhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTdGFydCBhIGRvIG5vdGF0aW9uIGJsb2NrLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBEbyA9IC8qI19fUFVSRV9fKi9zdWNjZWVkKHt9KTtcbi8qKlxuICogQmluZCB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGlzIGBNaWNyb2AgZWZmZWN0IHRvIHRoZSBwcm92aWRlZCBuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBiaW5kVG8gPSAvKiNfX1BVUkVfXyovZG9Ob3RhdGlvbi5iaW5kVG8obWFwKTtcbi8qKlxuICogQmluZCB0aGUgc3VjY2VzcyB2YWx1ZSBvZiB0aGlzIGBNaWNyb2AgZWZmZWN0IHRvIHRoZSBwcm92aWRlZCBuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBiaW5kID0gLyojX19QVVJFX18qL2RvTm90YXRpb24uYmluZChtYXAsIGZsYXRNYXApO1xuY29uc3QgbGV0XyA9IC8qI19fUFVSRV9fKi9kb05vdGF0aW9uLmxldF8obWFwKTtcbmV4cG9ydCB7XG4vKipcbiAqIEJpbmQgdGhlIHJlc3VsdCBvZiBhIHN5bmNocm9ub3VzIGNvbXB1dGF0aW9uIHRvIHRoZSBnaXZlbiBuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKi9cbmxldF8gYXMgbGV0IH07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmaWJlcnMgJiBmb3JraW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFJ1biB0aGUgYE1pY3JvYCBlZmZlY3QgaW4gYSBuZXcgYE1pY3JvRmliZXJgIHRoYXQgY2FuIGJlIGF3YWl0ZWQsIGpvaW5lZCwgb3JcbiAqIGFib3J0ZWQuXG4gKlxuICogV2hlbiB0aGUgcGFyZW50IGBNaWNyb2AgZmluaXNoZXMsIHRoaXMgYE1pY3JvYCB3aWxsIGJlIGFib3J0ZWQuXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZmliZXIgJiBmb3JraW5nXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JrID0gc2VsZiA9PiB3aXRoTWljcm9GaWJlcihmaWJlciA9PiB7XG4gIGZpYmVyTWlkZGxld2FyZS5pbnRlcnJ1cHRDaGlsZHJlbiA/Pz0gZmliZXJJbnRlcnJ1cHRDaGlsZHJlbjtcbiAgcmV0dXJuIHN1Y2NlZWQodW5zYWZlRm9yayhmaWJlciwgc2VsZikpO1xufSk7XG5jb25zdCB1bnNhZmVGb3JrID0gKHBhcmVudCwgZWZmZWN0LCBpbW1lZGlhdGUgPSBmYWxzZSwgZGFlbW9uID0gZmFsc2UpID0+IHtcbiAgY29uc3QgY2hpbGQgPSBuZXcgTWljcm9GaWJlckltcGwocGFyZW50LmNvbnRleHQsIHBhcmVudC5pbnRlcnJ1cHRpYmxlKTtcbiAgaWYgKCFkYWVtb24pIHtcbiAgICBwYXJlbnQuY2hpbGRyZW4oKS5hZGQoY2hpbGQpO1xuICAgIGNoaWxkLmFkZE9ic2VydmVyKCgpID0+IHBhcmVudC5jaGlsZHJlbigpLmRlbGV0ZShjaGlsZCkpO1xuICB9XG4gIGlmIChpbW1lZGlhdGUpIHtcbiAgICBjaGlsZC5ldmFsdWF0ZShlZmZlY3QpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5nZXRSZWYoQ3VycmVudFNjaGVkdWxlcikuc2NoZWR1bGVUYXNrKCgpID0+IGNoaWxkLmV2YWx1YXRlKGVmZmVjdCksIDApO1xuICB9XG4gIHJldHVybiBjaGlsZDtcbn07XG4vKipcbiAqIFJ1biB0aGUgYE1pY3JvYCBlZmZlY3QgaW4gYSBuZXcgYE1pY3JvRmliZXJgIHRoYXQgY2FuIGJlIGF3YWl0ZWQsIGpvaW5lZCwgb3JcbiAqIGFib3J0ZWQuXG4gKlxuICogSXQgd2lsbCBub3QgYmUgYWJvcnRlZCB3aGVuIHRoZSBwYXJlbnQgYE1pY3JvYCBmaW5pc2hlcy5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmaWJlciAmIGZvcmtpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcmtEYWVtb24gPSBzZWxmID0+IHdpdGhNaWNyb0ZpYmVyKGZpYmVyID0+IHN1Y2NlZWQodW5zYWZlRm9yayhmaWJlciwgc2VsZiwgZmFsc2UsIHRydWUpKSk7XG4vKipcbiAqIFJ1biB0aGUgYE1pY3JvYCBlZmZlY3QgaW4gYSBuZXcgYE1pY3JvRmliZXJgIHRoYXQgY2FuIGJlIGF3YWl0ZWQsIGpvaW5lZCwgb3JcbiAqIGFib3J0ZWQuXG4gKlxuICogVGhlIGxpZmV0aW1lIG9mIHRoZSBoYW5kbGUgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgYE1pY3JvU2NvcGVgLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGZpYmVyICYgZm9ya2luZ1xuICovXG5leHBvcnQgY29uc3QgZm9ya0luID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHNjb3BlKSA9PiB1bmludGVycnVwdGlibGVNYXNrKHJlc3RvcmUgPT4gZmxhdE1hcChzY29wZS5mb3JrLCBzY29wZSA9PiB0YXAocmVzdG9yZShmb3JrRGFlbW9uKG9uRXhpdChzZWxmLCBleGl0ID0+IHNjb3BlLmNsb3NlKGV4aXQpKSkpLCBmaWJlciA9PiBzY29wZS5hZGRGaW5hbGl6ZXIoXyA9PiBmaWJlckludGVycnVwdChmaWJlcikpKSkpKTtcbi8qKlxuICogUnVuIHRoZSBgTWljcm9gIGVmZmVjdCBpbiBhIG5ldyBgTWljcm9GaWJlcmAgdGhhdCBjYW4gYmUgYXdhaXRlZCwgam9pbmVkLCBvclxuICogYWJvcnRlZC5cbiAqXG4gKiBUaGUgbGlmZXRpbWUgb2YgdGhlIGhhbmRsZSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IGBNaWNyb1Njb3BlYC5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBmaWJlciAmIGZvcmtpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcmtTY29wZWQgPSBzZWxmID0+IGZsYXRNYXAoc2NvcGUsIHNjb3BlID0+IGZvcmtJbihzZWxmLCBzY29wZSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZXhlY3V0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGBNaWNyb2AgZWZmZWN0IGFuZCByZXR1cm4gYSBgTWljcm9GaWJlcmAgdGhhdCBjYW4gYmUgYXdhaXRlZCwgam9pbmVkLFxuICogb3IgYWJvcnRlZC5cbiAqXG4gKiBZb3UgY2FuIGxpc3RlbiBmb3IgdGhlIHJlc3VsdCBieSBhZGRpbmcgYW4gb2JzZXJ2ZXIgdXNpbmcgdGhlIGhhbmRsZSdzXG4gKiBgYWRkT2JzZXJ2ZXJgIG1ldGhvZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCAqIGFzIE1pY3JvIGZyb20gXCJlZmZlY3QvTWljcm9cIlxuICpcbiAqIGNvbnN0IGhhbmRsZSA9IE1pY3JvLnN1Y2NlZWQoNDIpLnBpcGUoXG4gKiAgIE1pY3JvLmRlbGF5KDEwMDApLFxuICogICBNaWNyby5ydW5Gb3JrXG4gKiApXG4gKlxuICogaGFuZGxlLmFkZE9ic2VydmVyKChleGl0KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGV4aXQpXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXhlY3V0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Gb3JrID0gKGVmZmVjdCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmaWJlciA9IG5ldyBNaWNyb0ZpYmVySW1wbChDdXJyZW50U2NoZWR1bGVyLmNvbnRleHQob3B0aW9ucz8uc2NoZWR1bGVyID8/IG5ldyBNaWNyb1NjaGVkdWxlckRlZmF1bHQoKSkpO1xuICBmaWJlci5ldmFsdWF0ZShlZmZlY3QpO1xuICBpZiAob3B0aW9ucz8uc2lnbmFsKSB7XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGZpYmVyLnVuc2FmZUludGVycnVwdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhYm9ydCA9ICgpID0+IGZpYmVyLnVuc2FmZUludGVycnVwdCgpO1xuICAgICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgZmliZXIuYWRkT2JzZXJ2ZXIoKCkgPT4gb3B0aW9ucy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWJlcjtcbn07XG4vKipcbiAqIEV4ZWN1dGUgdGhlIGBNaWNyb2AgZWZmZWN0IGFuZCByZXR1cm4gYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZVxuICogYE1pY3JvRXhpdGAgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjQuNlxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGV4ZWN1dGlvblxuICovXG5leHBvcnQgY29uc3QgcnVuUHJvbWlzZUV4aXQgPSAoZWZmZWN0LCBvcHRpb25zKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICBjb25zdCBoYW5kbGUgPSBydW5Gb3JrKGVmZmVjdCwgb3B0aW9ucyk7XG4gIGhhbmRsZS5hZGRPYnNlcnZlcihyZXNvbHZlKTtcbn0pO1xuLyoqXG4gKiBFeGVjdXRlIHRoZSBgTWljcm9gIGVmZmVjdCBhbmQgcmV0dXJuIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAqIHN1Y2Nlc3NmdWwgdmFsdWUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjQuMFxuICogQGV4cGVyaW1lbnRhbFxuICogQGNhdGVnb3J5IGV4ZWN1dGlvblxuICovXG5leHBvcnQgY29uc3QgcnVuUHJvbWlzZSA9IChlZmZlY3QsIG9wdGlvbnMpID0+IHJ1blByb21pc2VFeGl0KGVmZmVjdCwgb3B0aW9ucykudGhlbihleGl0ID0+IHtcbiAgaWYgKGV4aXQuX3RhZyA9PT0gXCJGYWlsdXJlXCIpIHtcbiAgICB0aHJvdyBleGl0LmNhdXNlO1xuICB9XG4gIHJldHVybiBleGl0LnZhbHVlO1xufSk7XG4vKipcbiAqIEF0dGVtcHQgdG8gZXhlY3V0ZSB0aGUgYE1pY3JvYCBlZmZlY3Qgc3luY2hyb25vdXNseSBhbmQgcmV0dXJuIHRoZSBgTWljcm9FeGl0YC5cbiAqXG4gKiBJZiBhbnkgYXN5bmNocm9ub3VzIGVmZmVjdHMgYXJlIGVuY291bnRlcmVkLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYVxuICogYENhdXNlRGllYCBjb250YWluaW5nIHRoZSBgTWljcm9GaWJlcmAuXG4gKlxuICogQHNpbmNlIDMuNC42XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXhlY3V0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBydW5TeW5jRXhpdCA9IGVmZmVjdCA9PiB7XG4gIGNvbnN0IHNjaGVkdWxlciA9IG5ldyBNaWNyb1NjaGVkdWxlckRlZmF1bHQoKTtcbiAgY29uc3QgZmliZXIgPSBydW5Gb3JrKGVmZmVjdCwge1xuICAgIHNjaGVkdWxlclxuICB9KTtcbiAgc2NoZWR1bGVyLmZsdXNoKCk7XG4gIHJldHVybiBmaWJlci5fZXhpdCA/PyBleGl0RGllKGZpYmVyKTtcbn07XG4vKipcbiAqIEF0dGVtcHQgdG8gZXhlY3V0ZSB0aGUgYE1pY3JvYCBlZmZlY3Qgc3luY2hyb25vdXNseSBhbmQgcmV0dXJuIHRoZSBzdWNjZXNzXG4gKiB2YWx1ZS5cbiAqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBleGVjdXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJ1blN5bmMgPSBlZmZlY3QgPT4ge1xuICBjb25zdCBleGl0ID0gcnVuU3luY0V4aXQoZWZmZWN0KTtcbiAgaWYgKGV4aXQuX3RhZyA9PT0gXCJGYWlsdXJlXCIpIHRocm93IGV4aXQuY2F1c2U7XG4gIHJldHVybiBleGl0LnZhbHVlO1xufTtcbmNvbnN0IFlpZWxkYWJsZUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgY2xhc3MgWWllbGRhYmxlRXJyb3IgZXh0ZW5kcyBnbG9iYWxUaGlzLkVycm9yIHt9XG4gIE9iamVjdC5hc3NpZ24oWWllbGRhYmxlRXJyb3IucHJvdG90eXBlLCBNaWNyb1Byb3RvLCBTdHJ1Y3R1cmFsUHJvdG90eXBlLCB7XG4gICAgW2lkZW50aWZpZXJdOiBcIkZhaWx1cmVcIixcbiAgICBbZXZhbHVhdGVdKCkge1xuICAgICAgcmV0dXJuIGZhaWwodGhpcyk7XG4gICAgfSxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgPyBgJHt0aGlzLm5hbWV9OiAke3RoaXMubWVzc2FnZX1gIDogdGhpcy5uYW1lO1xuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpc1xuICAgICAgfTtcbiAgICB9LFxuICAgIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMudG9TdHJpbmcoKX1cXG4ke3N0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpLmpvaW4oXCJcXG5cIil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFlpZWxkYWJsZUVycm9yO1xufSgpO1xuLyoqXG4gKiBAc2luY2UgMy40LjBcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgWWllbGRhYmxlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0oKTtcbi8qKlxuICogQHNpbmNlIDMuNC4wXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3JzXG4gKi9cbmV4cG9ydCBjb25zdCBUYWdnZWRFcnJvciA9IHRhZyA9PiB7XG4gIGNsYXNzIEJhc2UgZXh0ZW5kcyBFcnJvciB7XG4gICAgX3RhZyA9IHRhZztcbiAgfVxuICA7XG4gIEJhc2UucHJvdG90eXBlLm5hbWUgPSB0YWc7XG4gIHJldHVybiBCYXNlO1xufTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNoZWNrZWQgZXhjZXB0aW9uIHdoaWNoIG9jY3VycyB3aGVuIGFuIGV4cGVjdGVkIGVsZW1lbnQgd2FzXG4gKiB1bmFibGUgdG8gYmUgZm91bmQuXG4gKlxuICogQHNpbmNlIDMuNC40XG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uIGV4dGVuZHMgLyojX19QVVJFX18qL1RhZ2dlZEVycm9yKFwiTm9TdWNoRWxlbWVudEV4Y2VwdGlvblwiKSB7fVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hlY2tlZCBleGNlcHRpb24gd2hpY2ggb2NjdXJzIHdoZW4gYSB0aW1lb3V0IG9jY3Vycy5cbiAqXG4gKiBAc2luY2UgMy40LjRcbiAqIEBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFRpbWVvdXRFeGNlcHRpb24gZXh0ZW5kcyAvKiNfX1BVUkVfXyovVGFnZ2VkRXJyb3IoXCJUaW1lb3V0RXhjZXB0aW9uXCIpIHt9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NaWNyby5qcy5tYXAiXSwibmFtZXMiOlsiQXJyIiwiQ29udGV4dCIsIkVmZmVjdGFibGUiLCJFaXRoZXIiLCJFcXVhbCIsImNvbnN0VHJ1ZSIsImNvbnN0Vm9pZCIsImR1YWwiLCJpZGVudGl0eSIsImdsb2JhbFZhbHVlIiwiSGFzaCIsImZvcm1hdCIsIk5vZGVJbnNwZWN0U3ltYm9sIiwidG9TdHJpbmdVbmtub3duIiwiSW50ZXJuYWxDb250ZXh0IiwiZG9Ob3RhdGlvbiIsIlN0cnVjdHVyYWxQcm90b3R5cGUiLCJPcHRpb24iLCJwaXBlQXJndW1lbnRzIiwiaGFzUHJvcGVydHkiLCJpc0l0ZXJhYmxlIiwiaXNUYWdnZWQiLCJTaW5nbGVTaG90R2VuIiwiWWllbGRXcmFwIiwieWllbGRXcmFwR2V0IiwiVHlwZUlkIiwiU3ltYm9sIiwiZm9yIiwiTWljcm9FeGl0VHlwZUlkIiwiaXNNaWNybyIsInUiLCJNaWNyb0NhdXNlVHlwZUlkIiwiaXNNaWNyb0NhdXNlIiwic2VsZiIsIm1pY3JvQ2F1c2VWYXJpYW5jZSIsIl9FIiwiTWljcm9DYXVzZUltcGwiLCJnbG9iYWxUaGlzIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIl90YWciLCJvcmlnaW5hbEVycm9yIiwidHJhY2VzIiwiY2F1c2VOYW1lIiwibmFtZSIsIm1lc3NhZ2UiLCJzdGFjayIsIm1lc3NhZ2VMaW5lcyIsInNwbGl0IiwibGVuZ3RoIiwic2xpY2UiLCJqb2luIiwicGlwZSIsImFyZ3VtZW50cyIsInRvU3RyaW5nIiwiRmFpbCIsImVycm9yIiwiY2F1c2VGYWlsIiwiRGllIiwiZGVmZWN0IiwiY2F1c2VEaWUiLCJJbnRlcnJ1cHQiLCJjYXVzZUludGVycnVwdCIsImNhdXNlSXNGYWlsIiwiY2F1c2VJc0RpZSIsImNhdXNlSXNJbnRlcnJ1cHQiLCJjYXVzZVNxdWFzaCIsImNhdXNlV2l0aFRyYWNlIiwidHJhY2UiLCJNaWNyb0ZpYmVyVHlwZUlkIiwiZmliZXJWYXJpYW5jZSIsIl9BIiwiTWljcm9GaWJlckltcGwiLCJjb250ZXh0IiwiaW50ZXJydXB0aWJsZSIsIl9zdGFjayIsIl9vYnNlcnZlcnMiLCJjdXJyZW50T3BDb3VudCIsIl9pbnRlcnJ1cHRlZCIsIl95aWVsZGVkIiwidW5kZWZpbmVkIiwiZ2V0UmVmIiwicmVmIiwidW5zYWZlR2V0UmVmZXJlbmNlIiwiYWRkT2JzZXJ2ZXIiLCJjYiIsIl9leGl0IiwicHVzaCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInVuc2FmZUludGVycnVwdCIsImV2YWx1YXRlIiwiZXhpdEludGVycnVwdCIsInVuc2FmZVBvbGwiLCJlZmZlY3QiLCJ5aWVsZGVkIiwiZXhpdCIsInJ1bkxvb3AiLCJZaWVsZCIsImludGVycnVwdENoaWxkcmVuIiwiZmliZXJNaWRkbGV3YXJlIiwiZmxhdE1hcCIsImkiLCJ5aWVsZGluZyIsImN1cnJlbnQiLCJDdXJyZW50U2NoZWR1bGVyIiwic2hvdWxkWWllbGQiLCJwcmV2IiwieWllbGROb3ciLCJleGl0RGllIiwiU3RyaW5nIiwiZ2V0Q29udCIsInN5bWJvbCIsIm9wIiwicG9wIiwiY29udCIsImVuc3VyZUNvbnQiLCJ5aWVsZFdpdGgiLCJ2YWx1ZSIsImNoaWxkcmVuIiwiX2NoaWxkcmVuIiwiU2V0IiwiZmliZXJJbnRlcnJ1cHRDaGlsZHJlbiIsImZpYmVyIiwic2l6ZSIsImZpYmVySW50ZXJydXB0QWxsIiwiZmliZXJBd2FpdCIsImFzeW5jIiwicmVzdW1lIiwic3luYyIsInN1Y2NlZWQiLCJmaWJlckpvaW4iLCJmbGF0dGVuIiwiZmliZXJJbnRlcnJ1cHQiLCJzdXNwZW5kIiwiYXNWb2lkIiwiZmliZXJzIiwiaXRlciIsIml0ZXJhdG9yIiwid2FpdCIsInJlc3VsdCIsIm5leHQiLCJkb25lIiwiXyIsImV4aXRWb2lkIiwiaWRlbnRpZmllciIsImFyZ3MiLCJzdWNjZXNzQ29udCIsImZhaWx1cmVDb250IiwibWljcm9WYXJpYW5jZSIsIl9SIiwiTWljcm9Qcm90byIsIkVmZmVjdFByb3RvdHlwZSIsIl9vcCIsInRvSlNPTiIsIl9pZCIsImRlZmF1bHRFdmFsdWF0ZSIsIl9maWJlciIsIm1ha2VQcmltaXRpdmVQcm90byIsIm9wdGlvbnMiLCJldmFsIiwiY29udEEiLCJjb250RSIsImVuc3VyZSIsIm1ha2VQcmltaXRpdmUiLCJQcm90byIsIk9iamVjdCIsImNyZWF0ZSIsInNpbmdsZSIsIm1ha2VFeGl0IiwicHJvcCIsInRoYXQiLCJpc01pY3JvRXhpdCIsImVxdWFscyIsImNhY2hlZCIsImNvbWJpbmUiLCJzdHJpbmciLCJoYXNoIiwiZmFpbENhdXNlIiwiZmFpbCIsImV4aXRTdWNjZWVkIiwieWllbGROb3dXaXRoIiwicmVzdW1lZCIsInNjaGVkdWxlVGFzayIsInN1Y2NlZWRTb21lIiwiYSIsInNvbWUiLCJzdWNjZWVkTm9uZSIsIm5vbmUiLCJmYWlsQ2F1c2VTeW5jIiwiZGllIiwiZmFpbFN5bmMiLCJmcm9tT3B0aW9uIiwib3B0aW9uIiwiTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiIsImZyb21FaXRoZXIiLCJlaXRoZXIiLCJyaWdodCIsImxlZnQiLCJ2b2lkXyIsInZvaWQiLCJ0cnlfIiwidHJ5IiwiZXJyIiwiY2F0Y2giLCJwcm9taXNlIiwiYXN5bmNPcHRpb25zIiwic2lnbmFsIiwidGhlbiIsImUiLCJ0cnlQcm9taXNlIiwid2l0aE1pY3JvRmliZXIiLCJ5aWVsZEZsdXNoIiwiZmx1c2giLCJyZWdpc3RlciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJvbkNhbmNlbCIsImFzeW5jRmluYWxpemVyIiwiYWJvcnQiLCJzZXRJbnRlcnJ1cHRpYmxlIiwiY2F1c2UiLCJuZXZlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZ2VuIiwiZnJvbUl0ZXJhdG9yIiwiY2FsbCIsInN0YXRlIiwiYXMiLCJtYXAiLCJhc1NvbWUiLCJmbGlwIiwibWF0Y2hFZmZlY3QiLCJvbkZhaWx1cmUiLCJvblN1Y2Nlc3MiLCJhbmRUaGVuIiwiZiIsInRhcCIsIm1hdGNoQ2F1c2UiLCJleGl0RmFpbENhdXNlIiwic2FuZGJveCIsImNhdGNoQWxsQ2F1c2UiLCJyYWNlQWxsIiwiYWxsIiwicGFyZW50IiwiZWZmZWN0cyIsImZyb21JdGVyYWJsZSIsImxlbiIsImRvbmVDb3VudCIsImNhdXNlcyIsIm9uRXhpdCIsInVuaW50ZXJydXB0aWJsZSIsInVuc2FmZUZvcmsiLCJhZGQiLCJkZWxldGUiLCJyYWNlQWxsRmlyc3QiLCJyYWNlIiwicmFjZUZpcnN0IiwiT25TdWNjZXNzUHJvdG8iLCJleGl0RmFpbCIsImV4aXRJc1N1Y2Nlc3MiLCJleGl0SXNGYWlsdXJlIiwiZXhpdElzSW50ZXJydXB0IiwiZXhpdElzRmFpbCIsImV4aXRJc0RpZSIsImV4aXRWb2lkQWxsIiwiZXhpdHMiLCJzZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwiTWljcm9TY2hlZHVsZXJEZWZhdWx0IiwidGFzayIsIl9wcmlvcml0eSIsInRhc2tzIiwicnVubmluZyIsImFmdGVyU2NoZWR1bGVkIiwicnVuVGFza3MiLCJNYXhPcHNCZWZvcmVZaWVsZCIsInNlcnZpY2UiLCJ0YWciLCJ1bnNhZmVHZXQiLCJzZXJ2aWNlT3B0aW9uIiwiZ2V0T3B0aW9uIiwidXBkYXRlQ29udGV4dCIsInVwZGF0ZVNlcnZpY2UiLCJnZXRDb250ZXh0IiwicHJvdmlkZUNvbnRleHQiLCJwcm92aWRlZCIsIm1lcmdlIiwicHJvdmlkZVNlcnZpY2UiLCJwcm92aWRlU2VydmljZUVmZmVjdCIsImFjcXVpcmUiLCJSZWZlcmVuY2UiLCJkZWZhdWx0VmFsdWUiLCJDdXJyZW50Q29uY3VycmVuY3kiLCJ3aXRoQ29uY3VycmVuY3kiLCJjb25jdXJyZW5jeSIsInppcCIsInppcFdpdGgiLCJhMiIsImNvbmN1cnJlbnQiLCJmaWx0ZXJPckZhaWxDYXVzZSIsInJlZmluZW1lbnQiLCJvckZhaWxXaXRoIiwiZmlsdGVyT3JGYWlsIiwid2hlbiIsImNvbmRpdGlvbiIsInBhc3MiLCJyZXBlYXRFeGl0Iiwic3RhcnRlZEF0Iiwic2NoZWR1bGUiLCJEYXRlIiwibm93IiwiYXR0ZW1wdCIsImxvb3AiLCJ3aGlsZSIsInRpbWVzIiwiZGVsYXlFZmZlY3QiLCJlbGFwc2VkIiwiZHVyYXRpb24iLCJpc05vbmUiLCJzbGVlcCIsInJlcGVhdCIsInJlcGxpY2F0ZSIsIm4iLCJBcnJheSIsImZyb20iLCJyZXBsaWNhdGVFZmZlY3QiLCJmb3JldmVyIiwic2NoZWR1bGVSZWN1cnMiLCJzY2hlZHVsZVNwYWNlZCIsIm1pbGxpcyIsInNjaGVkdWxlRXhwb25lbnRpYWwiLCJiYXNlTWlsbGlzIiwiZmFjdG9yIiwiTWF0aCIsInBvdyIsInNjaGVkdWxlQWRkRGVsYXkiLCJzY2hlZHVsZVdpdGhNYXhEZWxheSIsIm1heCIsIm1pbiIsInNjaGVkdWxlV2l0aE1heEVsYXBzZWQiLCJzY2hlZHVsZVVuaW9uIiwiZDEiLCJkMiIsInNjaGVkdWxlSW50ZXJzZWN0IiwiT25GYWlsdXJlUHJvdG8iLCJjYXRjaENhdXNlSWYiLCJwcmVkaWNhdGUiLCJjYXRjaEFsbCIsImNhdGNoQWxsRGVmZWN0IiwidGFwRXJyb3JDYXVzZSIsInRhcEVycm9yQ2F1c2VJZiIsInRhcEVycm9yIiwidGFwRGVmZWN0IiwiY2F0Y2hJZiIsImNhdGNoVGFnIiwiayIsIm1hcEVycm9yQ2F1c2UiLCJtYXBFcnJvciIsIm9yRGllIiwib3JFbHNlU3VjY2VlZCIsImlnbm9yZSIsImlnbm9yZUxvZ2dlZCIsImNvbnNvbGUiLCJtYXRjaCIsInJldHJ5Iiwid2l0aFRyYWNlIiwicHJldkxpbWl0Iiwic3RhY2tUcmFjZUxpbWl0IiwiZ2VuZXJhdGUiLCJsaW5lIiwidHJpbSIsInJlcGxhY2UiLCJsaW5lTWF0Y2giLCJvbkVycm9yIiwibWF0Y2hDYXVzZUVmZmVjdCIsInByaW1pdGl2ZSIsIk9uU3VjY2Vzc0FuZEZhaWx1cmVQcm90byIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJkZWxheSIsInRpbWVvdXRPckVsc2UiLCJvblRpbWVvdXQiLCJUaW1lb3V0RXhjZXB0aW9uIiwidGltZW91dE9wdGlvbiIsIk1pY3JvU2NvcGVUeXBlSWQiLCJNaWNyb1Njb3BlIiwiR2VuZXJpY1RhZyIsIk1pY3JvU2NvcGVJbXBsIiwiZmluYWxpemVycyIsInVuc2FmZUFkZEZpbmFsaXplciIsImZpbmFsaXplciIsImFkZEZpbmFsaXplciIsInVuc2FmZVJlbW92ZUZpbmFsaXplciIsImNsb3NlIiwibWljcm9FeGl0IiwicmV2ZXJzZSIsImZvckVhY2giLCJmb3JrIiwibmV3U2NvcGUiLCJmaW4iLCJzY29wZU1ha2UiLCJzY29wZVVuc2FmZU1ha2UiLCJzY29wZSIsInByb3ZpZGVTY29wZSIsInNjb3BlZCIsImFjcXVpcmVSZWxlYXNlIiwicmVsZWFzZSIsInVuaW50ZXJydXB0aWJsZU1hc2siLCJyZXN0b3JlIiwiZW5zdXJpbmciLCJvbkV4aXRJZiIsIm9uSW50ZXJydXB0IiwiYWNxdWlyZVVzZVJlbGVhc2UiLCJ1c2UiLCJpbnRlcnJ1cHQiLCJhcmciLCJpc0FycmF5IiwiZGlzY2FyZCIsInZhbHVlcyIsIm91dCIsImVudHJpZXMiLCJrZXkiLCJ3aGlsZUxvb3AiLCJzdGVwIiwiYm9keSIsIml0ZXJhYmxlIiwiY29uY3VycmVuY3lPcHRpb24iLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsIml0ZW1zIiwiYiIsImluUHJvZ3Jlc3MiLCJwdW1waW5nIiwiaW50ZXJydXB0ZWQiLCJwdW1wIiwiY3VycmVudEluZGV4IiwiaXRlbSIsImNoaWxkIiwiZmlsdGVyIiwiZmlsdGVyTWFwIiwibmVnYXRlIiwibyIsIkRvIiwiYmluZFRvIiwiYmluZCIsImxldF8iLCJsZXQiLCJpbW1lZGlhdGUiLCJkYWVtb24iLCJmb3JrRGFlbW9uIiwiZm9ya0luIiwiZm9ya1Njb3BlZCIsInJ1bkZvcmsiLCJzY2hlZHVsZXIiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicnVuUHJvbWlzZUV4aXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9yZWplY3QiLCJoYW5kbGUiLCJydW5Qcm9taXNlIiwicnVuU3luY0V4aXQiLCJydW5TeW5jIiwiWWllbGRhYmxlRXJyb3IiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJUYWdnZWRFcnJvciIsIkJhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Micro.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Option.js":
/*!************************************************!*\
  !*** ./node_modules/effect/dist/esm/Option.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Do: () => (/* binding */ Do),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   andThen: () => (/* binding */ andThen),\n/* harmony export */   ap: () => (/* binding */ ap),\n/* harmony export */   as: () => (/* binding */ as),\n/* harmony export */   asVoid: () => (/* binding */ asVoid),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   composeK: () => (/* binding */ composeK),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   containsWith: () => (/* binding */ containsWith),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   firstSomeOf: () => (/* binding */ firstSomeOf),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatMapNullable: () => (/* binding */ flatMapNullable),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   fromIterable: () => (/* binding */ fromIterable),\n/* harmony export */   fromNullable: () => (/* binding */ fromNullable),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getLeft: () => (/* binding */ getLeft),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   getOrNull: () => (/* binding */ getOrNull),\n/* harmony export */   getOrThrow: () => (/* binding */ getOrThrow),\n/* harmony export */   getOrThrowWith: () => (/* binding */ getOrThrowWith),\n/* harmony export */   getOrUndefined: () => (/* binding */ getOrUndefined),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getRight: () => (/* binding */ getRight),\n/* harmony export */   isNone: () => (/* binding */ isNone),\n/* harmony export */   isOption: () => (/* binding */ isOption),\n/* harmony export */   isSome: () => (/* binding */ isSome),\n/* harmony export */   \"let\": () => (/* binding */ let_),\n/* harmony export */   lift2: () => (/* binding */ lift2),\n/* harmony export */   liftNullable: () => (/* binding */ liftNullable),\n/* harmony export */   liftPredicate: () => (/* binding */ liftPredicate),\n/* harmony export */   liftThrowable: () => (/* binding */ liftThrowable),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   orElse: () => (/* binding */ orElse),\n/* harmony export */   orElseEither: () => (/* binding */ orElseEither),\n/* harmony export */   orElseSome: () => (/* binding */ orElseSome),\n/* harmony export */   partitionMap: () => (/* binding */ partitionMap),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   reduceCompact: () => (/* binding */ reduceCompact),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toRefinement: () => (/* binding */ toRefinement),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   zipLeft: () => (/* binding */ zipLeft),\n/* harmony export */   zipRight: () => (/* binding */ zipRight),\n/* harmony export */   zipWith: () => (/* binding */ zipWith)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal/doNotation.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\");\n/* harmony import */ var _internal_either_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/either.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/either.js\");\n/* harmony import */ var _internal_option_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/option.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/option.js\");\n/* harmony import */ var _Order_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Order.js */ \"(ssr)/./node_modules/effect/dist/esm/Order.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n\n\n\n\n\n\n\n\n/**\n * @category symbols\n * @since 2.0.0\n */ const TypeId = /*#__PURE__*/ Symbol.for(\"effect/Option\");\n/**\n * Creates a new `Option` that represents the absence of a value.\n *\n * @category constructors\n * @since 2.0.0\n */ const none = ()=>_internal_option_js__WEBPACK_IMPORTED_MODULE_0__.none;\n/**\n * Creates a new `Option` that wraps the given value.\n *\n * @param value - The value to wrap.\n *\n * @category constructors\n * @since 2.0.0\n */ const some = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.some;\n/**\n * Checks if a given value is an `Option` value.\n *\n * @param input - The value to check.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.isOption(Option.some(1)), true)\n * assert.deepStrictEqual(Option.isOption(Option.none()), true)\n * assert.deepStrictEqual(Option.isOption({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isOption = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.isOption;\n/**\n * Determine if a `Option` is a `None`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.isNone(Option.some(1)), false)\n * assert.deepStrictEqual(Option.isNone(Option.none()), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNone = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.isNone;\n/**\n * Determine if a `Option` is a `Some`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.isSome(Option.some(1)), true)\n * assert.deepStrictEqual(Option.isSome(Option.none()), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isSome = _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.isSome;\n/**\n * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`\n * function when passed the `Option`'s value.\n *\n * @param self - The `Option` to match\n * @param onNone - The value to be returned if the `Option` is `None`\n * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(Option.some(1), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a some containing 1'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(Option.none(), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a none'\n * )\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */ const match = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, { onNone, onSome })=>isNone(self) ? onNone() : onSome(self.value));\n/**\n * Returns a type guard from a `Option` returning function.\n * This function ensures that a type guard definition is type-safe.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parsePositive = (n: number): Option.Option<number> =>\n *   n > 0 ? Option.some(n) : Option.none()\n *\n * const isPositive = Option.toRefinement(parsePositive)\n *\n * assert.deepStrictEqual(isPositive(1), true)\n * assert.deepStrictEqual(isPositive(-1), false)\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const toRefinement = (f)=>(a)=>isSome(f(a));\n/**\n * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`\n * if the `Iterable` is not empty, otherwise returns `None`.\n *\n * @param collection - The `Iterable` to be converted to an `Option`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.fromIterable([1, 2, 3]), Option.some(1))\n * assert.deepStrictEqual(Option.fromIterable([]), Option.none())\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const fromIterable = (collection)=>{\n    for (const a of collection){\n        return some(a);\n    }\n    return none();\n};\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @example\n * ```ts\n * import { Option, Either } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Option.getRight(Either.left('err')), Option.none())\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const getRight = _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * ```ts\n * import { Option, Either } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getLeft(Either.right(\"ok\")), Option.none())\n * assert.deepStrictEqual(Option.getLeft(Either.left(\"a\")), Option.some(\"a\"))\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const getLeft = _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.getLeft;\n/**\n * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`\n *\n * @param self - The `Option` to get the value of.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(pipe(Option.some(1), Option.getOrElse(() => 0)), 1)\n * assert.deepStrictEqual(pipe(Option.none(), Option.getOrElse(() => 0)), 0)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrElse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNone)=>isNone(self) ? onNone() : self.value);\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.none(),\n *     Option.orElse(() => Option.none())\n *   ),\n *   Option.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some('a'),\n *     Option.orElse(() => Option.none())\n *   ),\n *   Option.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.none(),\n *     Option.orElse(() => Option.some('b'))\n *   ),\n *   Option.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some('a'),\n *     Option.orElse(() => Option.some('b'))\n *   ),\n *   Option.some('a')\n * )\n * ```\n *\n * @category error handling\n * @since 2.0.0\n */ const orElse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>isNone(self) ? that() : self);\n/**\n * Returns the provided default value as `Some` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.none(),\n *     Option.orElseSome(() => 'b')\n *   ),\n *   Option.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some('a'),\n *     Option.orElseSome(() => 'b')\n *   ),\n *   Option.some('a')\n * )\n * ```\n *\n * @category error handling\n * @since 2.0.0\n */ const orElseSome = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNone)=>isNone(self) ? some(onNone()) : self);\n/**\n * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,\n * which contains information about which of the two `Option`s has been chosen.\n *\n * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The second `Option` to be considered if the first `Option` is `None`.\n *\n * @category error handling\n * @since 2.0.0\n */ const orElseEither = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>isNone(self) ? map(that(), _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.right) : map(self, _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.left));\n/**\n * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.\n *\n * @param collection - An iterable collection of `Option` to be searched.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.firstSomeOf([Option.none(), Option.some(1), Option.some(2)]), Option.some(1))\n * ```\n *\n * @category error handling\n * @since 2.0.0\n */ const firstSomeOf = (collection)=>{\n    let out = none();\n    for (out of collection){\n        if (isSome(out)) {\n            return out;\n        }\n    }\n    return out;\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @param nullableValue - The nullable value to be converted to an `Option`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.fromNullable(undefined), Option.none())\n * assert.deepStrictEqual(Option.fromNullable(null), Option.none())\n * assert.deepStrictEqual(Option.fromNullable(1), Option.some(1))\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const fromNullable = (nullableValue)=>nullableValue == null ? none() : some(nullableValue);\n/**\n * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = Option.liftNullable(parse)\n *\n * assert.deepStrictEqual(parseOption('1'), Option.some(1))\n * assert.deepStrictEqual(parseOption('not a number'), Option.none())\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const liftNullable = (f)=>(...a)=>fromNullable(f(...a));\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrNull(Option.some(1)), 1)\n * assert.deepStrictEqual(Option.getOrNull(Option.none()), null)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrNull = /*#__PURE__*/ getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constNull);\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrUndefined(Option.some(1)), 1)\n * assert.deepStrictEqual(Option.getOrUndefined(Option.none()), undefined)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getOrUndefined = /*#__PURE__*/ getOrElse(_Function_js__WEBPACK_IMPORTED_MODULE_1__.constUndefined);\n/**\n * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.\n *\n * This function is useful for any function that might throw an exception, allowing the developer to handle\n * the exception in a more functional way.\n *\n * @param f - the function that can throw exceptions.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = Option.liftThrowable(JSON.parse)\n *\n * assert.deepStrictEqual(parse(\"1\"), Option.some(1))\n * assert.deepStrictEqual(parse(\"\"), Option.none())\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const liftThrowable = (f)=>(...a)=>{\n        try {\n            return some(f(...a));\n        } catch (e) {\n            return none();\n        }\n    };\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Option` to extract the value from.\n * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const getOrThrowWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, onNone)=>{\n    if (isSome(self)) {\n        return self.value;\n    }\n    throw onNone();\n});\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Option` to extract the value from.\n * @throws `Error(\"getOrThrow called on a None\")`\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\n * assert.throws(() => Option.getOrThrow(Option.none()))\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const getOrThrow = /*#__PURE__*/ getOrThrowWith(()=>new Error(\"getOrThrow called on a None\"));\n/**\n * Maps the `Some` side of an `Option` value to a new `Option` value.\n *\n * @param self - An `Option` to map\n * @param f - The function to map over the value of the `Option`\n *\n * @category mapping\n * @since 2.0.0\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isNone(self) ? none() : some(f(self.value)));\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.0.0\n */ const as = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, b)=>map(self, ()=>b));\n/**\n * Maps the `Some` value of this `Option` to the `void` constant value.\n *\n * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.\n *\n * @category mapping\n * @since 2.0.0\n */ const asVoid = /*#__PURE__*/ as(undefined);\nconst void_ = /*#__PURE__*/ some(undefined);\n\n/**\n * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isNone(self) ? none() : f(self.value));\n/**\n * Executes a sequence of two `Option`s. The second `Option` can be dependent on the result of the first `Option`.\n *\n * @category sequencing\n * @since 2.0.0\n */ const andThen = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>flatMap(self, (a)=>{\n        const b = (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f) ? f(a) : f;\n        return isOption(b) ? b : some(b);\n    }));\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some(employee1),\n *     Option.flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   Option.some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Option.some(employee2),\n *     Option.flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   Option.none()\n * )\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */ const flatMapNullable = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isNone(self) ? none() : fromNullable(f(self.value)));\n/**\n * @category sequencing\n * @since 2.0.0\n */ const flatten = /*#__PURE__*/ flatMap(_Function_js__WEBPACK_IMPORTED_MODULE_1__.identity);\n/**\n * @category zipping\n * @since 2.0.0\n */ const zipRight = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>flatMap(self, ()=>that));\n/**\n * @category sequencing\n * @since 2.0.0\n */ const composeK = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (afb, bfc)=>(a)=>flatMap(afb(a), bfc));\n/**\n * Sequences the specified `that` `Option` but ignores its value.\n *\n * It is useful when we want to chain multiple operations, but only care about the result of `self`.\n *\n * @param that - The `Option` that will be ignored in the chain and discarded\n * @param self - The `Option` we care about\n *\n * @category zipping\n * @since 2.0.0\n */ const zipLeft = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>tap(self, ()=>that));\n/**\n * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`\n * unless `f` returns `None`, in which case it returns `None`.\n *\n * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.\n *\n * @param f - Function to apply to the value of the `Option` if it is `Some`\n * @param self - The `Option` to apply the function to\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n *\n * assert.deepStrictEqual(Option.tap(Option.none(), getInteger), Option.none())\n * assert.deepStrictEqual(Option.tap(Option.some(1), getInteger), Option.some(1))\n * assert.deepStrictEqual(Option.tap(Option.some(1.14), getInteger), Option.none())\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */ const tap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>flatMap(self, (a)=>map(f(a), ()=>a)));\n/**\n * @category combining\n * @since 2.0.0\n */ const product = (self, that)=>isSome(self) && isSome(that) ? some([\n        self.value,\n        that.value\n    ]) : none();\n/**\n * @category combining\n * @since 2.0.0\n */ const productMany = (self, collection)=>{\n    if (isNone(self)) {\n        return none();\n    }\n    const out = [\n        self.value\n    ];\n    for (const o of collection){\n        if (isNone(o)) {\n            return none();\n        }\n        out.push(o.value);\n    }\n    return some(out);\n};\n/**\n * Takes a structure of `Option`s and returns an `Option` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Option` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Option` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Option` will contain an array.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.all([Option.some(1), Option.some(2)]), Option.some([1, 2]))\n * assert.deepStrictEqual(Option.all({ a: Option.some(1), b: Option.some(\"hello\") }), Option.some({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Option.all({ a: Option.some(1), b: Option.none() }), Option.none())\n * ```\n *\n * @category combining\n * @since 2.0.0\n */ // @ts-expect-error\nconst all = (input)=>{\n    if (Symbol.iterator in input) {\n        const out = [];\n        for (const o of input){\n            if (isNone(o)) {\n                return none();\n            }\n            out.push(o.value);\n        }\n        return some(out);\n    }\n    const out = {};\n    for (const key of Object.keys(input)){\n        const o = input[key];\n        if (isNone(o)) {\n            return none();\n        }\n        out[key] = o.value;\n    }\n    return some(out);\n};\n/**\n * Zips two `Option` values together using a provided function, returning a new `Option` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * type Complex = [real: number, imaginary: number]\n *\n * const complex = (real: number, imaginary: number): Complex => [real, imaginary]\n *\n * assert.deepStrictEqual(Option.zipWith(Option.none(), Option.none(), complex), Option.none())\n * assert.deepStrictEqual(Option.zipWith(Option.some(1), Option.none(), complex), Option.none())\n * assert.deepStrictEqual(Option.zipWith(Option.none(), Option.some(1), complex), Option.none())\n * assert.deepStrictEqual(Option.zipWith(Option.some(1), Option.some(2), complex), Option.some([1, 2]))\n *\n * assert.deepStrictEqual(Option.zipWith(Option.some(1), complex)(Option.some(2)), Option.some([2, 1]))\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */ const zipWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, that, f)=>map(product(self, that), ([a, b])=>f(a, b)));\n/**\n * @category combining\n * @since 2.0.0\n */ const ap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>zipWith(self, that, (f, a)=>f(a)));\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.\n *\n * @param self - The Iterable of `Option<A>` to be reduced.\n * @param b - The initial value of the accumulator.\n * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n * assert.deepStrictEqual(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)), 3)\n * ```\n *\n * @category folding\n * @since 2.0.0\n */ const reduceCompact = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(3, (self, b, f)=>{\n    let out = b;\n    for (const oa of self){\n        if (isSome(oa)) {\n            out = f(out, oa.value);\n        }\n    }\n    return out;\n});\n/**\n * Transforms an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, the value is wrapped in an array.\n *\n * @param self - The `Option` to convert to an array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.toArray(Option.some(1)), [1])\n * assert.deepStrictEqual(Option.toArray(Option.none()), [])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const toArray = (self)=>isNone(self) ? [] : [\n        self.value\n    ];\n/**\n * @category filtering\n * @since 2.0.0\n */ const partitionMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>{\n    if (isNone(self)) {\n        return [\n            none(),\n            none()\n        ];\n    }\n    const e = f(self.value);\n    return _internal_either_js__WEBPACK_IMPORTED_MODULE_2__.isLeft(e) ? [\n        some(e.left),\n        none()\n    ] : [\n        none(),\n        some(e.right)\n    ];\n});\n/**\n * Maps over the value of an `Option` and filters out `None`s.\n *\n * Useful when in addition to filtering you also want to change the type of the `Option`.\n *\n * @param self - The `Option` to map over.\n * @param f - A function to apply to the value of the `Option`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const evenNumber = (n: number) => n % 2 === 0 ? Option.some(n) : Option.none()\n *\n * assert.deepStrictEqual(Option.filterMap(Option.none(), evenNumber), Option.none())\n * assert.deepStrictEqual(Option.filterMap(Option.some(3), evenNumber), Option.none())\n * assert.deepStrictEqual(Option.filterMap(Option.some(2), evenNumber), Option.some(2))\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const filterMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, f)=>isNone(self) ? none() : f(self.value));\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @param predicate - A predicate function to apply to the `Option` value.\n * @param fb - The `Option` to filter.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // predicate\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(Option.filter(Option.none(), isEven), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some(3), isEven), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some(2), isEven), Option.some(2))\n *\n * // refinement\n * const isNumber = (v: unknown): v is number => typeof v === \"number\"\n *\n * assert.deepStrictEqual(Option.filter(Option.none(), isNumber), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some('hello'), isNumber), Option.none())\n * assert.deepStrictEqual(Option.filter(Option.some(2), isNumber), Option.some(2))\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const filter = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, predicate)=>filterMap(self, (b)=>predicate(b) ? _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.some(b) : _internal_option_js__WEBPACK_IMPORTED_MODULE_0__.none));\n/**\n * @example\n * ```ts\n * import { Option, Number } from \"effect\"\n *\n * const isEquivalent = Option.getEquivalence(Number.Equivalence)\n * assert.deepStrictEqual(isEquivalent(Option.none(), Option.none()), true)\n * assert.deepStrictEqual(isEquivalent(Option.none(), Option.some(1)), false)\n * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.none()), false)\n * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(2)), false)\n * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(1)), true)\n * ```\n *\n * @category equivalence\n * @since 2.0.0\n */ const getEquivalence = (isEquivalent)=>_Equivalence_js__WEBPACK_IMPORTED_MODULE_3__.make((x, y)=>isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * ```ts\n * import { pipe, Option, Number } from \"effect\"\n *\n * const O = Option.getOrder(Number.Order)\n * assert.deepStrictEqual(O(Option.none(), Option.none()), 0)\n * assert.deepStrictEqual(O(Option.none(), Option.some(1)), -1)\n * assert.deepStrictEqual(O(Option.some(1), Option.none()), 1)\n * assert.deepStrictEqual(O(Option.some(1), Option.some(2)), -1)\n * assert.deepStrictEqual(O(Option.some(1), Option.some(1)), 0)\n * ```\n *\n * @category sorting\n * @since 2.0.0\n */ const getOrder = (O)=>_Order_js__WEBPACK_IMPORTED_MODULE_4__.make((self, that)=>isSome(self) ? isSome(that) ? O(self.value, that.value) : 1 : -1);\n/**\n * Lifts a binary function into `Option`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 2.0.0\n */ const lift2 = (f)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, that)=>zipWith(self, that, f));\n/**\n * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`\n * if the predicate returns `false`.\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const getOption = Option.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), Option.none())\n * assert.deepStrictEqual(getOption(1), Option.some(1))\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */ const liftPredicate = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (b, predicate)=>predicate(b) ? some(b) : none());\n/**\n * Returns a function that checks if a `Option` contains a given value using a provided `isEquivalent` function.\n *\n * @param equivalent - An `Equivalence` instance to compare values of the `Option`.\n * @param self - The `Option` to apply the comparison to.\n * @param a - The value to compare against the `Option`.\n *\n * @example\n * ```ts\n * import { pipe, Option, Number } from \"effect\"\n *\n * assert.deepStrictEqual(pipe(Option.some(2), Option.containsWith(Number.Equivalence)(2)), true)\n * assert.deepStrictEqual(pipe(Option.some(1), Option.containsWith(Number.Equivalence)(2)), false)\n * assert.deepStrictEqual(pipe(Option.none(), Option.containsWith(Number.Equivalence)(2)), false)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */ const containsWith = (isEquivalent)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, a)=>isNone(self) ? false : isEquivalent(self.value, a));\nconst _equivalence = /*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_5__.equivalence();\n/**\n * Returns a function that checks if an `Option` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */ const contains = /*#__PURE__*/ containsWith(_equivalence);\n/**\n * Check if a value in an `Option` type meets a certain predicate.\n *\n * @param self - The `Option` to check.\n * @param predicate - The condition to check.\n *\n * @example\n * ```ts\n * import { pipe, Option } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(pipe(Option.some(2), Option.exists(isEven)), true)\n * assert.deepStrictEqual(pipe(Option.some(1), Option.exists(isEven)), false)\n * assert.deepStrictEqual(pipe(Option.none(), Option.exists(isEven)), false)\n * ```\n *\n * @since 2.0.0\n */ const exists = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (self, refinement)=>isNone(self) ? false : refinement(self.value));\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */ const bindTo = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__.bindTo(map);\nconst let_ = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__.let_(map);\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */ const bind = /*#__PURE__*/ _internal_doNotation_js__WEBPACK_IMPORTED_MODULE_6__.bind(map, flatMap);\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */ const Do = /*#__PURE__*/ some({});\nconst adapter = /*#__PURE__*/ _Utils_js__WEBPACK_IMPORTED_MODULE_7__.adapter();\n/**\n * @category generators\n * @since 2.0.0\n */ const gen = (...args)=>{\n    let f;\n    if (args.length === 1) {\n        f = args[0];\n    } else {\n        f = args[1].bind(args[0]);\n    }\n    const iterator = f(adapter);\n    let state = iterator.next();\n    if (state.done) {\n        return some(state.value);\n    } else {\n        let current = state.value;\n        if (_Utils_js__WEBPACK_IMPORTED_MODULE_7__.isGenKind(current)) {\n            current = current.value;\n        } else {\n            current = _Utils_js__WEBPACK_IMPORTED_MODULE_7__.yieldWrapGet(current);\n        }\n        if (isNone(current)) {\n            return current;\n        }\n        while(!state.done){\n            state = iterator.next(current.value);\n            if (!state.done) {\n                current = state.value;\n                if (_Utils_js__WEBPACK_IMPORTED_MODULE_7__.isGenKind(current)) {\n                    current = current.value;\n                } else {\n                    current = _Utils_js__WEBPACK_IMPORTED_MODULE_7__.yieldWrapGet(current);\n                }\n                if (isNone(current)) {\n                    return current;\n                }\n            }\n        }\n        return some(state.value);\n    }\n}; //# sourceMappingURL=Option.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL09wdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNZO0FBQ3NDO0FBQy9CO0FBQ1I7QUFDQTtBQUNYO0FBQ0Y7QUFDbEM7OztDQUdDLEdBQ00sTUFBTVksU0FBUyxXQUFXLEdBQUVDLE9BQU9DLEdBQUcsQ0FBQyxpQkFBaUI7QUFDL0Q7Ozs7O0NBS0MsR0FDTSxNQUFNQyxPQUFPLElBQU1OLHFEQUFXLENBQUM7QUFDdEM7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1PLE9BQU9QLHFEQUFXLENBQUM7QUFDaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNUSxXQUFXUix5REFBZSxDQUFDO0FBQ3hDOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLE1BQU1TLFNBQVNULHVEQUFhLENBQUM7QUFDcEM7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTVUsU0FBU1YsdURBQWEsQ0FBQztBQUNwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNNLE1BQU1XLFFBQVEsV0FBVyxHQUFFaEIsa0RBQUlBLENBQUMsR0FBRyxDQUFDaUIsTUFBTSxFQUMvQ0MsTUFBTSxFQUNOQyxNQUFNLEVBQ1AsR0FBS0wsT0FBT0csUUFBUUMsV0FBV0MsT0FBT0YsS0FBS0csS0FBSyxHQUFHO0FBQ3BEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sTUFBTUMsZUFBZUMsQ0FBQUEsSUFBS0MsQ0FBQUEsSUFBS1IsT0FBT08sRUFBRUMsSUFBSTtBQUNuRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1DLGVBQWVDLENBQUFBO0lBQzFCLEtBQUssTUFBTUYsS0FBS0UsV0FBWTtRQUMxQixPQUFPYixLQUFLVztJQUNkO0lBQ0EsT0FBT1o7QUFDVCxFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7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RixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL09wdGlvbi5qcz8xZTg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuL0VxdWFsLmpzXCI7XG5pbXBvcnQgKiBhcyBFcXVpdmFsZW5jZSBmcm9tIFwiLi9FcXVpdmFsZW5jZS5qc1wiO1xuaW1wb3J0IHsgY29uc3ROdWxsLCBjb25zdFVuZGVmaW5lZCwgZHVhbCwgaWRlbnRpdHksIGlzRnVuY3Rpb24gfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgZG9Ob3RhdGlvbiBmcm9tIFwiLi9pbnRlcm5hbC9kb05vdGF0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBlaXRoZXIgZnJvbSBcIi4vaW50ZXJuYWwvZWl0aGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBvcHRpb24gZnJvbSBcIi4vaW50ZXJuYWwvb3B0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBvcmRlciBmcm9tIFwiLi9PcmRlci5qc1wiO1xuaW1wb3J0ICogYXMgR2VuIGZyb20gXCIuL1V0aWxzLmpzXCI7XG4vKipcbiAqIEBjYXRlZ29yeSBzeW1ib2xzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L09wdGlvblwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgT3B0aW9uYCB0aGF0IHJlcHJlc2VudHMgdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG5vbmUgPSAoKSA9PiBvcHRpb24ubm9uZTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgT3B0aW9uYCB0aGF0IHdyYXBzIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSBvcHRpb24uc29tZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gYE9wdGlvbmAgdmFsdWUuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uaXNPcHRpb24oT3B0aW9uLnNvbWUoMSkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uaXNPcHRpb24oT3B0aW9uLm5vbmUoKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5pc09wdGlvbih7fSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc09wdGlvbiA9IG9wdGlvbi5pc09wdGlvbjtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgYE9wdGlvbmAgaXMgYSBgTm9uZWAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5pc05vbmUoT3B0aW9uLnNvbWUoMSkpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmlzTm9uZShPcHRpb24ubm9uZSgpKSwgdHJ1ZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNOb25lID0gb3B0aW9uLmlzTm9uZTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgYE9wdGlvbmAgaXMgYSBgU29tZWAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gY2hlY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5pc1NvbWUoT3B0aW9uLnNvbWUoMSkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uaXNTb21lKE9wdGlvbi5ub25lKCkpLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNTb21lID0gb3B0aW9uLmlzU29tZTtcbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gYE9wdGlvbmAgYW5kIHJldHVybnMgZWl0aGVyIHRoZSBwcm92aWRlZCBgb25Ob25lYCB2YWx1ZSBvciB0aGUgcmVzdWx0IG9mIHRoZSBwcm92aWRlZCBgb25Tb21lYFxuICogZnVuY3Rpb24gd2hlbiBwYXNzZWQgdGhlIGBPcHRpb25gJ3MgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gbWF0Y2hcbiAqIEBwYXJhbSBvbk5vbmUgLSBUaGUgdmFsdWUgdG8gYmUgcmV0dXJuZWQgaWYgdGhlIGBPcHRpb25gIGlzIGBOb25lYFxuICogQHBhcmFtIG9uU29tZSAtIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaWYgdGhlIGBPcHRpb25gIGlzIGBTb21lYCwgaXQgd2lsbCBiZSBwYXNzZWQgdGhlIGBPcHRpb25gJ3MgdmFsdWUgYW5kIGl0cyByZXN1bHQgd2lsbCBiZSByZXR1cm5lZFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcGlwZSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShPcHRpb24uc29tZSgxKSwgT3B0aW9uLm1hdGNoKHsgb25Ob25lOiAoKSA9PiAnYSBub25lJywgb25Tb21lOiAoYSkgPT4gYGEgc29tZSBjb250YWluaW5nICR7YX1gIH0pKSxcbiAqICAgJ2Egc29tZSBjb250YWluaW5nIDEnXG4gKiApXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShPcHRpb24ubm9uZSgpLCBPcHRpb24ubWF0Y2goeyBvbk5vbmU6ICgpID0+ICdhIG5vbmUnLCBvblNvbWU6IChhKSA9PiBgYSBzb21lIGNvbnRhaW5pbmcgJHthfWAgfSkpLFxuICogICAnYSBub25lJ1xuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IHBhdHRlcm4gbWF0Y2hpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWF0Y2ggPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwge1xuICBvbk5vbmUsXG4gIG9uU29tZVxufSkgPT4gaXNOb25lKHNlbGYpID8gb25Ob25lKCkgOiBvblNvbWUoc2VsZi52YWx1ZSkpO1xuLyoqXG4gKiBSZXR1cm5zIGEgdHlwZSBndWFyZCBmcm9tIGEgYE9wdGlvbmAgcmV0dXJuaW5nIGZ1bmN0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSB0eXBlIGd1YXJkIGRlZmluaXRpb24gaXMgdHlwZS1zYWZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcGFyc2VQb3NpdGl2ZSA9IChuOiBudW1iZXIpOiBPcHRpb24uT3B0aW9uPG51bWJlcj4gPT5cbiAqICAgbiA+IDAgPyBPcHRpb24uc29tZShuKSA6IE9wdGlvbi5ub25lKClcbiAqXG4gKiBjb25zdCBpc1Bvc2l0aXZlID0gT3B0aW9uLnRvUmVmaW5lbWVudChwYXJzZVBvc2l0aXZlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQb3NpdGl2ZSgxKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQb3NpdGl2ZSgtMSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHRvUmVmaW5lbWVudCA9IGYgPT4gYSA9PiBpc1NvbWUoZihhKSk7XG4vKipcbiAqIENvbnZlcnRzIGFuIGBJdGVyYWJsZWAgb2YgdmFsdWVzIGludG8gYW4gYE9wdGlvbmAuIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSBgSXRlcmFibGVgIHdyYXBwZWQgaW4gYSBgU29tZWBcbiAqIGlmIHRoZSBgSXRlcmFibGVgIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIHJldHVybnMgYE5vbmVgLlxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIC0gVGhlIGBJdGVyYWJsZWAgdG8gYmUgY29udmVydGVkIHRvIGFuIGBPcHRpb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbUl0ZXJhYmxlKFsxLCAyLCAzXSksIE9wdGlvbi5zb21lKDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbUl0ZXJhYmxlKFtdKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZnJvbUl0ZXJhYmxlID0gY29sbGVjdGlvbiA9PiB7XG4gIGZvciAoY29uc3QgYSBvZiBjb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHNvbWUoYSk7XG4gIH1cbiAgcmV0dXJuIG5vbmUoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEVpdGhlcmAgdG8gYW4gYE9wdGlvbmAgZGlzY2FyZGluZyB0aGUgZXJyb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24sIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldFJpZ2h0KEVpdGhlci5yaWdodCgnb2snKSksIE9wdGlvbi5zb21lKCdvaycpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZ2V0UmlnaHQoRWl0aGVyLmxlZnQoJ2VycicpKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRSaWdodCA9IGVpdGhlci5nZXRSaWdodDtcbi8qKlxuICogQ29udmVydHMgYSBgRWl0aGVyYCB0byBhbiBgT3B0aW9uYCBkaXNjYXJkaW5nIHRoZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiwgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZ2V0TGVmdChFaXRoZXIucmlnaHQoXCJva1wiKSksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5nZXRMZWZ0KEVpdGhlci5sZWZ0KFwiYVwiKSksIE9wdGlvbi5zb21lKFwiYVwiKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMZWZ0ID0gZWl0aGVyLmdldExlZnQ7XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYCBpZiBpdCBpcyBgU29tZWAsIG90aGVyd2lzZSByZXR1cm5zIGBvbk5vbmVgXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gZ2V0IHRoZSB2YWx1ZSBvZi5cbiAqIEBwYXJhbSBvbk5vbmUgLSBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBgT3B0aW9uYCBpcyBgTm9uZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5nZXRPckVsc2UoKCkgPT4gMCkpLCAxKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKE9wdGlvbi5ub25lKCksIE9wdGlvbi5nZXRPckVsc2UoKCkgPT4gMCkpLCAwKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JFbHNlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9uTm9uZSkgPT4gaXNOb25lKHNlbGYpID8gb25Ob25lKCkgOiBzZWxmLnZhbHVlKTtcbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgYE9wdGlvbmAgYHRoYXRgIGlmIGBzZWxmYCBpcyBgTm9uZWAsIG90aGVyd2lzZSByZXR1cm5zIGBzZWxmYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBmaXJzdCBgT3B0aW9uYCB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtIHRoYXQgLSBUaGUgYE9wdGlvbmAgdG8gcmV0dXJuIGlmIGBzZWxmYCBpcyBgTm9uZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5ub25lKCksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24ubm9uZSgpKVxuICogICApLFxuICogICBPcHRpb24ubm9uZSgpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKCdhJyksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24ubm9uZSgpKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYScpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5ub25lKCksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24uc29tZSgnYicpKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYicpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKCdhJyksXG4gKiAgICAgT3B0aW9uLm9yRWxzZSgoKSA9PiBPcHRpb24uc29tZSgnYicpKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYScpXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgb3JFbHNlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGlzTm9uZShzZWxmKSA/IHRoYXQoKSA6IHNlbGYpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0IHZhbHVlIGFzIGBTb21lYCBpZiBgc2VsZmAgaXMgYE5vbmVgLCBvdGhlcndpc2UgcmV0dXJucyBgc2VsZmAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgYE9wdGlvbmAgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSBvbk5vbmUgLSBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBgT3B0aW9uYCBpcyBgTm9uZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5ub25lKCksXG4gKiAgICAgT3B0aW9uLm9yRWxzZVNvbWUoKCkgPT4gJ2InKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYicpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKCdhJyksXG4gKiAgICAgT3B0aW9uLm9yRWxzZVNvbWUoKCkgPT4gJ2InKVxuICogICApLFxuICogICBPcHRpb24uc29tZSgnYScpXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgb3JFbHNlU29tZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvbk5vbmUpID0+IGlzTm9uZShzZWxmKSA/IHNvbWUob25Ob25lKCkpIDogc2VsZik7XG4vKipcbiAqIFNpbWlsYXIgdG8gYG9yRWxzZWAsIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhIHNpbXBsZSB1bmlvbiwgaXQgcmV0dXJucyBhbiBgRWl0aGVyYCBvYmplY3QsXG4gKiB3aGljaCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB3aGljaCBvZiB0aGUgdHdvIGBPcHRpb25gcyBoYXMgYmVlbiBjaG9zZW4uXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiBpdCdzIGltcG9ydGFudCB0byBrbm93IHdoZXRoZXIgdGhlIHZhbHVlIHdhcyByZXRyaWV2ZWQgZnJvbSB0aGUgZmlyc3QgYE9wdGlvbmAgb3IgdGhlIHNlY29uZCBvcHRpb24uXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgYE9wdGlvbmAgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB0aGF0IC0gVGhlIHNlY29uZCBgT3B0aW9uYCB0byBiZSBjb25zaWRlcmVkIGlmIHRoZSBmaXJzdCBgT3B0aW9uYCBpcyBgTm9uZWAuXG4gKlxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG9yRWxzZUVpdGhlciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBpc05vbmUoc2VsZikgPyBtYXAodGhhdCgpLCBlaXRoZXIucmlnaHQpIDogbWFwKHNlbGYsIGVpdGhlci5sZWZ0KSk7XG4vKipcbiAqIEdpdmVuIGFuIGBJdGVyYWJsZWAgY29sbGVjdGlvbiBvZiBgT3B0aW9uYHMsIHJldHVybnMgdGhlIGZpcnN0IGBTb21lYCBmb3VuZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gY29sbGVjdGlvbiAtIEFuIGl0ZXJhYmxlIGNvbGxlY3Rpb24gb2YgYE9wdGlvbmAgdG8gYmUgc2VhcmNoZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maXJzdFNvbWVPZihbT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5zb21lKDIpXSksIE9wdGlvbi5zb21lKDEpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpcnN0U29tZU9mID0gY29sbGVjdGlvbiA9PiB7XG4gIGxldCBvdXQgPSBub25lKCk7XG4gIGZvciAob3V0IG9mIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoaXNTb21lKG91dCkpIHtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBPcHRpb25gIGZyb20gYSBudWxsYWJsZSB0eXBlLiBJZiB0aGUgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCByZXR1cm5zIGBOb25lYCwgb3RoZXJ3aXNlXG4gKiByZXR1cm5zIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGEgYFNvbWVgLlxuICpcbiAqIEBwYXJhbSBudWxsYWJsZVZhbHVlIC0gVGhlIG51bGxhYmxlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBgT3B0aW9uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZyb21OdWxsYWJsZSh1bmRlZmluZWQpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbU51bGxhYmxlKG51bGwpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZnJvbU51bGxhYmxlKDEpLCBPcHRpb24uc29tZSgxKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tTnVsbGFibGUgPSBudWxsYWJsZVZhbHVlID0+IG51bGxhYmxlVmFsdWUgPT0gbnVsbCA/IG5vbmUoKSA6IHNvbWUobnVsbGFibGVWYWx1ZSk7XG4vKipcbiAqIFRoaXMgQVBJIGlzIHVzZWZ1bCBmb3IgbGlmdGluZyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaW50byB0aGUgYE9wdGlvbmAgY29udGV4dC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHBhcnNlID0gKHM6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gKiAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHMpXG4gKiAgIHJldHVybiBpc05hTihuKSA/IHVuZGVmaW5lZCA6IG5cbiAqIH1cbiAqXG4gKiBjb25zdCBwYXJzZU9wdGlvbiA9IE9wdGlvbi5saWZ0TnVsbGFibGUocGFyc2UpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwYXJzZU9wdGlvbignMScpLCBPcHRpb24uc29tZSgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGFyc2VPcHRpb24oJ25vdCBhIG51bWJlcicpLCBPcHRpb24ubm9uZSgpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxpZnROdWxsYWJsZSA9IGYgPT4gKC4uLmEpID0+IGZyb21OdWxsYWJsZShmKC4uLmEpKTtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGBPcHRpb25gIGlmIGl0IGlzIGEgYFNvbWVgLCBvdGhlcndpc2UgcmV0dXJucyBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gZXh0cmFjdCB0aGUgdmFsdWUgZnJvbS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yTnVsbChPcHRpb24uc29tZSgxKSksIDEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5nZXRPck51bGwoT3B0aW9uLm5vbmUoKSksIG51bGwpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPck51bGwgPSAvKiNfX1BVUkVfXyovZ2V0T3JFbHNlKGNvbnN0TnVsbCk7XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYCBpZiBpdCBpcyBhIGBTb21lYCwgb3RoZXJ3aXNlIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gZXh0cmFjdCB0aGUgdmFsdWUgZnJvbS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yVW5kZWZpbmVkKE9wdGlvbi5zb21lKDEpKSwgMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yVW5kZWZpbmVkKE9wdGlvbi5ub25lKCkpLCB1bmRlZmluZWQpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPclVuZGVmaW5lZCA9IC8qI19fUFVSRV9fKi9nZXRPckVsc2UoY29uc3RVbmRlZmluZWQpO1xuLyoqXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBsaWZ0cyBhIGZ1bmN0aW9uIHRoYXQgdGhyb3dzIGV4Y2VwdGlvbnMgaW50byBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBgT3B0aW9uYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBmb3IgYW55IGZ1bmN0aW9uIHRoYXQgbWlnaHQgdGhyb3cgYW4gZXhjZXB0aW9uLCBhbGxvd2luZyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZVxuICogdGhlIGV4Y2VwdGlvbiBpbiBhIG1vcmUgZnVuY3Rpb25hbCB3YXkuXG4gKlxuICogQHBhcmFtIGYgLSB0aGUgZnVuY3Rpb24gdGhhdCBjYW4gdGhyb3cgZXhjZXB0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHBhcnNlID0gT3B0aW9uLmxpZnRUaHJvd2FibGUoSlNPTi5wYXJzZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBhcnNlKFwiMVwiKSwgT3B0aW9uLnNvbWUoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBhcnNlKFwiXCIpLCBPcHRpb24ubm9uZSgpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxpZnRUaHJvd2FibGUgPSBmID0+ICguLi5hKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNvbWUoZiguLi5hKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbm9uZSgpO1xuICB9XG59O1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdmFsdWUgb2YgYW4gYE9wdGlvbmAgb3IgdGhyb3dzIGlmIHRoZSBgT3B0aW9uYCBpcyBgTm9uZWAuXG4gKlxuICogSWYgYSBkZWZhdWx0IGVycm9yIGlzIHN1ZmZpY2llbnQgZm9yIHlvdXIgdXNlIGNhc2UgYW5kIHlvdSBkb24ndCBuZWVkIHRvIGNvbmZpZ3VyZSB0aGUgdGhyb3duIGVycm9yLCBzZWUge0BsaW5rIGdldE9yVGhyb3d9LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb20uXG4gKiBAcGFyYW0gb25Ob25lIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBgT3B0aW9uYCBpcyBgTm9uZWAuIEl0IHJldHVybnMgdGhlIGVycm9yIHRvIGJlIHRocm93bi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIE9wdGlvbi5nZXRPclRocm93V2l0aChPcHRpb24uc29tZSgxKSwgKCkgPT4gbmV3IEVycm9yKCdVbmV4cGVjdGVkIE5vbmUnKSksXG4gKiAgIDFcbiAqIClcbiAqIGFzc2VydC50aHJvd3MoKCkgPT4gT3B0aW9uLmdldE9yVGhyb3dXaXRoKE9wdGlvbi5ub25lKCksICgpID0+IG5ldyBFcnJvcignVW5leHBlY3RlZCBOb25lJykpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yVGhyb3dXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG9uTm9uZSkgPT4ge1xuICBpZiAoaXNTb21lKHNlbGYpKSB7XG4gICAgcmV0dXJuIHNlbGYudmFsdWU7XG4gIH1cbiAgdGhyb3cgb25Ob25lKCk7XG59KTtcbi8qKlxuICogRXh0cmFjdHMgdGhlIHZhbHVlIG9mIGFuIGBPcHRpb25gIG9yIHRocm93cyBpZiB0aGUgYE9wdGlvbmAgaXMgYE5vbmVgLlxuICpcbiAqIFRoZSB0aHJvd24gZXJyb3IgaXMgYSBkZWZhdWx0IGVycm9yLiBUbyBjb25maWd1cmUgdGhlIGVycm9yIHRocm93biwgc2VlICB7QGxpbmsgZ2V0T3JUaHJvd1dpdGh9LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGV4dHJhY3QgdGhlIHZhbHVlIGZyb20uXG4gKiBAdGhyb3dzIGBFcnJvcihcImdldE9yVGhyb3cgY2FsbGVkIG9uIGEgTm9uZVwiKWBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmdldE9yVGhyb3coT3B0aW9uLnNvbWUoMSkpLCAxKVxuICogYXNzZXJ0LnRocm93cygoKSA9PiBPcHRpb24uZ2V0T3JUaHJvdyhPcHRpb24ubm9uZSgpKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPclRocm93ID0gLyojX19QVVJFX18qL2dldE9yVGhyb3dXaXRoKCgpID0+IG5ldyBFcnJvcihcImdldE9yVGhyb3cgY2FsbGVkIG9uIGEgTm9uZVwiKSk7XG4vKipcbiAqIE1hcHMgdGhlIGBTb21lYCBzaWRlIG9mIGFuIGBPcHRpb25gIHZhbHVlIHRvIGEgbmV3IGBPcHRpb25gIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQW4gYE9wdGlvbmAgdG8gbWFwXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB0byBtYXAgb3ZlciB0aGUgdmFsdWUgb2YgdGhlIGBPcHRpb25gXG4gKlxuICogQGNhdGVnb3J5IG1hcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzTm9uZShzZWxmKSA/IG5vbmUoKSA6IHNvbWUoZihzZWxmLnZhbHVlKSkpO1xuLyoqXG4gKiBNYXBzIHRoZSBgU29tZWAgdmFsdWUgb2YgdGhpcyBgT3B0aW9uYCB0byB0aGUgc3BlY2lmaWVkIGNvbnN0YW50IHZhbHVlLlxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFzID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGIpID0+IG1hcChzZWxmLCAoKSA9PiBiKSk7XG4vKipcbiAqIE1hcHMgdGhlIGBTb21lYCB2YWx1ZSBvZiB0aGlzIGBPcHRpb25gIHRvIHRoZSBgdm9pZGAgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGBPcHRpb25gIGlzIG5vdCBuZWVkZWQsIGJ1dCB0aGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiB0aGUgdmFsdWUgaXMgaW1wb3J0YW50LlxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFzVm9pZCA9IC8qI19fUFVSRV9fKi9hcyh1bmRlZmluZWQpO1xuY29uc3Qgdm9pZF8gPSAvKiNfX1BVUkVfXyovc29tZSh1bmRlZmluZWQpO1xuZXhwb3J0IHtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZvaWRfIGFzIHZvaWQgfTtcbi8qKlxuICogQXBwbGllcyBhIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZSBvZiBhbiBgT3B0aW9uYCBhbmQgZmxhdHRlbnMgdGhlIHJlc3VsdCwgaWYgdGhlIGlucHV0IGlzIGBTb21lYC5cbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0TWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzTm9uZShzZWxmKSA/IG5vbmUoKSA6IGYoc2VsZi52YWx1ZSkpO1xuLyoqXG4gKiBFeGVjdXRlcyBhIHNlcXVlbmNlIG9mIHR3byBgT3B0aW9uYHMuIFRoZSBzZWNvbmQgYE9wdGlvbmAgY2FuIGJlIGRlcGVuZGVudCBvbiB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBgT3B0aW9uYC5cbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhbmRUaGVuID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGZsYXRNYXAoc2VsZiwgYSA9PiB7XG4gIGNvbnN0IGIgPSBpc0Z1bmN0aW9uKGYpID8gZihhKSA6IGY7XG4gIHJldHVybiBpc09wdGlvbihiKSA/IGIgOiBzb21lKGIpO1xufSkpO1xuLyoqXG4gKiBUaGlzIGlzIGBmbGF0TWFwYCArIGBmcm9tTnVsbGFibGVgLCB1c2VmdWwgd2hlbiB3b3JraW5nIHdpdGggb3B0aW9uYWwgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcGlwZSwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogaW50ZXJmYWNlIEVtcGxveWVlIHtcbiAqICAgY29tcGFueT86IHtcbiAqICAgICBhZGRyZXNzPzoge1xuICogICAgICAgc3RyZWV0Pzoge1xuICogICAgICAgICBuYW1lPzogc3RyaW5nXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogY29uc3QgZW1wbG95ZWUxOiBFbXBsb3llZSA9IHsgY29tcGFueTogeyBhZGRyZXNzOiB7IHN0cmVldDogeyBuYW1lOiAnaGlnaCBzdHJlZXQnIH0gfSB9IH1cbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIE9wdGlvbi5zb21lKGVtcGxveWVlMSksXG4gKiAgICAgT3B0aW9uLmZsYXRNYXBOdWxsYWJsZShlbXBsb3llZSA9PiBlbXBsb3llZS5jb21wYW55Py5hZGRyZXNzPy5zdHJlZXQ/Lm5hbWUpLFxuICogICApLFxuICogICBPcHRpb24uc29tZSgnaGlnaCBzdHJlZXQnKVxuICogKVxuICpcbiAqIGNvbnN0IGVtcGxveWVlMjogRW1wbG95ZWUgPSB7IGNvbXBhbnk6IHsgYWRkcmVzczogeyBzdHJlZXQ6IHt9IH0gfSB9XG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICBPcHRpb24uc29tZShlbXBsb3llZTIpLFxuICogICAgIE9wdGlvbi5mbGF0TWFwTnVsbGFibGUoZW1wbG95ZWUgPT4gZW1wbG95ZWUuY29tcGFueT8uYWRkcmVzcz8uc3RyZWV0Py5uYW1lKSxcbiAqICAgKSxcbiAqICAgT3B0aW9uLm5vbmUoKVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IHNlcXVlbmNpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcE51bGxhYmxlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IGlzTm9uZShzZWxmKSA/IG5vbmUoKSA6IGZyb21OdWxsYWJsZShmKHNlbGYudmFsdWUpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW4gPSAvKiNfX1BVUkVfXyovZmxhdE1hcChpZGVudGl0eSk7XG4vKipcbiAqIEBjYXRlZ29yeSB6aXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHppcFJpZ2h0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGZsYXRNYXAoc2VsZiwgKCkgPT4gdGhhdCkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wb3NlSyA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChhZmIsIGJmYykgPT4gYSA9PiBmbGF0TWFwKGFmYihhKSwgYmZjKSk7XG4vKipcbiAqIFNlcXVlbmNlcyB0aGUgc3BlY2lmaWVkIGB0aGF0YCBgT3B0aW9uYCBidXQgaWdub3JlcyBpdHMgdmFsdWUuXG4gKlxuICogSXQgaXMgdXNlZnVsIHdoZW4gd2Ugd2FudCB0byBjaGFpbiBtdWx0aXBsZSBvcGVyYXRpb25zLCBidXQgb25seSBjYXJlIGFib3V0IHRoZSByZXN1bHQgb2YgYHNlbGZgLlxuICpcbiAqIEBwYXJhbSB0aGF0IC0gVGhlIGBPcHRpb25gIHRoYXQgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBjaGFpbiBhbmQgZGlzY2FyZGVkXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgT3B0aW9uYCB3ZSBjYXJlIGFib3V0XG4gKlxuICogQGNhdGVnb3J5IHppcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgemlwTGVmdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiB0YXAoc2VsZiwgKCkgPT4gdGhhdCkpO1xuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgdG8gdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYCBpZiBpdCBpcyBgU29tZWAgYW5kIHJldHVybnMgdGhlIG9yaWdpbmFsIGBPcHRpb25gXG4gKiB1bmxlc3MgYGZgIHJldHVybnMgYE5vbmVgLCBpbiB3aGljaCBjYXNlIGl0IHJldHVybnMgYE5vbmVgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBwZXJmb3JtaW5nIGFkZGl0aW9uYWwgY29tcHV0YXRpb25zIG9uIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgYE9wdGlvbmAgd2l0aG91dCBhZmZlY3RpbmcgaXRzIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBmIC0gRnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlIG9mIHRoZSBgT3B0aW9uYCBpZiBpdCBpcyBgU29tZWBcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBPcHRpb25gIHRvIGFwcGx5IHRoZSBmdW5jdGlvbiB0b1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgZ2V0SW50ZWdlciA9IChuOiBudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobikgPyBPcHRpb24uc29tZShuKSA6IE9wdGlvbi5ub25lKClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi50YXAoT3B0aW9uLm5vbmUoKSwgZ2V0SW50ZWdlciksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi50YXAoT3B0aW9uLnNvbWUoMSksIGdldEludGVnZXIpLCBPcHRpb24uc29tZSgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnRhcChPcHRpb24uc29tZSgxLjE0KSwgZ2V0SW50ZWdlciksIE9wdGlvbi5ub25lKCkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0YXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gZmxhdE1hcChzZWxmLCBhID0+IG1hcChmKGEpLCAoKSA9PiBhKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3QgPSAoc2VsZiwgdGhhdCkgPT4gaXNTb21lKHNlbGYpICYmIGlzU29tZSh0aGF0KSA/IHNvbWUoW3NlbGYudmFsdWUsIHRoYXQudmFsdWVdKSA6IG5vbmUoKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0TWFueSA9IChzZWxmLCBjb2xsZWN0aW9uKSA9PiB7XG4gIGlmIChpc05vbmUoc2VsZikpIHtcbiAgICByZXR1cm4gbm9uZSgpO1xuICB9XG4gIGNvbnN0IG91dCA9IFtzZWxmLnZhbHVlXTtcbiAgZm9yIChjb25zdCBvIG9mIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoaXNOb25lKG8pKSB7XG4gICAgICByZXR1cm4gbm9uZSgpO1xuICAgIH1cbiAgICBvdXQucHVzaChvLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gc29tZShvdXQpO1xufTtcbi8qKlxuICogVGFrZXMgYSBzdHJ1Y3R1cmUgb2YgYE9wdGlvbmBzIGFuZCByZXR1cm5zIGFuIGBPcHRpb25gIG9mIHZhbHVlcyB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZS5cbiAqXG4gKiAtIElmIGEgdHVwbGUgaXMgc3VwcGxpZWQsIHRoZW4gdGhlIHJldHVybmVkIGBPcHRpb25gIHdpbGwgY29udGFpbiBhIHR1cGxlIHdpdGggdGhlIHNhbWUgbGVuZ3RoLlxuICogLSBJZiBhIHN0cnVjdCBpcyBzdXBwbGllZCwgdGhlbiB0aGUgcmV0dXJuZWQgYE9wdGlvbmAgd2lsbCBjb250YWluIGEgc3RydWN0IHdpdGggdGhlIHNhbWUga2V5cy5cbiAqIC0gSWYgYW4gaXRlcmFibGUgaXMgc3VwcGxpZWQsIHRoZW4gdGhlIHJldHVybmVkIGBPcHRpb25gIHdpbGwgY29udGFpbiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gZmllbGRzIC0gdGhlIHN0cnVjdCBvZiBgT3B0aW9uYHMgdG8gYmUgc2VxdWVuY2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uYWxsKFtPcHRpb24uc29tZSgxKSwgT3B0aW9uLnNvbWUoMildKSwgT3B0aW9uLnNvbWUoWzEsIDJdKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmFsbCh7IGE6IE9wdGlvbi5zb21lKDEpLCBiOiBPcHRpb24uc29tZShcImhlbGxvXCIpIH0pLCBPcHRpb24uc29tZSh7IGE6IDEsIGI6IFwiaGVsbG9cIiB9KSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmFsbCh7IGE6IE9wdGlvbi5zb21lKDEpLCBiOiBPcHRpb24ubm9uZSgpIH0pLCBPcHRpb24ubm9uZSgpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmV4cG9ydCBjb25zdCBhbGwgPSBpbnB1dCA9PiB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG8gb2YgaW5wdXQpIHtcbiAgICAgIGlmIChpc05vbmUobykpIHtcbiAgICAgICAgcmV0dXJuIG5vbmUoKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKG8udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc29tZShvdXQpO1xuICB9XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICBjb25zdCBvID0gaW5wdXRba2V5XTtcbiAgICBpZiAoaXNOb25lKG8pKSB7XG4gICAgICByZXR1cm4gbm9uZSgpO1xuICAgIH1cbiAgICBvdXRba2V5XSA9IG8udmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNvbWUob3V0KTtcbn07XG4vKipcbiAqIFppcHMgdHdvIGBPcHRpb25gIHZhbHVlcyB0b2dldGhlciB1c2luZyBhIHByb3ZpZGVkIGZ1bmN0aW9uLCByZXR1cm5pbmcgYSBuZXcgYE9wdGlvbmAgb2YgdGhlIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgemlwIG9wZXJhdGlvblxuICogQHBhcmFtIHRoYXQgLSBUaGUgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSB6aXAgb3BlcmF0aW9uXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbWJpbmUgdGhlIHZhbHVlcyBvZiB0aGUgdHdvIGBPcHRpb25gc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogdHlwZSBDb21wbGV4ID0gW3JlYWw6IG51bWJlciwgaW1hZ2luYXJ5OiBudW1iZXJdXG4gKlxuICogY29uc3QgY29tcGxleCA9IChyZWFsOiBudW1iZXIsIGltYWdpbmFyeTogbnVtYmVyKTogQ29tcGxleCA9PiBbcmVhbCwgaW1hZ2luYXJ5XVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnppcFdpdGgoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLm5vbmUoKSwgY29tcGxleCksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi56aXBXaXRoKE9wdGlvbi5zb21lKDEpLCBPcHRpb24ubm9uZSgpLCBjb21wbGV4KSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnppcFdpdGgoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSksIGNvbXBsZXgpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uemlwV2l0aChPcHRpb24uc29tZSgxKSwgT3B0aW9uLnNvbWUoMiksIGNvbXBsZXgpLCBPcHRpb24uc29tZShbMSwgMl0pKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnppcFdpdGgoT3B0aW9uLnNvbWUoMSksIGNvbXBsZXgpKE9wdGlvbi5zb21lKDIpKSwgT3B0aW9uLnNvbWUoWzIsIDFdKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSB6aXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHppcFdpdGggPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGhhdCwgZikgPT4gbWFwKHByb2R1Y3Qoc2VsZiwgdGhhdCksIChbYSwgYl0pID0+IGYoYSwgYikpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiB6aXBXaXRoKHNlbGYsIHRoYXQsIChmLCBhKSA9PiBmKGEpKSk7XG4vKipcbiAqIFJlZHVjZXMgYW4gYEl0ZXJhYmxlYCBvZiBgT3B0aW9uPEE+YCB0byBhIHNpbmdsZSB2YWx1ZSBvZiB0eXBlIGBCYCwgZWxlbWVudHMgdGhhdCBhcmUgYE5vbmVgIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIEl0ZXJhYmxlIG9mIGBPcHRpb248QT5gIHRvIGJlIHJlZHVjZWQuXG4gKiBAcGFyYW0gYiAtIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAqIEBwYXJhbSBmIC0gVGhlIHJlZHVjaW5nIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGN1cnJlbnQgYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWUgb2YgYW4gYE9wdGlvbjxBPmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBpdGVyYWJsZSA9IFtPcHRpb24uc29tZSgxKSwgT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMiksIE9wdGlvbi5ub25lKCldXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoaXRlcmFibGUsIE9wdGlvbi5yZWR1Y2VDb21wYWN0KDAsIChiLCBhKSA9PiBiICsgYSkpLCAzKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZvbGRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmVkdWNlQ29tcGFjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBiLCBmKSA9PiB7XG4gIGxldCBvdXQgPSBiO1xuICBmb3IgKGNvbnN0IG9hIG9mIHNlbGYpIHtcbiAgICBpZiAoaXNTb21lKG9hKSkge1xuICAgICAgb3V0ID0gZihvdXQsIG9hLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGBPcHRpb25gIGludG8gYW4gYEFycmF5YC5cbiAqIElmIHRoZSBpbnB1dCBpcyBgTm9uZWAsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICogSWYgdGhlIGlucHV0IGlzIGBTb21lYCwgdGhlIHZhbHVlIGlzIHdyYXBwZWQgaW4gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gY29udmVydCB0byBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLnRvQXJyYXkoT3B0aW9uLnNvbWUoMSkpLCBbMV0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi50b0FycmF5KE9wdGlvbi5ub25lKCkpLCBbXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gc2VsZiA9PiBpc05vbmUoc2VsZikgPyBbXSA6IFtzZWxmLnZhbHVlXTtcbi8qKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJ0aXRpb25NYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4ge1xuICBpZiAoaXNOb25lKHNlbGYpKSB7XG4gICAgcmV0dXJuIFtub25lKCksIG5vbmUoKV07XG4gIH1cbiAgY29uc3QgZSA9IGYoc2VsZi52YWx1ZSk7XG4gIHJldHVybiBlaXRoZXIuaXNMZWZ0KGUpID8gW3NvbWUoZS5sZWZ0KSwgbm9uZSgpXSA6IFtub25lKCksIHNvbWUoZS5yaWdodCldO1xufSk7XG4vKipcbiAqIE1hcHMgb3ZlciB0aGUgdmFsdWUgb2YgYW4gYE9wdGlvbmAgYW5kIGZpbHRlcnMgb3V0IGBOb25lYHMuXG4gKlxuICogVXNlZnVsIHdoZW4gaW4gYWRkaXRpb24gdG8gZmlsdGVyaW5nIHlvdSBhbHNvIHdhbnQgdG8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBgT3B0aW9uYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgT3B0aW9uYCB0byBtYXAgb3Zlci5cbiAqIEBwYXJhbSBmIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWUgb2YgdGhlIGBPcHRpb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgZXZlbk51bWJlciA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwID8gT3B0aW9uLnNvbWUobikgOiBPcHRpb24ubm9uZSgpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZmlsdGVyTWFwKE9wdGlvbi5ub25lKCksIGV2ZW5OdW1iZXIpLCBPcHRpb24ubm9uZSgpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZmlsdGVyTWFwKE9wdGlvbi5zb21lKDMpLCBldmVuTnVtYmVyKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZpbHRlck1hcChPcHRpb24uc29tZSgyKSwgZXZlbk51bWJlciksIE9wdGlvbi5zb21lKDIpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmaWx0ZXJNYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gaXNOb25lKHNlbGYpID8gbm9uZSgpIDogZihzZWxmLnZhbHVlKSk7XG4vKipcbiAqIEZpbHRlcnMgYW4gYE9wdGlvbmAgdXNpbmcgYSBwcmVkaWNhdGUuIElmIHRoZSBwcmVkaWNhdGUgaXMgbm90IHNhdGlzZmllZCBvciB0aGUgYE9wdGlvbmAgaXMgYE5vbmVgIHJldHVybnMgYE5vbmVgLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgYE9wdGlvbmAgaW4gYWRkaXRpb24gdG8gZmlsdGVyaW5nLCBzZWUgYGZpbHRlck1hcGAuXG4gKlxuICogQHBhcmFtIHByZWRpY2F0ZSAtIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBgT3B0aW9uYCB2YWx1ZS5cbiAqIEBwYXJhbSBmYiAtIFRoZSBgT3B0aW9uYCB0byBmaWx0ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiAvLyBwcmVkaWNhdGVcbiAqIGNvbnN0IGlzRXZlbiA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPcHRpb24uZmlsdGVyKE9wdGlvbi5ub25lKCksIGlzRXZlbiksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maWx0ZXIoT3B0aW9uLnNvbWUoMyksIGlzRXZlbiksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maWx0ZXIoT3B0aW9uLnNvbWUoMiksIGlzRXZlbiksIE9wdGlvbi5zb21lKDIpKVxuICpcbiAqIC8vIHJlZmluZW1lbnRcbiAqIGNvbnN0IGlzTnVtYmVyID0gKHY6IHVua25vd24pOiB2IGlzIG51bWJlciA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZpbHRlcihPcHRpb24ubm9uZSgpLCBpc051bWJlciksIE9wdGlvbi5ub25lKCkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE9wdGlvbi5maWx0ZXIoT3B0aW9uLnNvbWUoJ2hlbGxvJyksIGlzTnVtYmVyKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoT3B0aW9uLmZpbHRlcihPcHRpb24uc29tZSgyKSwgaXNOdW1iZXIpLCBPcHRpb24uc29tZSgyKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHByZWRpY2F0ZSkgPT4gZmlsdGVyTWFwKHNlbGYsIGIgPT4gcHJlZGljYXRlKGIpID8gb3B0aW9uLnNvbWUoYikgOiBvcHRpb24ubm9uZSkpO1xuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgaXNFcXVpdmFsZW50ID0gT3B0aW9uLmdldEVxdWl2YWxlbmNlKE51bWJlci5FcXVpdmFsZW5jZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcXVpdmFsZW50KE9wdGlvbi5ub25lKCksIE9wdGlvbi5ub25lKCkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0VxdWl2YWxlbnQoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSkpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcXVpdmFsZW50KE9wdGlvbi5zb21lKDEpLCBPcHRpb24ubm9uZSgpKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRXF1aXZhbGVudChPcHRpb24uc29tZSgxKSwgT3B0aW9uLnNvbWUoMikpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFcXVpdmFsZW50KE9wdGlvbi5zb21lKDEpLCBPcHRpb24uc29tZSgxKSksIHRydWUpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZXF1aXZhbGVuY2VcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0RXF1aXZhbGVuY2UgPSBpc0VxdWl2YWxlbnQgPT4gRXF1aXZhbGVuY2UubWFrZSgoeCwgeSkgPT4gaXNOb25lKHgpID8gaXNOb25lKHkpIDogaXNOb25lKHkpID8gZmFsc2UgOiBpc0VxdWl2YWxlbnQoeC52YWx1ZSwgeS52YWx1ZSkpO1xuLyoqXG4gKiBUaGUgYE9yZGVyYCBpbnN0YW5jZSBhbGxvd3MgYE9wdGlvbmAgdmFsdWVzIHRvIGJlIGNvbXBhcmVkIHdpdGhcbiAqIGBjb21wYXJlYCwgd2hlbmV2ZXIgdGhlcmUgaXMgYW4gYE9yZGVyYCBpbnN0YW5jZSBmb3JcbiAqIHRoZSB0eXBlIHRoZSBgT3B0aW9uYCBjb250YWlucy5cbiAqXG4gKiBgTm9uZWAgaXMgY29uc2lkZXJlZCB0byBiZSBsZXNzIHRoYW4gYW55IGBTb21lYCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHBpcGUsIE9wdGlvbiwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgTyA9IE9wdGlvbi5nZXRPcmRlcihOdW1iZXIuT3JkZXIpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLm5vbmUoKSwgT3B0aW9uLm5vbmUoKSksIDApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLm5vbmUoKSwgT3B0aW9uLnNvbWUoMSkpLCAtMSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTyhPcHRpb24uc29tZSgxKSwgT3B0aW9uLm5vbmUoKSksIDEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5zb21lKDIpKSwgLTEpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8oT3B0aW9uLnNvbWUoMSksIE9wdGlvbi5zb21lKDEpKSwgMClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBzb3J0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yZGVyID0gTyA9PiBvcmRlci5tYWtlKChzZWxmLCB0aGF0KSA9PiBpc1NvbWUoc2VsZikgPyBpc1NvbWUodGhhdCkgPyBPKHNlbGYudmFsdWUsIHRoYXQudmFsdWUpIDogMSA6IC0xKTtcbi8qKlxuICogTGlmdHMgYSBiaW5hcnkgZnVuY3Rpb24gaW50byBgT3B0aW9uYC5cbiAqXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB0byBsaWZ0LlxuICpcbiAqIEBjYXRlZ29yeSBsaWZ0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxpZnQyID0gZiA9PiBkdWFsKDIsIChzZWxmLCB0aGF0KSA9PiB6aXBXaXRoKHNlbGYsIHRoYXQsIGYpKTtcbi8qKlxuICogVHJhbnNmb3JtcyBhIGBQcmVkaWNhdGVgIGZ1bmN0aW9uIGludG8gYSBgU29tZWAgb2YgdGhlIGlucHV0IHZhbHVlIGlmIHRoZSBwcmVkaWNhdGUgcmV0dXJucyBgdHJ1ZWAgb3IgYE5vbmVgXG4gKiBpZiB0aGUgcHJlZGljYXRlIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAcGFyYW0gcHJlZGljYXRlIC0gQSBgUHJlZGljYXRlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGluIGEgdmFsdWUgb2YgdHlwZSBgQWAgYW5kIHJldHVybnMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgZ2V0T3B0aW9uID0gT3B0aW9uLmxpZnRQcmVkaWNhdGUoKG46IG51bWJlcikgPT4gbiA+PSAwKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0T3B0aW9uKC0xKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0T3B0aW9uKDEpLCBPcHRpb24uc29tZSgxKSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBsaWZ0aW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGxpZnRQcmVkaWNhdGUgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoYiwgcHJlZGljYXRlKSA9PiBwcmVkaWNhdGUoYikgPyBzb21lKGIpIDogbm9uZSgpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgYE9wdGlvbmAgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSB1c2luZyBhIHByb3ZpZGVkIGBpc0VxdWl2YWxlbnRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBlcXVpdmFsZW50IC0gQW4gYEVxdWl2YWxlbmNlYCBpbnN0YW5jZSB0byBjb21wYXJlIHZhbHVlcyBvZiB0aGUgYE9wdGlvbmAuXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgT3B0aW9uYCB0byBhcHBseSB0aGUgY29tcGFyaXNvbiB0by5cbiAqIEBwYXJhbSBhIC0gVGhlIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgYE9wdGlvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBPcHRpb24sIE51bWJlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShPcHRpb24uc29tZSgyKSwgT3B0aW9uLmNvbnRhaW5zV2l0aChOdW1iZXIuRXF1aXZhbGVuY2UpKDIpKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShPcHRpb24uc29tZSgxKSwgT3B0aW9uLmNvbnRhaW5zV2l0aChOdW1iZXIuRXF1aXZhbGVuY2UpKDIpKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBpcGUoT3B0aW9uLm5vbmUoKSwgT3B0aW9uLmNvbnRhaW5zV2l0aChOdW1iZXIuRXF1aXZhbGVuY2UpKDIpKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29udGFpbnNXaXRoID0gaXNFcXVpdmFsZW50ID0+IGR1YWwoMiwgKHNlbGYsIGEpID0+IGlzTm9uZShzZWxmKSA/IGZhbHNlIDogaXNFcXVpdmFsZW50KHNlbGYudmFsdWUsIGEpKTtcbmNvbnN0IF9lcXVpdmFsZW5jZSA9IC8qI19fUFVSRV9fKi9FcXVhbC5lcXVpdmFsZW5jZSgpO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYW4gYE9wdGlvbmAgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSB1c2luZyB0aGUgZGVmYXVsdCBgRXF1aXZhbGVuY2VgLlxuICpcbiAqIEBjYXRlZ29yeSBlbGVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb250YWlucyA9IC8qI19fUFVSRV9fKi9jb250YWluc1dpdGgoX2VxdWl2YWxlbmNlKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpbiBhbiBgT3B0aW9uYCB0eXBlIG1lZXRzIGEgY2VydGFpbiBwcmVkaWNhdGUuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYE9wdGlvbmAgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJlZGljYXRlIC0gVGhlIGNvbmRpdGlvbiB0byBjaGVjay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHBpcGUsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGlzRXZlbiA9IChuOiBudW1iZXIpID0+IG4gJSAyID09PSAwXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKE9wdGlvbi5zb21lKDIpLCBPcHRpb24uZXhpc3RzKGlzRXZlbikpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwaXBlKE9wdGlvbi5zb21lKDEpLCBPcHRpb24uZXhpc3RzKGlzRXZlbikpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocGlwZShPcHRpb24ubm9uZSgpLCBPcHRpb24uZXhpc3RzKGlzRXZlbikpLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZXhpc3RzID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHJlZmluZW1lbnQpID0+IGlzTm9uZShzZWxmKSA/IGZhbHNlIDogcmVmaW5lbWVudChzZWxmLnZhbHVlKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkbyBub3RhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBUaGUgXCJkbyBzaW11bGF0aW9uXCIgaW4gRWZmZWN0IGFsbG93cyB5b3UgdG8gd3JpdGUgY29kZSBpbiBhIG1vcmUgZGVjbGFyYXRpdmUgc3R5bGUsIHNpbWlsYXIgdG8gdGhlIFwiZG8gbm90YXRpb25cIiBpbiBvdGhlciBwcm9ncmFtbWluZyBsYW5ndWFnZXMuIEl0IHByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVtIHVzaW5nIGZ1bmN0aW9ucyBsaWtlIGBiaW5kYCBhbmQgYGxldGAuXG4gKlxuICogSGVyZSdzIGhvdyB0aGUgZG8gc2ltdWxhdGlvbiB3b3JrczpcbiAqXG4gKiAxLiBTdGFydCB0aGUgZG8gc2ltdWxhdGlvbiB1c2luZyB0aGUgYERvYCB2YWx1ZVxuICogMi4gV2l0aGluIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIHVzZSB0aGUgYGJpbmRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBgT3B0aW9uYCB2YWx1ZXNcbiAqIDMuIFlvdSBjYW4gYWNjdW11bGF0ZSBtdWx0aXBsZSBgYmluZGAgc3RhdGVtZW50cyB0byBkZWZpbmUgbXVsdGlwbGUgdmFyaWFibGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAqIDQuIEluc2lkZSB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiBhbHNvIHVzZSB0aGUgYGxldGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIHNpbXBsZSB2YWx1ZXNcbiAqIDUuIFJlZ3VsYXIgYE9wdGlvbmAgZnVuY3Rpb25zIGxpa2UgYG1hcGAgYW5kIGBmaWx0ZXJgIGNhbiBzdGlsbCBiZSB1c2VkIHdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbi4gVGhlc2UgZnVuY3Rpb25zIHdpbGwgcmVjZWl2ZSB0aGUgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGFzIGFyZ3VtZW50cyB3aXRoaW4gdGhlIHNjb3BlXG4gKlxuICogQHNlZSB7QGxpbmsgRG99XG4gKiBAc2VlIHtAbGluayBiaW5kfVxuICogQHNlZSB7QGxpbmsgbGV0XyBsZXR9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24sIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaXBlKFxuICogICBPcHRpb24uRG8sXG4gKiAgIE9wdGlvbi5iaW5kKFwieFwiLCAoKSA9PiBPcHRpb24uc29tZSgyKSksXG4gKiAgIE9wdGlvbi5iaW5kKFwieVwiLCAoKSA9PiBPcHRpb24uc29tZSgzKSksXG4gKiAgIE9wdGlvbi5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSksXG4gKiAgIE9wdGlvbi5maWx0ZXIoKHsgeCwgeSB9KSA9PiB4ICogeSA+IDUpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgT3B0aW9uLnNvbWUoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYmluZFRvID0gLyojX19QVVJFX18qL2RvTm90YXRpb24uYmluZFRvKG1hcCk7XG5jb25zdCBsZXRfID0gLyojX19QVVJFX18qL2RvTm90YXRpb24ubGV0XyhtYXApO1xuZXhwb3J0IHtcbi8qKlxuICogVGhlIFwiZG8gc2ltdWxhdGlvblwiIGluIEVmZmVjdCBhbGxvd3MgeW91IHRvIHdyaXRlIGNvZGUgaW4gYSBtb3JlIGRlY2xhcmF0aXZlIHN0eWxlLCBzaW1pbGFyIHRvIHRoZSBcImRvIG5vdGF0aW9uXCIgaW4gb3RoZXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLiBJdCBwcm92aWRlcyBhIHdheSB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBwZXJmb3JtIG9wZXJhdGlvbnMgb24gdGhlbSB1c2luZyBmdW5jdGlvbnMgbGlrZSBgYmluZGAgYW5kIGBsZXRgLlxuICpcbiAqIEhlcmUncyBob3cgdGhlIGRvIHNpbXVsYXRpb24gd29ya3M6XG4gKlxuICogMS4gU3RhcnQgdGhlIGRvIHNpbXVsYXRpb24gdXNpbmcgdGhlIGBEb2AgdmFsdWVcbiAqIDIuIFdpdGhpbiB0aGUgZG8gc2ltdWxhdGlvbiBzY29wZSwgeW91IGNhbiB1c2UgdGhlIGBiaW5kYCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gYE9wdGlvbmAgdmFsdWVzXG4gKiAzLiBZb3UgY2FuIGFjY3VtdWxhdGUgbXVsdGlwbGUgYGJpbmRgIHN0YXRlbWVudHMgdG8gZGVmaW5lIG11bHRpcGxlIHZhcmlhYmxlcyB3aXRoaW4gdGhlIHNjb3BlXG4gKiA0LiBJbnNpZGUgdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBsZXRgIGZ1bmN0aW9uIHRvIGRlZmluZSB2YXJpYWJsZXMgYW5kIGJpbmQgdGhlbSB0byBzaW1wbGUgdmFsdWVzXG4gKiA1LiBSZWd1bGFyIGBPcHRpb25gIGZ1bmN0aW9ucyBsaWtlIGBtYXBgIGFuZCBgZmlsdGVyYCBjYW4gc3RpbGwgYmUgdXNlZCB3aXRoaW4gdGhlIGRvIHNpbXVsYXRpb24uIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIHJlY2VpdmUgdGhlIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhcyBhcmd1bWVudHMgd2l0aGluIHRoZSBzY29wZVxuICpcbiAqIEBzZWUge0BsaW5rIERvfVxuICogQHNlZSB7QGxpbmsgYmluZH1cbiAqIEBzZWUge0BsaW5rIGJpbmRUb31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9wdGlvbiwgcGlwZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpcGUoXG4gKiAgIE9wdGlvbi5EbyxcbiAqICAgT3B0aW9uLmJpbmQoXCJ4XCIsICgpID0+IE9wdGlvbi5zb21lKDIpKSxcbiAqICAgT3B0aW9uLmJpbmQoXCJ5XCIsICgpID0+IE9wdGlvbi5zb21lKDMpKSxcbiAqICAgT3B0aW9uLmxldChcInN1bVwiLCAoeyB4LCB5IH0pID0+IHggKyB5KSxcbiAqICAgT3B0aW9uLmZpbHRlcigoeyB4LCB5IH0pID0+IHggKiB5ID4gNSlcbiAqIClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmVzdWx0LCBPcHRpb24uc29tZSh7IHg6IDIsIHk6IDMsIHN1bTogNSB9KSlcbiAqXG4gKiBgYGBcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmxldF8gYXMgbGV0IH07XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBpbiBFZmZlY3QgYWxsb3dzIHlvdSB0byB3cml0ZSBjb2RlIGluIGEgbW9yZSBkZWNsYXJhdGl2ZSBzdHlsZSwgc2ltaWxhciB0byB0aGUgXCJkbyBub3RhdGlvblwiIGluIG90aGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcy4gSXQgcHJvdmlkZXMgYSB3YXkgdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgcGVyZm9ybSBvcGVyYXRpb25zIG9uIHRoZW0gdXNpbmcgZnVuY3Rpb25zIGxpa2UgYGJpbmRgIGFuZCBgbGV0YC5cbiAqXG4gKiBIZXJlJ3MgaG93IHRoZSBkbyBzaW11bGF0aW9uIHdvcmtzOlxuICpcbiAqIDEuIFN0YXJ0IHRoZSBkbyBzaW11bGF0aW9uIHVzaW5nIHRoZSBgRG9gIHZhbHVlXG4gKiAyLiBXaXRoaW4gdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gdXNlIHRoZSBgYmluZGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIGBPcHRpb25gIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICogNS4gUmVndWxhciBgT3B0aW9uYCBmdW5jdGlvbnMgbGlrZSBgbWFwYCBhbmQgYGZpbHRlcmAgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aGluIHRoZSBkbyBzaW11bGF0aW9uLiBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYXMgYXJndW1lbnRzIHdpdGhpbiB0aGUgc2NvcGVcbiAqXG4gKiBAc2VlIHtAbGluayBEb31cbiAqIEBzZWUge0BsaW5rIGJpbmRUb31cbiAqIEBzZWUge0BsaW5rIGxldF8gbGV0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT3B0aW9uLCBwaXBlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGlwZShcbiAqICAgT3B0aW9uLkRvLFxuICogICBPcHRpb24uYmluZChcInhcIiwgKCkgPT4gT3B0aW9uLnNvbWUoMikpLFxuICogICBPcHRpb24uYmluZChcInlcIiwgKCkgPT4gT3B0aW9uLnNvbWUoMykpLFxuICogICBPcHRpb24ubGV0KFwic3VtXCIsICh7IHgsIHkgfSkgPT4geCArIHkpLFxuICogICBPcHRpb24uZmlsdGVyKCh7IHgsIHkgfSkgPT4geCAqIHkgPiA1KVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZXN1bHQsIE9wdGlvbi5zb21lKHsgeDogMiwgeTogMywgc3VtOiA1IH0pKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmQgPSAvKiNfX1BVUkVfXyovZG9Ob3RhdGlvbi5iaW5kKG1hcCwgZmxhdE1hcCk7XG4vKipcbiAqIFRoZSBcImRvIHNpbXVsYXRpb25cIiBpbiBFZmZlY3QgYWxsb3dzIHlvdSB0byB3cml0ZSBjb2RlIGluIGEgbW9yZSBkZWNsYXJhdGl2ZSBzdHlsZSwgc2ltaWxhciB0byB0aGUgXCJkbyBub3RhdGlvblwiIGluIG90aGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcy4gSXQgcHJvdmlkZXMgYSB3YXkgdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgcGVyZm9ybSBvcGVyYXRpb25zIG9uIHRoZW0gdXNpbmcgZnVuY3Rpb25zIGxpa2UgYGJpbmRgIGFuZCBgbGV0YC5cbiAqXG4gKiBIZXJlJ3MgaG93IHRoZSBkbyBzaW11bGF0aW9uIHdvcmtzOlxuICpcbiAqIDEuIFN0YXJ0IHRoZSBkbyBzaW11bGF0aW9uIHVzaW5nIHRoZSBgRG9gIHZhbHVlXG4gKiAyLiBXaXRoaW4gdGhlIGRvIHNpbXVsYXRpb24gc2NvcGUsIHlvdSBjYW4gdXNlIHRoZSBgYmluZGAgZnVuY3Rpb24gdG8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgYmluZCB0aGVtIHRvIGBPcHRpb25gIHZhbHVlc1xuICogMy4gWW91IGNhbiBhY2N1bXVsYXRlIG11bHRpcGxlIGBiaW5kYCBzdGF0ZW1lbnRzIHRvIGRlZmluZSBtdWx0aXBsZSB2YXJpYWJsZXMgd2l0aGluIHRoZSBzY29wZVxuICogNC4gSW5zaWRlIHRoZSBkbyBzaW11bGF0aW9uIHNjb3BlLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgbGV0YCBmdW5jdGlvbiB0byBkZWZpbmUgdmFyaWFibGVzIGFuZCBiaW5kIHRoZW0gdG8gc2ltcGxlIHZhbHVlc1xuICogNS4gUmVndWxhciBgT3B0aW9uYCBmdW5jdGlvbnMgbGlrZSBgbWFwYCBhbmQgYGZpbHRlcmAgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aGluIHRoZSBkbyBzaW11bGF0aW9uLiBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYXMgYXJndW1lbnRzIHdpdGhpbiB0aGUgc2NvcGVcbiAqXG4gKiBAc2VlIHtAbGluayBiaW5kVG99XG4gKiBAc2VlIHtAbGluayBiaW5kfVxuICogQHNlZSB7QGxpbmsgbGV0XyBsZXR9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBPcHRpb24sIHBpcGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBwaXBlKFxuICogICBPcHRpb24uRG8sXG4gKiAgIE9wdGlvbi5iaW5kKFwieFwiLCAoKSA9PiBPcHRpb24uc29tZSgyKSksXG4gKiAgIE9wdGlvbi5iaW5kKFwieVwiLCAoKSA9PiBPcHRpb24uc29tZSgzKSksXG4gKiAgIE9wdGlvbi5sZXQoXCJzdW1cIiwgKHsgeCwgeSB9KSA9PiB4ICsgeSksXG4gKiAgIE9wdGlvbi5maWx0ZXIoKHsgeCwgeSB9KSA9PiB4ICogeSA+IDUpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgT3B0aW9uLnNvbWUoeyB4OiAyLCB5OiAzLCBzdW06IDUgfSkpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgRG8gPSAvKiNfX1BVUkVfXyovc29tZSh7fSk7XG5jb25zdCBhZGFwdGVyID0gLyojX19QVVJFX18qL0dlbi5hZGFwdGVyKCk7XG4vKipcbiAqIEBjYXRlZ29yeSBnZW5lcmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbiA9ICguLi5hcmdzKSA9PiB7XG4gIGxldCBmO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICBmID0gYXJnc1swXTtcbiAgfSBlbHNlIHtcbiAgICBmID0gYXJnc1sxXS5iaW5kKGFyZ3NbMF0pO1xuICB9XG4gIGNvbnN0IGl0ZXJhdG9yID0gZihhZGFwdGVyKTtcbiAgbGV0IHN0YXRlID0gaXRlcmF0b3IubmV4dCgpO1xuICBpZiAoc3RhdGUuZG9uZSkge1xuICAgIHJldHVybiBzb21lKHN0YXRlLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgY3VycmVudCA9IHN0YXRlLnZhbHVlO1xuICAgIGlmIChHZW4uaXNHZW5LaW5kKGN1cnJlbnQpKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCA9IEdlbi55aWVsZFdyYXBHZXQoY3VycmVudCk7XG4gICAgfVxuICAgIGlmIChpc05vbmUoY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICB3aGlsZSAoIXN0YXRlLmRvbmUpIHtcbiAgICAgIHN0YXRlID0gaXRlcmF0b3IubmV4dChjdXJyZW50LnZhbHVlKTtcbiAgICAgIGlmICghc3RhdGUuZG9uZSkge1xuICAgICAgICBjdXJyZW50ID0gc3RhdGUudmFsdWU7XG4gICAgICAgIGlmIChHZW4uaXNHZW5LaW5kKGN1cnJlbnQpKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IEdlbi55aWVsZFdyYXBHZXQoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm9uZShjdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb21lKHN0YXRlLnZhbHVlKTtcbiAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiRXF1YWwiLCJFcXVpdmFsZW5jZSIsImNvbnN0TnVsbCIsImNvbnN0VW5kZWZpbmVkIiwiZHVhbCIsImlkZW50aXR5IiwiaXNGdW5jdGlvbiIsImRvTm90YXRpb24iLCJlaXRoZXIiLCJvcHRpb24iLCJvcmRlciIsIkdlbiIsIlR5cGVJZCIsIlN5bWJvbCIsImZvciIsIm5vbmUiLCJzb21lIiwiaXNPcHRpb24iLCJpc05vbmUiLCJpc1NvbWUiLCJtYXRjaCIsInNlbGYiLCJvbk5vbmUiLCJvblNvbWUiLCJ2YWx1ZSIsInRvUmVmaW5lbWVudCIsImYiLCJhIiwiZnJvbUl0ZXJhYmxlIiwiY29sbGVjdGlvbiIsImdldFJpZ2h0IiwiZ2V0TGVmdCIsImdldE9yRWxzZSIsIm9yRWxzZSIsInRoYXQiLCJvckVsc2VTb21lIiwib3JFbHNlRWl0aGVyIiwibWFwIiwicmlnaHQiLCJsZWZ0IiwiZmlyc3RTb21lT2YiLCJvdXQiLCJmcm9tTnVsbGFibGUiLCJudWxsYWJsZVZhbHVlIiwibGlmdE51bGxhYmxlIiwiZ2V0T3JOdWxsIiwiZ2V0T3JVbmRlZmluZWQiLCJsaWZ0VGhyb3dhYmxlIiwiZSIsImdldE9yVGhyb3dXaXRoIiwiZ2V0T3JUaHJvdyIsIkVycm9yIiwiYXMiLCJiIiwiYXNWb2lkIiwidW5kZWZpbmVkIiwidm9pZF8iLCJ2b2lkIiwiZmxhdE1hcCIsImFuZFRoZW4iLCJmbGF0TWFwTnVsbGFibGUiLCJmbGF0dGVuIiwiemlwUmlnaHQiLCJjb21wb3NlSyIsImFmYiIsImJmYyIsInppcExlZnQiLCJ0YXAiLCJwcm9kdWN0IiwicHJvZHVjdE1hbnkiLCJvIiwicHVzaCIsImFsbCIsImlucHV0IiwiaXRlcmF0b3IiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwiemlwV2l0aCIsImFwIiwicmVkdWNlQ29tcGFjdCIsIm9hIiwidG9BcnJheSIsInBhcnRpdGlvbk1hcCIsImlzTGVmdCIsImZpbHRlck1hcCIsImZpbHRlciIsInByZWRpY2F0ZSIsImdldEVxdWl2YWxlbmNlIiwiaXNFcXVpdmFsZW50IiwibWFrZSIsIngiLCJ5IiwiZ2V0T3JkZXIiLCJPIiwibGlmdDIiLCJsaWZ0UHJlZGljYXRlIiwiY29udGFpbnNXaXRoIiwiX2VxdWl2YWxlbmNlIiwiZXF1aXZhbGVuY2UiLCJjb250YWlucyIsImV4aXN0cyIsInJlZmluZW1lbnQiLCJiaW5kVG8iLCJsZXRfIiwibGV0IiwiYmluZCIsIkRvIiwiYWRhcHRlciIsImdlbiIsImFyZ3MiLCJsZW5ndGgiLCJzdGF0ZSIsIm5leHQiLCJkb25lIiwiY3VycmVudCIsImlzR2VuS2luZCIsInlpZWxkV3JhcEdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Option.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Order.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Order.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Date: () => (/* binding */ Date),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   combineAll: () => (/* binding */ combineAll),\n/* harmony export */   combineMany: () => (/* binding */ combineMany),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   greaterThan: () => (/* binding */ greaterThan),\n/* harmony export */   greaterThanOrEqualTo: () => (/* binding */ greaterThanOrEqualTo),\n/* harmony export */   lessThan: () => (/* binding */ lessThan),\n/* harmony export */   lessThanOrEqualTo: () => (/* binding */ lessThanOrEqualTo),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   reverse: () => (/* binding */ reverse),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   tuple: () => (/* binding */ tuple)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/**\n * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.\n * An order is defined by a relation `<=`, which obeys the following laws:\n *\n * - either `x <= y` or `y <= x` (totality)\n * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)\n * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)\n *\n * The truth table for compare is defined as follows:\n *\n * | `x <= y` | `x >= y` | Ordering |                       |\n * | -------- | -------- | -------- | --------------------- |\n * | `true`   | `true`   | `0`      | corresponds to x == y |\n * | `true`   | `false`  | `< 0`    | corresponds to x < y  |\n * | `false`  | `true`   | `> 0`    | corresponds to x > y  |\n *\n * @since 2.0.0\n */ \n/**\n * @category constructors\n * @since 2.0.0\n */ const make = (compare)=>(self, that)=>self === that ? 0 : compare(self, that);\n/**\n * @category instances\n * @since 2.0.0\n */ const string = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */ const number = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */ const boolean = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */ const bigint = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);\n/**\n * @since 2.0.0\n */ const reverse = (O)=>make((self, that)=>O(that, self));\n/**\n * @category combining\n * @since 2.0.0\n */ const combine = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>make((a1, a2)=>{\n        const out = self(a1, a2);\n        if (out !== 0) {\n            return out;\n        }\n        return that(a1, a2);\n    }));\n/**\n * @category combining\n * @since 2.0.0\n */ const combineMany = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, collection)=>make((a1, a2)=>{\n        let out = self(a1, a2);\n        if (out !== 0) {\n            return out;\n        }\n        for (const O of collection){\n            out = O(a1, a2);\n            if (out !== 0) {\n                return out;\n            }\n        }\n        return out;\n    }));\n/**\n * @since 2.0.0\n */ const empty = ()=>make(()=>0);\n/**\n * @category combining\n * @since 2.0.0\n */ const combineAll = (collection)=>combineMany(empty(), collection);\n/**\n * @category mapping\n * @since 2.0.0\n */ const mapInput = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>make((b1, b2)=>self(f(b1), f(b2))));\n/**\n * @category instances\n * @since 2.0.0\n */ const Date = /*#__PURE__*/ mapInput(number, (date)=>date.getTime());\n/**\n * @category combining\n * @since 2.0.0\n */ const product = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>make(([xa, xb], [ya, yb])=>{\n        const o = self(xa, ya);\n        return o !== 0 ? o : that(xb, yb);\n    }));\n/**\n * @category combining\n * @since 2.0.0\n */ const all = (collection)=>{\n    return make((x, y)=>{\n        const len = Math.min(x.length, y.length);\n        let collectionLength = 0;\n        for (const O of collection){\n            if (collectionLength >= len) {\n                break;\n            }\n            const o = O(x[collectionLength], y[collectionLength]);\n            if (o !== 0) {\n                return o;\n            }\n            collectionLength++;\n        }\n        return 0;\n    });\n};\n/**\n * @category combining\n * @since 2.0.0\n */ const productMany = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, collection)=>{\n    const O = all(collection);\n    return make((x, y)=>{\n        const o = self(x[0], y[0]);\n        return o !== 0 ? o : O(x.slice(1), y.slice(1));\n    });\n});\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */ const tuple = (...elements)=>all(elements);\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 2.0.0\n */ const array = (O)=>make((self, that)=>{\n        const aLen = self.length;\n        const bLen = that.length;\n        const len = Math.min(aLen, bLen);\n        for(let i = 0; i < len; i++){\n            const o = O(self[i], that[i]);\n            if (o !== 0) {\n                return o;\n            }\n        }\n        return number(aLen, bLen);\n    });\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 2.0.0\n */ const struct = (fields)=>{\n    const keys = Object.keys(fields);\n    return make((self, that)=>{\n        for (const key of keys){\n            const o = fields[key](self[key], that[key]);\n            if (o !== 0) {\n                return o;\n            }\n        }\n        return 0;\n    });\n};\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 2.0.0\n */ const lessThan = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>O(self, that) === -1);\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 2.0.0\n */ const greaterThan = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>O(self, that) === 1);\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 2.0.0\n */ const lessThanOrEqualTo = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>O(self, that) !== 1);\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 2.0.0\n */ const greaterThanOrEqualTo = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>O(self, that) !== -1);\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */ const min = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>self === that || O(self, that) < 1 ? self : that);\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */ const max = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>self === that || O(self, that) > -1 ? self : that);\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @example\n * ```ts\n * import { Order, Number } from \"effect\"\n *\n * const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n * ```\n *\n * @since 2.0.0\n */ const clamp = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, options)=>min(O)(options.maximum, max(O)(options.minimum, self)));\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 2.0.0\n */ const between = (O)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, options)=>!lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum)); //# sourceMappingURL=Order.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL09yZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNvQztBQUNyQzs7O0NBR0MsR0FDTSxNQUFNQyxPQUFPQyxDQUFBQSxVQUFXLENBQUNDLE1BQU1DLE9BQVNELFNBQVNDLE9BQU8sSUFBSUYsUUFBUUMsTUFBTUMsTUFBTTtBQUN2Rjs7O0NBR0MsR0FDTSxNQUFNQyxTQUFTLFdBQVcsR0FBRUosS0FBSyxDQUFDRSxNQUFNQyxPQUFTRCxPQUFPQyxPQUFPLENBQUMsSUFBSSxHQUFHO0FBQzlFOzs7Q0FHQyxHQUNNLE1BQU1FLFNBQVMsV0FBVyxHQUFFTCxLQUFLLENBQUNFLE1BQU1DLE9BQVNELE9BQU9DLE9BQU8sQ0FBQyxJQUFJLEdBQUc7QUFDOUU7OztDQUdDLEdBQ00sTUFBTUcsVUFBVSxXQUFXLEdBQUVOLEtBQUssQ0FBQ0UsTUFBTUMsT0FBU0QsT0FBT0MsT0FBTyxDQUFDLElBQUksR0FBRztBQUMvRTs7O0NBR0MsR0FDTSxNQUFNSSxTQUFTLFdBQVcsR0FBRVAsS0FBSyxDQUFDRSxNQUFNQyxPQUFTRCxPQUFPQyxPQUFPLENBQUMsSUFBSSxHQUFHO0FBQzlFOztDQUVDLEdBQ00sTUFBTUssVUFBVUMsQ0FBQUEsSUFBS1QsS0FBSyxDQUFDRSxNQUFNQyxPQUFTTSxFQUFFTixNQUFNRCxPQUFPO0FBQ2hFOzs7Q0FHQyxHQUNNLE1BQU1RLFVBQVUsV0FBVyxHQUFFWCxrREFBSUEsQ0FBQyxHQUFHLENBQUNHLE1BQU1DLE9BQVNILEtBQUssQ0FBQ1csSUFBSUM7UUFDcEUsTUFBTUMsTUFBTVgsS0FBS1MsSUFBSUM7UUFDckIsSUFBSUMsUUFBUSxHQUFHO1lBQ2IsT0FBT0E7UUFDVDtRQUNBLE9BQU9WLEtBQUtRLElBQUlDO0lBQ2xCLElBQUk7QUFDSjs7O0NBR0MsR0FDTSxNQUFNRSxjQUFjLFdBQVcs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TS9DLENBQUFBLElBQUtWLGtEQUFJQSxDQUFDLEdBQUcsQ0FBQ0csTUFBTUMsT0FBU0QsU0FBU0MsUUFBUU0sRUFBRVAsTUFBTUMsUUFBUSxDQUFDLElBQUlELE9BQU9DLE1BQU07QUFDbkc7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTXNELFFBQVFoRCxDQUFBQSxJQUFLVixrREFBSUEsQ0FBQyxHQUFHLENBQUNHLE1BQU13RCxVQUFZdEIsSUFBSTNCLEdBQUdpRCxRQUFRQyxPQUFPLEVBQUVILElBQUkvQyxHQUFHaUQsUUFBUUUsT0FBTyxFQUFFMUQsUUFBUTtBQUM3Rzs7OztDQUlDLEdBQ00sTUFBTTJELFVBQVVwRCxDQUFBQSxJQUFLVixrREFBSUEsQ0FBQyxHQUFHLENBQUNHLE1BQU13RCxVQUFZLENBQUNOLFNBQVMzQyxHQUFHUCxNQUFNd0QsUUFBUUUsT0FBTyxLQUFLLENBQUNQLFlBQVk1QyxHQUFHUCxNQUFNd0QsUUFBUUMsT0FBTyxHQUFHLENBQ3RJLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vT3JkZXIuanM/YWNjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgT3JkZXJgIHR5cGUgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBkZWZpbmUgYSB0b3RhbCBvcmRlcmluZyBvbiBzb21lIHR5cGUgYEFgLlxuICogQW4gb3JkZXIgaXMgZGVmaW5lZCBieSBhIHJlbGF0aW9uIGA8PWAsIHdoaWNoIG9iZXlzIHRoZSBmb2xsb3dpbmcgbGF3czpcbiAqXG4gKiAtIGVpdGhlciBgeCA8PSB5YCBvciBgeSA8PSB4YCAodG90YWxpdHkpXG4gKiAtIGlmIGB4IDw9IHlgIGFuZCBgeSA8PSB4YCwgdGhlbiBgeCA9PSB5YCAoYW50aXN5bW1ldHJ5KVxuICogLSBpZiBgeCA8PSB5YCBhbmQgYHkgPD0gemAsIHRoZW4gYHggPD0gemAgKHRyYW5zaXRpdml0eSlcbiAqXG4gKiBUaGUgdHJ1dGggdGFibGUgZm9yIGNvbXBhcmUgaXMgZGVmaW5lZCBhcyBmb2xsb3dzOlxuICpcbiAqIHwgYHggPD0geWAgfCBgeCA+PSB5YCB8IE9yZGVyaW5nIHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYHRydWVgICAgfCBgdHJ1ZWAgICB8IGAwYCAgICAgIHwgY29ycmVzcG9uZHMgdG8geCA9PSB5IHxcbiAqIHwgYHRydWVgICAgfCBgZmFsc2VgICB8IGA8IDBgICAgIHwgY29ycmVzcG9uZHMgdG8geCA8IHkgIHxcbiAqIHwgYGZhbHNlYCAgfCBgdHJ1ZWAgICB8IGA+IDBgICAgIHwgY29ycmVzcG9uZHMgdG8geCA+IHkgIHxcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0IHsgZHVhbCB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG4vKipcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFrZSA9IGNvbXBhcmUgPT4gKHNlbGYsIHRoYXQpID0+IHNlbGYgPT09IHRoYXQgPyAwIDogY29tcGFyZShzZWxmLCB0aGF0KTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSAvKiNfX1BVUkVfXyovbWFrZSgoc2VsZiwgdGhhdCkgPT4gc2VsZiA8IHRoYXQgPyAtMSA6IDEpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IC8qI19fUFVSRV9fKi9tYWtlKChzZWxmLCB0aGF0KSA9PiBzZWxmIDwgdGhhdCA/IC0xIDogMSk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbiA9IC8qI19fUFVSRV9fKi9tYWtlKChzZWxmLCB0aGF0KSA9PiBzZWxmIDwgdGhhdCA/IC0xIDogMSk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYmlnaW50ID0gLyojX19QVVJFX18qL21ha2UoKHNlbGYsIHRoYXQpID0+IHNlbGYgPCB0aGF0ID8gLTEgOiAxKTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByZXZlcnNlID0gTyA9PiBtYWtlKChzZWxmLCB0aGF0KSA9PiBPKHRoYXQsIHNlbGYpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjb21iaW5lID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IG1ha2UoKGExLCBhMikgPT4ge1xuICBjb25zdCBvdXQgPSBzZWxmKGExLCBhMik7XG4gIGlmIChvdXQgIT09IDApIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHJldHVybiB0aGF0KGExLCBhMik7XG59KSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29tYmluZU1hbnkgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgY29sbGVjdGlvbikgPT4gbWFrZSgoYTEsIGEyKSA9PiB7XG4gIGxldCBvdXQgPSBzZWxmKGExLCBhMik7XG4gIGlmIChvdXQgIT09IDApIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZvciAoY29uc3QgTyBvZiBjb2xsZWN0aW9uKSB7XG4gICAgb3V0ID0gTyhhMSwgYTIpO1xuICAgIGlmIChvdXQgIT09IDApIHtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59KSk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZW1wdHkgPSAoKSA9PiBtYWtlKCgpID0+IDApO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVBbGwgPSBjb2xsZWN0aW9uID0+IGNvbWJpbmVNYW55KGVtcHR5KCksIGNvbGxlY3Rpb24pO1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBJbnB1dCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBtYWtlKChiMSwgYjIpID0+IHNlbGYoZihiMSksIGYoYjIpKSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IERhdGUgPSAvKiNfX1BVUkVfXyovbWFwSW5wdXQobnVtYmVyLCBkYXRlID0+IGRhdGUuZ2V0VGltZSgpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IG1ha2UoKFt4YSwgeGJdLCBbeWEsIHliXSkgPT4ge1xuICBjb25zdCBvID0gc2VsZih4YSwgeWEpO1xuICByZXR1cm4gbyAhPT0gMCA/IG8gOiB0aGF0KHhiLCB5Yik7XG59KSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWxsID0gY29sbGVjdGlvbiA9PiB7XG4gIHJldHVybiBtYWtlKCh4LCB5KSA9PiB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBsZXQgY29sbGVjdGlvbkxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBPIG9mIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uTGVuZ3RoID49IGxlbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG8gPSBPKHhbY29sbGVjdGlvbkxlbmd0aF0sIHlbY29sbGVjdGlvbkxlbmd0aF0pO1xuICAgICAgaWYgKG8gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBjb2xsZWN0aW9uTGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5pbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcHJvZHVjdE1hbnkgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgY29sbGVjdGlvbikgPT4ge1xuICBjb25zdCBPID0gYWxsKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gbWFrZSgoeCwgeSkgPT4ge1xuICAgIGNvbnN0IG8gPSBzZWxmKHhbMF0sIHlbMF0pO1xuICAgIHJldHVybiBvICE9PSAwID8gbyA6IE8oeC5zbGljZSgxKSwgeS5zbGljZSgxKSk7XG4gIH0pO1xufSk7XG4vKipcbiAqIFNpbWlsYXIgdG8gYFByb21pc2UuYWxsYCBidXQgb3BlcmF0ZXMgb24gYE9yZGVyYHMuXG4gKlxuICogYGBgXG4gKiBbT3JkZXI8QT4sIE9yZGVyPEI+LCAuLi5dIC0+IE9yZGVyPFtBLCBCLCAuLi5dPlxuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBPcmRlcmAgZm9yIGEgdHVwbGUgb2YgdmFsdWVzIGJhc2VkIG9uIHRoZSBnaXZlbiBgT3JkZXJgcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSB0dXBsZS5cbiAqIFRoZSByZXR1cm5lZCBgT3JkZXJgIGNvbXBhcmVzIHR3byB0dXBsZXMgb2YgdGhlIHNhbWUgdHlwZSBieSBhcHBseWluZyB0aGUgY29ycmVzcG9uZGluZyBgT3JkZXJgIHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgdHVwbGUuXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBjb21wYXJlIHR3byB0dXBsZXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgeW91IGhhdmUgYSBzcGVjaWZpYyB3YXkgb2YgY29tcGFyaW5nIGVhY2ggZWxlbWVudFxuICogb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0dXBsZSA9ICguLi5lbGVtZW50cykgPT4gYWxsKGVsZW1lbnRzKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBPcmRlcmAgZm9yIGFuIGFycmF5IG9mIHZhbHVlcyBiYXNlZCBvbiBhIGdpdmVuIGBPcmRlcmAgZm9yIHRoZSBlbGVtZW50cyBvZiB0aGUgYXJyYXkuXG4gKiBUaGUgcmV0dXJuZWQgYE9yZGVyYCBjb21wYXJlcyB0d28gYXJyYXlzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBgT3JkZXJgIHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlzLlxuICogSWYgYWxsIGVsZW1lbnRzIGFyZSBlcXVhbCwgdGhlIGFycmF5cyBhcmUgdGhlbiBjb21wYXJlZCBiYXNlZCBvbiB0aGVpciBsZW5ndGguXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBjb21wYXJlIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgeW91IGhhdmUgYSBzcGVjaWZpYyB3YXkgb2YgY29tcGFyaW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGFycmF5ID0gTyA9PiBtYWtlKChzZWxmLCB0aGF0KSA9PiB7XG4gIGNvbnN0IGFMZW4gPSBzZWxmLmxlbmd0aDtcbiAgY29uc3QgYkxlbiA9IHRoYXQubGVuZ3RoO1xuICBjb25zdCBsZW4gPSBNYXRoLm1pbihhTGVuLCBiTGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IG8gPSBPKHNlbGZbaV0sIHRoYXRbaV0pO1xuICAgIGlmIChvICE9PSAwKSB7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcihhTGVuLCBiTGVuKTtcbn0pO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYE9yZGVyYCBmb3IgYSBzdHJ1Y3Qgb2YgdmFsdWVzIGJhc2VkIG9uIHRoZSBnaXZlbiBgT3JkZXJgc1xuICogZm9yIGVhY2ggcHJvcGVydHkgaW4gdGhlIHN0cnVjdC5cbiAqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc3RydWN0ID0gZmllbGRzID0+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG4gIHJldHVybiBtYWtlKChzZWxmLCB0aGF0KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgbyA9IGZpZWxkc1trZXldKHNlbGZba2V5XSwgdGhhdFtrZXldKTtcbiAgICAgIGlmIChvICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG59O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgb25lIHZhbHVlIGlzIF9zdHJpY3RseSBsZXNzIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZXNzVGhhbiA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSA9PT0gLTEpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgb25lIHZhbHVlIGlzIF9zdHJpY3RseSBncmVhdGVyIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBncmVhdGVyVGhhbiA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSA9PT0gMSk7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBvbmUgdmFsdWUgaXMgX25vbi1zdHJpY3RseSBsZXNzIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBsZXNzVGhhbk9yRXF1YWxUbyA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSAhPT0gMSk7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBvbmUgdmFsdWUgaXMgX25vbi1zdHJpY3RseSBncmVhdGVyIHRoYW5fIGFub3RoZXIuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBncmVhdGVyVGhhbk9yRXF1YWxUbyA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gTyhzZWxmLCB0aGF0KSAhPT0gLTEpO1xuLyoqXG4gKiBUYWtlIHRoZSBtaW5pbXVtIG9mIHR3byB2YWx1ZXMuIElmIHRoZXkgYXJlIGNvbnNpZGVyZWQgZXF1YWwsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBjaG9zZW4uXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtaW4gPSBPID0+IGR1YWwoMiwgKHNlbGYsIHRoYXQpID0+IHNlbGYgPT09IHRoYXQgfHwgTyhzZWxmLCB0aGF0KSA8IDEgPyBzZWxmIDogdGhhdCk7XG4vKipcbiAqIFRha2UgdGhlIG1heGltdW0gb2YgdHdvIHZhbHVlcy4gSWYgdGhleSBhcmUgY29uc2lkZXJlZCBlcXVhbCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGNob3Nlbi5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1heCA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4gc2VsZiA9PT0gdGhhdCB8fCBPKHNlbGYsIHRoYXQpID4gLTEgPyBzZWxmIDogdGhhdCk7XG4vKipcbiAqIENsYW1wIGEgdmFsdWUgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE9yZGVyLCBOdW1iZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBjbGFtcCA9IE9yZGVyLmNsYW1wKE51bWJlci5PcmRlcikoeyBtaW5pbXVtOiAxLCBtYXhpbXVtOiA1IH0pXG4gKlxuICogYXNzZXJ0LmVxdWFsKGNsYW1wKDMpLCAzKVxuICogYXNzZXJ0LmVxdWFsKGNsYW1wKDApLCAxKVxuICogYXNzZXJ0LmVxdWFsKGNsYW1wKDYpLCA1KVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjbGFtcCA9IE8gPT4gZHVhbCgyLCAoc2VsZiwgb3B0aW9ucykgPT4gbWluKE8pKG9wdGlvbnMubWF4aW11bSwgbWF4KE8pKG9wdGlvbnMubWluaW11bSwgc2VsZikpKTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bSAoaW5jbHVzaXZlKS5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGJldHdlZW4gPSBPID0+IGR1YWwoMiwgKHNlbGYsIG9wdGlvbnMpID0+ICFsZXNzVGhhbihPKShzZWxmLCBvcHRpb25zLm1pbmltdW0pICYmICFncmVhdGVyVGhhbihPKShzZWxmLCBvcHRpb25zLm1heGltdW0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9yZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkdWFsIiwibWFrZSIsImNvbXBhcmUiLCJzZWxmIiwidGhhdCIsInN0cmluZyIsIm51bWJlciIsImJvb2xlYW4iLCJiaWdpbnQiLCJyZXZlcnNlIiwiTyIsImNvbWJpbmUiLCJhMSIsImEyIiwib3V0IiwiY29tYmluZU1hbnkiLCJjb2xsZWN0aW9uIiwiZW1wdHkiLCJjb21iaW5lQWxsIiwibWFwSW5wdXQiLCJmIiwiYjEiLCJiMiIsIkRhdGUiLCJkYXRlIiwiZ2V0VGltZSIsInByb2R1Y3QiLCJ4YSIsInhiIiwieWEiLCJ5YiIsIm8iLCJhbGwiLCJ4IiwieSIsImxlbiIsIk1hdGgiLCJtaW4iLCJsZW5ndGgiLCJjb2xsZWN0aW9uTGVuZ3RoIiwicHJvZHVjdE1hbnkiLCJzbGljZSIsInR1cGxlIiwiZWxlbWVudHMiLCJhcnJheSIsImFMZW4iLCJiTGVuIiwiaSIsInN0cnVjdCIsImZpZWxkcyIsImtleXMiLCJPYmplY3QiLCJrZXkiLCJsZXNzVGhhbiIsImdyZWF0ZXJUaGFuIiwibGVzc1RoYW5PckVxdWFsVG8iLCJncmVhdGVyVGhhbk9yRXF1YWxUbyIsIm1heCIsImNsYW1wIiwib3B0aW9ucyIsIm1heGltdW0iLCJtaW5pbXVtIiwiYmV0d2VlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Order.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Pipeable.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Pipeable.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pipeArguments: () => (/* binding */ pipeArguments)\n/* harmony export */ });\n/**\n * @since 2.0.0\n */ /**\n * @since 2.0.0\n */ const pipeArguments = (self, args)=>{\n    switch(args.length){\n        case 0:\n            return self;\n        case 1:\n            return args[0](self);\n        case 2:\n            return args[1](args[0](self));\n        case 3:\n            return args[2](args[1](args[0](self)));\n        case 4:\n            return args[3](args[2](args[1](args[0](self))));\n        case 5:\n            return args[4](args[3](args[2](args[1](args[0](self)))));\n        case 6:\n            return args[5](args[4](args[3](args[2](args[1](args[0](self))))));\n        case 7:\n            return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));\n        case 8:\n            return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));\n        case 9:\n            return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));\n        default:\n            {\n                let ret = self;\n                for(let i = 0, len = args.length; i < len; i++){\n                    ret = args[i](ret);\n                }\n                return ret;\n            }\n    }\n}; //# sourceMappingURL=Pipeable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1BpcGVhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNEOztDQUVDLEdBQ00sTUFBTUEsZ0JBQWdCLENBQUNDLE1BQU1DO0lBQ2xDLE9BQVFBLEtBQUtDLE1BQU07UUFDakIsS0FBSztZQUNILE9BQU9GO1FBQ1QsS0FBSztZQUNILE9BQU9DLElBQUksQ0FBQyxFQUFFLENBQUNEO1FBQ2pCLEtBQUs7WUFDSCxPQUFPQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDRDtRQUN6QixLQUFLO1lBQ0gsT0FBT0MsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0Q7UUFDakMsS0FBSztZQUNILE9BQU9DLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNEO1FBQ3pDLEtBQUs7WUFDSCxPQUFPQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDRDtRQUNqRCxLQUFLO1lBQ0gsT0FBT0MsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0Q7UUFDekQsS0FBSztZQUNILE9BQU9DLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQyxFQUFFLENBQUNEO1FBQ2pFLEtBQUs7WUFDSCxPQUFPQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDQSxJQUFJLENBQUMsRUFBRSxDQUFDRDtRQUN6RSxLQUFLO1lBQ0gsT0FBT0MsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0Q7UUFDakY7WUFDRTtnQkFDRSxJQUFJRyxNQUFNSDtnQkFDVixJQUFLLElBQUlJLElBQUksR0FBR0MsTUFBTUosS0FBS0MsTUFBTSxFQUFFRSxJQUFJQyxLQUFLRCxJQUFLO29CQUMvQ0QsTUFBTUYsSUFBSSxDQUFDRyxFQUFFLENBQUNEO2dCQUNoQjtnQkFDQSxPQUFPQTtZQUNUO0lBQ0o7QUFDRixFQUFFLENBQ0Ysb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9QaXBlYWJsZS5qcz8wOWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwaXBlQXJndW1lbnRzID0gKHNlbGYsIGFyZ3MpID0+IHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBhcmdzWzBdKHNlbGYpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBhcmdzWzFdKGFyZ3NbMF0oc2VsZikpO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBhcmdzWzJdKGFyZ3NbMV0oYXJnc1swXShzZWxmKSkpO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBhcmdzWzNdKGFyZ3NbMl0oYXJnc1sxXShhcmdzWzBdKHNlbGYpKSkpO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBhcmdzWzRdKGFyZ3NbM10oYXJnc1syXShhcmdzWzFdKGFyZ3NbMF0oc2VsZikpKSkpO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBhcmdzWzVdKGFyZ3NbNF0oYXJnc1szXShhcmdzWzJdKGFyZ3NbMV0oYXJnc1swXShzZWxmKSkpKSkpO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBhcmdzWzZdKGFyZ3NbNV0oYXJnc1s0XShhcmdzWzNdKGFyZ3NbMl0oYXJnc1sxXShhcmdzWzBdKHNlbGYpKSkpKSkpO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBhcmdzWzddKGFyZ3NbNl0oYXJnc1s1XShhcmdzWzRdKGFyZ3NbM10oYXJnc1syXShhcmdzWzFdKGFyZ3NbMF0oc2VsZikpKSkpKSkpO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBhcmdzWzhdKGFyZ3NbN10oYXJnc1s2XShhcmdzWzVdKGFyZ3NbNF0oYXJnc1szXShhcmdzWzJdKGFyZ3NbMV0oYXJnc1swXShzZWxmKSkpKSkpKSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGxldCByZXQgPSBzZWxmO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJldCA9IGFyZ3NbaV0ocmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGlwZWFibGUuanMubWFwIl0sIm5hbWVzIjpbInBpcGVBcmd1bWVudHMiLCJzZWxmIiwiYXJncyIsImxlbmd0aCIsInJldCIsImkiLCJsZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Pipeable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Predicate.js":
/*!***************************************************!*\
  !*** ./node_modules/effect/dist/esm/Predicate.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   eqv: () => (/* binding */ eqv),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   hasProperty: () => (/* binding */ hasProperty),\n/* harmony export */   implies: () => (/* binding */ implies),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isIterable: () => (/* binding */ isIterable),\n/* harmony export */   isMap: () => (/* binding */ isMap),\n/* harmony export */   isNever: () => (/* binding */ isNever),\n/* harmony export */   isNotNull: () => (/* binding */ isNotNull),\n/* harmony export */   isNotNullable: () => (/* binding */ isNotNullable),\n/* harmony export */   isNotUndefined: () => (/* binding */ isNotUndefined),\n/* harmony export */   isNull: () => (/* binding */ isNull),\n/* harmony export */   isNullable: () => (/* binding */ isNullable),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),\n/* harmony export */   isReadonlyRecord: () => (/* binding */ isReadonlyRecord),\n/* harmony export */   isRecord: () => (/* binding */ isRecord),\n/* harmony export */   isRecordOrArray: () => (/* binding */ isRecordOrArray),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isSet: () => (/* binding */ isSet),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isSymbol: () => (/* binding */ isSymbol),\n/* harmony export */   isTagged: () => (/* binding */ isTagged),\n/* harmony export */   isTruthy: () => (/* binding */ isTruthy),\n/* harmony export */   isTupleOf: () => (/* binding */ isTupleOf),\n/* harmony export */   isTupleOfAtLeast: () => (/* binding */ isTupleOfAtLeast),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   isUnknown: () => (/* binding */ isUnknown),\n/* harmony export */   mapInput: () => (/* binding */ mapInput),\n/* harmony export */   nand: () => (/* binding */ nand),\n/* harmony export */   nor: () => (/* binding */ nor),\n/* harmony export */   not: () => (/* binding */ not),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   product: () => (/* binding */ product),\n/* harmony export */   productMany: () => (/* binding */ productMany),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   xor: () => (/* binding */ xor)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/**\n * @since 2.0.0\n */ \n/**\n * Given a `Predicate<A>` returns a `Predicate<B>`\n *\n * @param self - the `Predicate<A>` to be transformed to `Predicate<B>`.\n * @param f - a function to transform `B` to `A`.\n *\n * @example\n * ```ts\n * import { Predicate, Number } from \"effect\"\n *\n * const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)\n *\n * assert.deepStrictEqual(minLength3(\"a\"), false)\n * assert.deepStrictEqual(minLength3(\"aa\"), false)\n * assert.deepStrictEqual(minLength3(\"aaa\"), true)\n * assert.deepStrictEqual(minLength3(\"aaaa\"), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */ const mapInput = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>(b)=>self(f(b)));\n/**\n * Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n *\n * An `Array` is considered to be a `TupleOf` if its length is exactly `N`.\n *\n * @param self - The `Array` to check.\n * @param n - The exact number of elements that the `Array` should have to be considered a `TupleOf`.\n *\n * @example\n * ```ts\n * import { isTupleOf } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3];\n * if (isTupleOf(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number]\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */ const isTupleOf = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>self.length === n);\n/**\n * Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n *\n * An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.\n *\n * @param self - The `Array` to check.\n * @param n - The minimum number of elements that the `Array` should have to be considered a `TupleOfAtLeast`.\n *\n * @example\n * ```ts\n * import { isTupleOfAtLeast } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3, 4];\n * if (isTupleOfAtLeast(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number, ...number[]]\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */ const isTupleOfAtLeast = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, n)=>self.length >= n);\n/**\n * Tests if a value is `truthy`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isTruthy } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTruthy(1), true)\n * assert.deepStrictEqual(isTruthy(0), false)\n * assert.deepStrictEqual(isTruthy(\"\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isTruthy = (input)=>!!input;\n/**\n * Tests if a value is a `Set`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isSet } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSet(new Set([1, 2])), true)\n * assert.deepStrictEqual(isSet(new Set()), true)\n * assert.deepStrictEqual(isSet({}), false)\n * assert.deepStrictEqual(isSet(null), false)\n * assert.deepStrictEqual(isSet(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isSet = (input)=>input instanceof Set;\n/**\n * Tests if a value is a `Map`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isMap } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isMap(new Map()), true)\n * assert.deepStrictEqual(isMap({}), false)\n * assert.deepStrictEqual(isMap(null), false)\n * assert.deepStrictEqual(isMap(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isMap = (input)=>input instanceof Map;\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isString } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n *\n * assert.deepStrictEqual(isString(1), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isString = (input)=>typeof input === \"string\";\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n *\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNumber = (input)=>typeof input === \"number\";\n/**\n * Tests if a value is a `boolean`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n *\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isBoolean = (input)=>typeof input === \"boolean\";\n/**\n * Tests if a value is a `bigint`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBigInt(1n), true)\n *\n * assert.deepStrictEqual(isBigInt(1), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isBigInt = (input)=>typeof input === \"bigint\";\n/**\n * Tests if a value is a `symbol`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.deepStrictEqual(isSymbol(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isSymbol = (input)=>typeof input === \"symbol\";\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n *\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isFunction = _Function_js__WEBPACK_IMPORTED_MODULE_0__.isFunction;\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUndefined(undefined), true)\n *\n * assert.deepStrictEqual(isUndefined(null), false)\n * assert.deepStrictEqual(isUndefined(\"undefined\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isUndefined = (input)=>input === undefined;\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotUndefined(null), true)\n * assert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n *\n * assert.deepStrictEqual(isNotUndefined(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNotUndefined = (input)=>input !== undefined;\n/**\n * Tests if a value is `null`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNull(null), true)\n *\n * assert.deepStrictEqual(isNull(undefined), false)\n * assert.deepStrictEqual(isNull(\"null\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNull = (input)=>input === null;\n/**\n * Tests if a value is not `null`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNull(undefined), true)\n * assert.deepStrictEqual(isNotNull(\"null\"), true)\n *\n * assert.deepStrictEqual(isNotNull(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNotNull = (input)=>input !== null;\n/**\n * A guard that always fails.\n *\n * @param _ - The value to test.\n *\n * @example\n * ```ts\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNever(null), false)\n * assert.deepStrictEqual(isNever(undefined), false)\n * assert.deepStrictEqual(isNever({}), false)\n * assert.deepStrictEqual(isNever([]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNever = (_)=>false;\n/**\n * A guard that always succeeds.\n *\n * @param _ - The value to test.\n *\n * @example\n * ```ts\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUnknown(null), true)\n * assert.deepStrictEqual(isUnknown(undefined), true)\n *\n * assert.deepStrictEqual(isUnknown({}), true)\n * assert.deepStrictEqual(isUnknown([]), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isUnknown = (_)=>true;\n/** @internal */ const isRecordOrArray = (input)=>typeof input === \"object\" && input !== null;\n/**\n * Tests if a value is an `object`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isObject({}), true)\n * assert.deepStrictEqual(isObject([]), true)\n *\n * assert.deepStrictEqual(isObject(null), false)\n * assert.deepStrictEqual(isObject(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isObject = (input)=>isRecordOrArray(input) || isFunction(input);\n/**\n * Checks whether a value is an `object` containing a specified property key.\n *\n * @param property - The field to check within the object.\n * @param self - The value to examine.\n *\n * @category guards\n * @since 2.0.0\n */ const hasProperty = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, property)=>isObject(self) && property in self);\n/**\n * Tests if a value is an `object` with a property `_tag` that matches the given tag.\n *\n * @param input - The value to test.\n * @param tag - The tag to test for.\n *\n * @example\n * ```ts\n * import { isTagged } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTagged(1, \"a\"), false)\n * assert.deepStrictEqual(isTagged(null, \"a\"), false)\n * assert.deepStrictEqual(isTagged({}, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\n * assert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isTagged = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, tag)=>hasProperty(self, \"_tag\") && self[\"_tag\"] === tag);\n/**\n * A guard that succeeds when the input is `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNullable(null), true)\n * assert.deepStrictEqual(isNullable(undefined), true)\n *\n * assert.deepStrictEqual(isNullable({}), false)\n * assert.deepStrictEqual(isNullable([]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNullable = (input)=>input === null || input === undefined;\n/**\n * A guard that succeeds when the input is not `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNullable({}), true)\n * assert.deepStrictEqual(isNotNullable([]), true)\n *\n * assert.deepStrictEqual(isNotNullable(null), false)\n * assert.deepStrictEqual(isNotNullable(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isNotNullable = (input)=>input !== null && input !== undefined;\n/**\n * A guard that succeeds when the input is an `Error`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isError } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isError(new Error()), true)\n *\n * assert.deepStrictEqual(isError(null), false)\n * assert.deepStrictEqual(isError({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isError = (input)=>input instanceof Error;\n/**\n * A guard that succeeds when the input is a `Uint8Array`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.deepStrictEqual(isUint8Array(null), false)\n * assert.deepStrictEqual(isUint8Array({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isUint8Array = (input)=>input instanceof Uint8Array;\n/**\n * A guard that succeeds when the input is a `Date`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isDate(new Date()), true)\n *\n * assert.deepStrictEqual(isDate(null), false)\n * assert.deepStrictEqual(isDate({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isDate = (input)=>input instanceof Date;\n/**\n * A guard that succeeds when the input is an `Iterable`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isIterable([]), true)\n * assert.deepStrictEqual(isIterable(new Set()), true)\n *\n * assert.deepStrictEqual(isIterable(null), false)\n * assert.deepStrictEqual(isIterable({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isIterable = (input)=>hasProperty(input, Symbol.iterator);\n/**\n * A guard that succeeds when the input is a record.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isRecord({}), true)\n * assert.deepStrictEqual(isRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isRecord([]), false)\n * assert.deepStrictEqual(isRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isRecord(null), false)\n * assert.deepStrictEqual(isRecord(undefined), false)\n * assert.deepStrictEqual(isRecord(() => null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isRecord = (input)=>isRecordOrArray(input) && !Array.isArray(input);\n/**\n * A guard that succeeds when the input is a readonly record.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isReadonlyRecord({}), true)\n * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isReadonlyRecord([]), false)\n * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isReadonlyRecord(null), false)\n * assert.deepStrictEqual(isReadonlyRecord(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isReadonlyRecord = isRecord;\n/**\n * A guard that succeeds when the input is a Promise.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { isPromise } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isPromise({}), false)\n * assert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isPromise = (input)=>hasProperty(input, \"then\") && \"catch\" in input && isFunction(input.then) && isFunction(input.catch);\n/**\n * @category guards\n * @since 2.0.0\n */ const isPromiseLike = (input)=>hasProperty(input, \"then\") && isFunction(input.then);\n/**\n * Tests if a value is a `RegExp`.\n *\n * @param input - The value to test.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n *\n * assert.deepStrictEqual(Predicate.isRegExp(/a/), true)\n * assert.deepStrictEqual(Predicate.isRegExp(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 3.9.0\n */ const isRegExp = (input)=>input instanceof RegExp;\n/**\n * @since 2.0.0\n */ const compose = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (ab, bc)=>(a)=>ab(a) && bc(a));\n/**\n * @category combining\n * @since 2.0.0\n */ const product = (self, that)=>([a, b])=>self(a) && that(b);\n/**\n * @category combining\n * @since 2.0.0\n */ const all = (collection)=>{\n    return (as)=>{\n        let collectionIndex = 0;\n        for (const p of collection){\n            if (collectionIndex >= as.length) {\n                break;\n            }\n            if (p(as[collectionIndex]) === false) {\n                return false;\n            }\n            collectionIndex++;\n        }\n        return true;\n    };\n};\n/**\n * @category combining\n * @since 2.0.0\n */ const productMany = (self, collection)=>{\n    const rest = all(collection);\n    return ([head, ...tail])=>self(head) === false ? false : rest(tail);\n};\n/**\n * Similar to `Promise.all` but operates on `Predicate`s.\n *\n * ```\n * [Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>\n * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n * [Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>\n * ```\n *\n * @since 2.0.0\n */ const tuple = (...elements)=>all(elements);\n/**\n * ```\n * { ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>\n * { a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>\n * { ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: ; ... }>\n * ```\n *\n * @since 2.0.0\n */ const struct = (fields)=>{\n    const keys = Object.keys(fields);\n    return (a)=>{\n        for (const key of keys){\n            if (!fields[key](a[key])) {\n                return false;\n            }\n        }\n        return true;\n    };\n};\n/**\n * Negates the result of a given predicate.\n *\n * @param self - A predicate.\n *\n * @example\n * ```ts\n * import { Predicate, Number } from \"effect\"\n *\n * const isPositive = Predicate.not(Number.lessThan(0))\n *\n * assert.deepStrictEqual(isPositive(-1), false)\n * assert.deepStrictEqual(isPositive(0), true)\n * assert.deepStrictEqual(isPositive(1), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */ const not = (self)=>(a)=>!self(a);\n/**\n * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * ```ts\n * import { Predicate, Number } from \"effect\"\n *\n * const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))\n *\n * assert.deepStrictEqual(nonZero(-1), true)\n * assert.deepStrictEqual(nonZero(0), false)\n * assert.deepStrictEqual(nonZero(1), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */ const or = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>(a)=>self(a) || that(a));\n/**\n * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n *\n * const minLength = (n: number) => (s: string) => s.length >= n\n * const maxLength = (n: number) => (s: string) => s.length <= n\n *\n * const length = (n: number) => Predicate.and(minLength(n), maxLength(n))\n *\n * assert.deepStrictEqual(length(2)(\"aa\"), true)\n * assert.deepStrictEqual(length(2)(\"a\"), false)\n * assert.deepStrictEqual(length(2)(\"aaa\"), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */ const and = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>(a)=>self(a) && that(a));\n/**\n * @category combinators\n * @since 2.0.0\n */ const xor = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>(a)=>self(a) !== that(a));\n/**\n * @category combinators\n * @since 2.0.0\n */ const eqv = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>(a)=>self(a) === that(a));\n/**\n * Represents the logical implication combinator for predicates. In formal\n * logic, the implication operator `->` denotes that if the first proposition\n * (antecedent) is true, then the second proposition (consequent) must also be\n * true. In simpler terms, `p implies q` can be interpreted as \"if p then q\". If\n * the first predicate holds, then the second predicate must hold\n * for the given context.\n *\n * In practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.\n *\n * Note that if the antecedent is `false`, the result is `true` by default\n * because the outcome of the consequent cannot be determined.\n *\n * This function is useful in situations where you need to enforce rules or\n * constraints that are contingent on certain conditions.\n * It proves especially helpful in defining property tests.\n *\n * The example below illustrates the transitive property of order using the\n * `implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`\n * must be true.\n *\n * @example\n * ```ts\n * import { Predicate } from \"effect\"\n *\n * type Triple = {\n *   readonly a: number\n *   readonly b: number\n *   readonly c: number\n * }\n *\n * const transitivity = Predicate.implies(\n *   // antecedent\n *   (input: Triple) => input.a <= input.b && input.b <= input.c,\n *   // consequent\n *   (input: Triple) => input.a <= input.c\n * )\n *\n * assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)\n * // antecedent is `false`, so the result is `true`\n * assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */ const implies = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (antecedent, consequent)=>(a)=>antecedent(a) ? consequent(a) : true);\n/**\n * @category combinators\n * @since 2.0.0\n */ const nor = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>(a)=>!(self(a) || that(a)));\n/**\n * @category combinators\n * @since 2.0.0\n */ const nand = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>(a)=>!(self(a) && that(a)));\n/**\n * @category elements\n * @since 2.0.0\n */ const every = (collection)=>(a)=>{\n        for (const p of collection){\n            if (!p(a)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * @category elements\n * @since 2.0.0\n */ const some = (collection)=>(a)=>{\n        for (const p of collection){\n            if (p(a)) {\n                return true;\n            }\n        }\n        return false;\n    }; //# sourceMappingURL=Predicate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1ByZWRpY2F0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQytEO0FBQ2hFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLE1BQU1HLFdBQVcsV0FBVyxHQUFFSCxrREFBSUEsQ0FBQyxHQUFHLENBQUNJLE1BQU1DLElBQU1DLENBQUFBLElBQUtGLEtBQUtDLEVBQUVDLEtBQUs7QUFDM0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxNQUFNQyxZQUFZLFdBQVcsR0FBRVAsa0RBQUlBLENBQUMsR0FBRyxDQUFDSSxNQUFNSSxJQUFNSixLQUFLSyxNQUFNLEtBQUtELEdBQUc7QUFDOUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxNQUFNRSxtQkFBbUIsV0FBVyxHQUFFVixrREFBSUEsQ0FBQyxHQUFHLENBQUNJLE1BQU1JLElBQU1KLEtBQUtLLE1BQU0sSUFBSUQsR0FBRztBQUNwRjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1HLFdBQVdDLENBQUFBLFFBQVMsQ0FBQyxDQUFDQSxNQUFNO0FBQ3pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxNQUFNQyxRQUFRRCxDQUFBQSxRQUFTQSxpQkFBaUJFLElBQUk7QUFDbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sTUFBTUMsUUFBUUgsQ0FBQUEsUUFBU0EsaUJBQWlCSSxJQUFJO0FBQ25EOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ00sTUFBTUMsV0FBV0wsQ0FBQUEsUUFBUyxPQUFPQSxVQUFVLFNBQVM7QUFDM0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNTSxXQUFXTixDQUFBQSxRQUFTLE9BQU9BLFVBQVUsU0FBUztBQUMzRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1PLFlBQVlQLENBQUFBLFFBQVMsT0FBT0EsVUFBVSxVQUFVO0FBQzdEOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ00sTUFBTVEsV0FBV1IsQ0FBQUEsUUFBUyxPQUFPQSxVQUFVLFNBQVM7QUFDM0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNUyxXQUFXVCxDQUFBQSxRQUFTLE9BQU9BLFVBQVUsU0FBUztBQUMzRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1YLGFBQWFDLG9EQUFXQSxDQUFDO0FBQ3RDOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1vQixjQUFjVixDQUFBQSxRQUFTQSxVQUFVVyxVQUFVO0FBQ3hEOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1DLGlCQUFpQlosQ0FBQUEsUUFBU0EsVUFBVVcsVUFBVTtBQUMzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxNQUFNRSxTQUFTYixDQUFBQSxRQUFTQSxVQUFVLEtBQUs7QUFDOUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sTUFBTWMsWUFBWWQsQ0FBQUEsUUFBU0EsVUFBVSxLQUFLO0FBQ2pEOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1lLFVBQVVDLENBQUFBLElBQUssTUFBTTtBQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sTUFBTUMsWUFBWUQsQ0FBQUEsSUFBSyxLQUFLO0FBQ25DLGNBQWMsR0FDUCxNQUFNRSxrQkFBa0JsQixDQUFBQSxRQUFTLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxLQUFLO0FBQ3BGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxNQUFNbUIsV0FBV25CLENBQUFBLFFBQVNrQixnQkFBZ0JsQixVQUFVWCxXQUFXVyxPQUFPO0FBQzdFOzs7Ozs7OztDQVFDLEdBQ00sTUFBTW9CLGNBQWMsV0FBVyxHQUFFaEMsa0RBQUlBLENBQUMsR0FBRyxDQUFDSSxNQUFNNkIsV0FBYUYsU0FBUzNCLFNBQVM2QixZQUFZN0IsTUFBTTtBQUN4Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FDTSxNQUFNOEIsV0FBVyxXQUFXLEdBQUVsQyxrREFBSUEsQ0FBQyxHQUFHLENBQUNJLE1BQU0rQixNQUFRSCxZQUFZNUIsTUFBTSxXQUFXQSxJQUFJLENBQUMsT0FBTyxLQUFLK0IsS0FBSztBQUMvRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sTUFBTUMsYUFBYXhCLENBQUFBLFFBQVNBLFVBQVUsUUFBUUEsVUFBVVcsVUFBVTtBQUN6RTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sTUFBTWMsZ0JBQWdCekIsQ0FBQUEsUUFBU0EsVUFBVSxRQUFRQSxVQUFVVyxVQUFVO0FBQzVFOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1lLFVBQVUxQixDQUFBQSxRQUFTQSxpQkFBaUIyQixNQUFNO0FBQ3ZEOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1DLGVBQWU1QixDQUFBQSxRQUFTQSxpQkFBaUI2QixXQUFXO0FBQ2pFOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLE1BQU1DLFNBQVM5QixDQUFBQSxRQUFTQSxpQkFBaUIrQixLQUFLO0FBQ3JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxNQUFNQyxhQUFhaEMsQ0FBQUEsUUFBU29CLFlBQVlwQixPQUFPaUMsT0FBT0MsUUFBUSxFQUFFO0FBQ3ZFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDTSxNQUFNQyxXQUFXbkMsQ0FBQUEsUUFBU2tCLGdCQUFnQmxCLFVBQVUsQ0FBQ29DLE1BQU1DLE9BQU8sQ0FBQ3JDLE9BQU87QUFDakY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sTUFBTXNDLG1CQUFtQkgsU0FBUztBQUN6Qzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNSSxZQUFZdkMsQ0FBQUEsUUFBU29CLFlBQVlwQixPQUFPLFdBQVcsV0FBV0EsU0FBU1gsV0FBV1csTUFBTXdDLElBQUksS0FBS25ELFdBQVdXLE1BQU15QyxLQUFLLEVBQUU7QUFDdEk7OztDQUdDLEdBQ00sTUFBTUMsZ0JBQWdCMUMsQ0FBQUEsUUFBU29CLFlBQVlwQixPQUFPLFdBQVdYLFdBQVdXLE1BQU13QyxJQUFJLEVBQUU7QUFDM0Y7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTUcsV0FBVzNDLENBQUFBLFFBQVNBLGlCQUFpQjRDLE9BQU87QUFDekQ7O0NBRUMsR0FDTSxNQUFNQyxVQUFVLFdBQVcsR0FBRXpELGtEQUFJQSxDQUFDLEdBQUcsQ0FBQzBELElBQUlDLEtBQU9DLENBQUFBLElBQUtGLEdBQUdFLE1BQU1ELEdBQUdDLElBQUk7QUFDN0U7OztDQUdDLEdBQ00sTUFBTUMsVUFBVSxDQUFDekQsTUFBTTBELE9BQVMsQ0FBQyxDQUFDRixHQUFHdEQsRUFBRSxHQUFLRixLQUFLd0QsTUFBTUUsS0FBS3hELEdBQUc7QUFDdEU7OztDQUdDLEdBQ00sTUFBTXlELE1BQU1DLENBQUFBO0lBQ2pCLE9BQU9DLENBQUFBO1FBQ0wsSUFBSUMsa0JBQWtCO1FBQ3RCLEtBQUssTUFBTUMsS0FBS0gsV0FBWTtZQUMxQixJQUFJRSxtQkFBbUJELEdBQUd4RCxNQUFNLEVBQUU7Z0JBQ2hDO1lBQ0Y7WUFDQSxJQUFJMEQsRUFBRUYsRUFBRSxDQUFDQyxnQkFBZ0IsTUFBTSxPQUFPO2dCQUNwQyxPQUFPO1lBQ1Q7WUFDQUE7UUFDRjtRQUNBLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFDRjs7O0NBR0MsR0FDTSxNQUFNRSxjQUFjLENBQUNoRSxNQUFNNEQ7SUFDaEMsTUFBTUssT0FBT04sSUFBSUM7SUFDakIsT0FBTyxDQUFDLENBQUNNLE1BQU0sR0FBR0MsS0FBSyxHQUFLbkUsS0FBS2tFLFVBQVUsUUFBUSxRQUFRRCxLQUFLRTtBQUNsRSxFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1DLFFBQVEsQ0FBQyxHQUFHQyxXQUFhVixJQUFJVSxVQUFVO0FBQ3BEOzs7Ozs7OztDQVFDLEdBQ00sTUFBTUMsU0FBU0MsQ0FBQUE7SUFDcEIsTUFBTUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRDtJQUN6QixPQUFPZixDQUFBQTtRQUNMLEtBQUssTUFBTWtCLE9BQU9GLEtBQU07WUFDdEIsSUFBSSxDQUFDRCxNQUFNLENBQUNHLElBQUksQ0FBQ2xCLENBQUMsQ0FBQ2tCLElBQUksR0FBRztnQkFDeEIsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7QUFDRixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLE1BQU1DLE1BQU0zRSxDQUFBQSxPQUFRd0QsQ0FBQUEsSUFBSyxDQUFDeEQsS0FBS3dELEdBQUc7QUFDekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxNQUFNb0IsS0FBSyxXQUFXLEdBQUVoRixrREFBSUEsQ0FBQyxHQUFHLENBQUNJLE1BQU0wRCxPQUFTRixDQUFBQSxJQUFLeEQsS0FBS3dELE1BQU1FLEtBQUtGLElBQUk7QUFDaEY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxNQUFNcUIsTUFBTSxXQUFXLEdBQUVqRixrREFBSUEsQ0FBQyxHQUFHLENBQUNJLE1BQU0wRCxPQUFTRixDQUFBQSxJQUFLeEQsS0FBS3dELE1BQU1FLEtBQUtGLElBQUk7QUFDakY7OztDQUdDLEdBQ00sTUFBTXNCLE1BQU0sV0FBVyxHQUFFbEYsa0RBQUlBLENBQUMsR0FBRyxDQUFDSSxNQUFNMEQsT0FBU0YsQ0FBQUEsSUFBS3hELEtBQUt3RCxPQUFPRSxLQUFLRixJQUFJO0FBQ2xGOzs7Q0FHQyxHQUNNLE1BQU11QixNQUFNLFdBQVcsR0FBRW5GLGtEQUFJQSxDQUFDLEdBQUcsQ0FBQ0ksTUFBTTBELE9BQVNGLENBQUFBLElBQUt4RCxLQUFLd0QsT0FBT0UsS0FBS0YsSUFBSTtBQUNsRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBQ00sTUFBTXdCLFVBQVUsV0FBVyxHQUFFcEYsa0RBQUlBLENBQUMsR0FBRyxDQUFDcUYsWUFBWUMsYUFBZTFCLENBQUFBLElBQUt5QixXQUFXekIsS0FBSzBCLFdBQVcxQixLQUFLLE1BQU07QUFDbkg7OztDQUdDLEdBQ00sTUFBTTJCLE1BQU0sV0FBVyxHQUFFdkYsa0RBQUlBLENBQUMsR0FBRyxDQUFDSSxNQUFNMEQsT0FBU0YsQ0FBQUEsSUFBSyxDQUFFeEQsQ0FBQUEsS0FBS3dELE1BQU1FLEtBQUtGLEVBQUMsR0FBSTtBQUNwRjs7O0NBR0MsR0FDTSxNQUFNNEIsT0FBTyxXQUFXLEdBQUV4RixrREFBSUEsQ0FBQyxHQUFHLENBQUNJLE1BQU0wRCxPQUFTRixDQUFBQSxJQUFLLENBQUV4RCxDQUFBQSxLQUFLd0QsTUFBTUUsS0FBS0YsRUFBQyxHQUFJO0FBQ3JGOzs7Q0FHQyxHQUNNLE1BQU02QixRQUFRekIsQ0FBQUEsYUFBY0osQ0FBQUE7UUFDakMsS0FBSyxNQUFNTyxLQUFLSCxXQUFZO1lBQzFCLElBQUksQ0FBQ0csRUFBRVAsSUFBSTtnQkFDVCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVCxFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sTUFBTThCLE9BQU8xQixDQUFBQSxhQUFjSixDQUFBQTtRQUNoQyxLQUFLLE1BQU1PLEtBQUtILFdBQVk7WUFDMUIsSUFBSUcsRUFBRVAsSUFBSTtnQkFDUixPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVCxFQUFFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9QcmVkaWNhdGUuanM/OTJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5pbXBvcnQgeyBkdWFsLCBpc0Z1bmN0aW9uIGFzIGlzRnVuY3Rpb25fIH0gZnJvbSBcIi4vRnVuY3Rpb24uanNcIjtcbi8qKlxuICogR2l2ZW4gYSBgUHJlZGljYXRlPEE+YCByZXR1cm5zIGEgYFByZWRpY2F0ZTxCPmBcbiAqXG4gKiBAcGFyYW0gc2VsZiAtIHRoZSBgUHJlZGljYXRlPEE+YCB0byBiZSB0cmFuc2Zvcm1lZCB0byBgUHJlZGljYXRlPEI+YC5cbiAqIEBwYXJhbSBmIC0gYSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYEJgIHRvIGBBYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFByZWRpY2F0ZSwgTnVtYmVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbWluTGVuZ3RoMyA9IFByZWRpY2F0ZS5tYXBJbnB1dChOdW1iZXIuZ3JlYXRlclRoYW4oMiksIChzOiBzdHJpbmcpID0+IHMubGVuZ3RoKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobWluTGVuZ3RoMyhcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW5MZW5ndGgzKFwiYWFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW5MZW5ndGgzKFwiYWFhXCIpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtaW5MZW5ndGgzKFwiYWFhYVwiKSwgdHJ1ZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBJbnB1dCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBiID0+IHNlbGYoZihiKSkpO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYEFycmF5YCBpcyBhIHR1cGxlIHdpdGggZXhhY3RseSBgTmAgZWxlbWVudHMsIG5hcnJvd2luZyBkb3duIHRoZSB0eXBlIHRvIGBUdXBsZU9mYC5cbiAqXG4gKiBBbiBgQXJyYXlgIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBgVHVwbGVPZmAgaWYgaXRzIGxlbmd0aCBpcyBleGFjdGx5IGBOYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBgQXJyYXlgIHRvIGNoZWNrLlxuICogQHBhcmFtIG4gLSBUaGUgZXhhY3QgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgdGhlIGBBcnJheWAgc2hvdWxkIGhhdmUgdG8gYmUgY29uc2lkZXJlZCBhIGBUdXBsZU9mYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzVHVwbGVPZiB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVHVwbGVPZihbMSwgMiwgM10sIDMpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mKFsxLCAyLCAzXSwgMiksIGZhbHNlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mKFsxLCAyLCAzXSwgNCksIGZhbHNlKTtcbiAqXG4gKiBjb25zdCBhcnI6IG51bWJlcltdID0gWzEsIDIsIDNdO1xuICogaWYgKGlzVHVwbGVPZihhcnIsIDMpKSB7XG4gKiAgIGNvbnNvbGUubG9nKGFycik7XG4gKiAgIC8vIF4/IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDMuMy4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1R1cGxlT2YgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgbikgPT4gc2VsZi5sZW5ndGggPT09IG4pO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYEFycmF5YCBpcyBhIHR1cGxlIHdpdGggYXQgbGVhc3QgYE5gIGVsZW1lbnRzLCBuYXJyb3dpbmcgZG93biB0aGUgdHlwZSB0byBgVHVwbGVPZkF0TGVhc3RgLlxuICpcbiAqIEFuIGBBcnJheWAgaXMgY29uc2lkZXJlZCB0byBiZSBhIGBUdXBsZU9mQXRMZWFzdGAgaWYgaXRzIGxlbmd0aCBpcyBhdCBsZWFzdCBgTmAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEFycmF5YCB0byBjaGVjay5cbiAqIEBwYXJhbSBuIC0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgdGhlIGBBcnJheWAgc2hvdWxkIGhhdmUgdG8gYmUgY29uc2lkZXJlZCBhIGBUdXBsZU9mQXRMZWFzdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc1R1cGxlT2ZBdExlYXN0IH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDMpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDIpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDQpLCBmYWxzZSk7XG4gKlxuICogY29uc3QgYXJyOiBudW1iZXJbXSA9IFsxLCAyLCAzLCA0XTtcbiAqIGlmIChpc1R1cGxlT2ZBdExlYXN0KGFyciwgMykpIHtcbiAqICAgY29uc29sZS5sb2coYXJyKTtcbiAqICAgLy8gXj8gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIC4uLm51bWJlcltdXVxuICogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDMuMy4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1R1cGxlT2ZBdExlYXN0ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIG4pID0+IHNlbGYubGVuZ3RoID49IG4pO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGB0cnV0aHlgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNUcnV0aHkgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RydXRoeSgxKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUcnV0aHkoMCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RydXRoeShcIlwiKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVHJ1dGh5ID0gaW5wdXQgPT4gISFpbnB1dDtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBTZXRgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNTZXQgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldChuZXcgU2V0KFsxLCAyXSkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldChuZXcgU2V0KCkpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldCh7fSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1NldChudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzU2V0KHVuZGVmaW5lZCksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1NldCA9IGlucHV0ID0+IGlucHV0IGluc3RhbmNlb2YgU2V0O1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYE1hcGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc01hcCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTWFwKG5ldyBNYXAoKSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTWFwKHt9KSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTWFwKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNNYXAodW5kZWZpbmVkKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTWFwID0gaW5wdXQgPT4gaW5wdXQgaW5zdGFuY2VvZiBNYXA7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNTdHJpbmcoXCJhXCIpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNTdHJpbmcoMSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIjtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBudW1iZXJgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc051bWJlcigyKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVtYmVyKFwiMlwiKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTnVtYmVyID0gaW5wdXQgPT4gdHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgYGJvb2xlYW5gLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNCb29sZWFuIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCb29sZWFuKHRydWUpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCb29sZWFuKFwidHJ1ZVwiKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbiA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJib29sZWFuXCI7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgYmlnaW50YC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzQmlnSW50IH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCaWdJbnQoMW4pLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNCaWdJbnQoMSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc0JpZ0ludCA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJiaWdpbnRcIjtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBzeW1ib2xgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNTeW1ib2wgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1N5bWJvbChTeW1ib2wuZm9yKFwiYVwiKSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1N5bWJvbChcImFcIiksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IGlucHV0ID0+IHR5cGVvZiBpbnB1dCA9PT0gXCJzeW1ib2xcIjtcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIGBmdW5jdGlvbmAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNGdW5jdGlvbihpc0Z1bmN0aW9uKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRnVuY3Rpb24oXCJmdW5jdGlvblwiKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uXztcbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNVbmRlZmluZWQodW5kZWZpbmVkKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVW5kZWZpbmVkKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNVbmRlZmluZWQoXCJ1bmRlZmluZWRcIiksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1VuZGVmaW5lZCA9IGlucHV0ID0+IGlucHV0ID09PSB1bmRlZmluZWQ7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNOb3RVbmRlZmluZWQgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdFVuZGVmaW5lZChudWxsKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3RVbmRlZmluZWQoXCJ1bmRlZmluZWRcIiksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdFVuZGVmaW5lZCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNOb3RVbmRlZmluZWQgPSBpbnB1dCA9PiBpbnB1dCAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzTnVsbCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbChudWxsKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOdWxsKFwibnVsbFwiKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTnVsbCA9IGlucHV0ID0+IGlucHV0ID09PSBudWxsO1xuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIG5vdCBgbnVsbGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc05vdE51bGwgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc05vdE51bGwodW5kZWZpbmVkKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3ROdWxsKFwibnVsbFwiKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTm90TnVsbChudWxsKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm90TnVsbCA9IGlucHV0ID0+IGlucHV0ICE9PSBudWxsO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgYWx3YXlzIGZhaWxzLlxuICpcbiAqIEBwYXJhbSBfIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc05ldmVyIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOZXZlcihudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTmV2ZXIodW5kZWZpbmVkKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTmV2ZXIoe30pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOZXZlcihbXSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc05ldmVyID0gXyA9PiBmYWxzZTtcbi8qKlxuICogQSBndWFyZCB0aGF0IGFsd2F5cyBzdWNjZWVkcy5cbiAqXG4gKiBAcGFyYW0gXyAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNVbmtub3duIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNVbmtub3duKG51bGwpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1Vua25vd24odW5kZWZpbmVkKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVW5rbm93bih7fSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVW5rbm93bihbXSksIHRydWUpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVW5rbm93biA9IF8gPT4gdHJ1ZTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc1JlY29yZE9yQXJyYXkgPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgaW5wdXQgIT09IG51bGw7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gYG9iamVjdGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzT2JqZWN0KHt9KSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNPYmplY3QoW10pLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNPYmplY3QobnVsbCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc09iamVjdCh1bmRlZmluZWQpLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSBpbnB1dCA9PiBpc1JlY29yZE9yQXJyYXkoaW5wdXQpIHx8IGlzRnVuY3Rpb24oaW5wdXQpO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIGFuIGBvYmplY3RgIGNvbnRhaW5pbmcgYSBzcGVjaWZpZWQgcHJvcGVydHkga2V5LlxuICpcbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBmaWVsZCB0byBjaGVjayB3aXRoaW4gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBzZWxmIC0gVGhlIHZhbHVlIHRvIGV4YW1pbmUuXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcm9wZXJ0eSkgPT4gaXNPYmplY3Qoc2VsZikgJiYgcHJvcGVydHkgaW4gc2VsZik7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYW4gYG9iamVjdGAgd2l0aCBhIHByb3BlcnR5IGBfdGFnYCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIHRhZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBwYXJhbSB0YWcgLSBUaGUgdGFnIHRvIHRlc3QgZm9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNUYWdnZWQgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RhZ2dlZCgxLCBcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RhZ2dlZChudWxsLCBcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RhZ2dlZCh7fSwgXCJhXCIpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUYWdnZWQoeyBhOiBcImFcIiB9LCBcImFcIiksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1RhZ2dlZCh7IF90YWc6IFwiYVwiIH0sIFwiYVwiKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUYWdnZWQoXCJhXCIpKHsgX3RhZzogXCJhXCIgfSksIHRydWUpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGFnZ2VkID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRhZykgPT4gaGFzUHJvcGVydHkoc2VsZiwgXCJfdGFnXCIpICYmIHNlbGZbXCJfdGFnXCJdID09PSB0YWcpO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNOdWxsYWJsZSB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbGFibGUobnVsbCksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbGFibGUodW5kZWZpbmVkKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTnVsbGFibGUoe30pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOdWxsYWJsZShbXSksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc051bGxhYmxlID0gaW5wdXQgPT4gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZDtcbi8qKlxuICogQSBndWFyZCB0aGF0IHN1Y2NlZWRzIHdoZW4gdGhlIGlucHV0IGlzIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc05vdE51bGxhYmxlIH0gZnJvbSBcImVmZmVjdC9QcmVkaWNhdGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3ROdWxsYWJsZSh7fSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTm90TnVsbGFibGUoW10pLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNOb3ROdWxsYWJsZShudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzTm90TnVsbGFibGUodW5kZWZpbmVkKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm90TnVsbGFibGUgPSBpbnB1dCA9PiBpbnB1dCAhPT0gbnVsbCAmJiBpbnB1dCAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYW4gYEVycm9yYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0Vycm9yKG5ldyBFcnJvcigpKSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRXJyb3IobnVsbCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0Vycm9yKHt9KSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXJyb3IgPSBpbnB1dCA9PiBpbnB1dCBpbnN0YW5jZW9mIEVycm9yO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc1VpbnQ4QXJyYXkgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1VpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoKSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1VpbnQ4QXJyYXkobnVsbCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1VpbnQ4QXJyYXkoe30pLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNVaW50OEFycmF5ID0gaW5wdXQgPT4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYSBgRGF0ZWAuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc0RhdGUgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0RhdGUobmV3IERhdGUoKSksIHRydWUpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0RhdGUobnVsbCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0RhdGUoe30pLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNEYXRlID0gaW5wdXQgPT4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYW4gYEl0ZXJhYmxlYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzSXRlcmFibGUgfSBmcm9tIFwiZWZmZWN0L1ByZWRpY2F0ZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0l0ZXJhYmxlKFtdKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNJdGVyYWJsZShuZXcgU2V0KCkpLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNJdGVyYWJsZShudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzSXRlcmFibGUoe30pLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNJdGVyYWJsZSA9IGlucHV0ID0+IGhhc1Byb3BlcnR5KGlucHV0LCBTeW1ib2wuaXRlcmF0b3IpO1xuLyoqXG4gKiBBIGd1YXJkIHRoYXQgc3VjY2VlZHMgd2hlbiB0aGUgaW5wdXQgaXMgYSByZWNvcmQuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc1JlY29yZCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVjb3JkKHt9KSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQoeyBhOiAxIH0pLCB0cnVlKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQoW10pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQoWzEsIDIsIDNdKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVjb3JkKG51bGwpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWNvcmQodW5kZWZpbmVkKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVjb3JkKCgpID0+IG51bGwpLCBmYWxzZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNSZWNvcmQgPSBpbnB1dCA9PiBpc1JlY29yZE9yQXJyYXkoaW5wdXQpICYmICFBcnJheS5pc0FycmF5KGlucHV0KTtcbi8qKlxuICogQSBndWFyZCB0aGF0IHN1Y2NlZWRzIHdoZW4gdGhlIGlucHV0IGlzIGEgcmVhZG9ubHkgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNSZWFkb25seVJlY29yZCB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVhZG9ubHlSZWNvcmQoe30pLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1JlYWRvbmx5UmVjb3JkKHsgYTogMSB9KSwgdHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVhZG9ubHlSZWNvcmQoW10pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWFkb25seVJlY29yZChbMSwgMiwgM10pLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNSZWFkb25seVJlY29yZChudWxsKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUmVhZG9ubHlSZWNvcmQodW5kZWZpbmVkKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUmVhZG9ubHlSZWNvcmQgPSBpc1JlY29yZDtcbi8qKlxuICogQSBndWFyZCB0aGF0IHN1Y2NlZWRzIHdoZW4gdGhlIGlucHV0IGlzIGEgUHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzUHJvbWlzZSB9IGZyb20gXCJlZmZlY3QvUHJlZGljYXRlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUHJvbWlzZSh7fSksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc1Byb21pc2UoUHJvbWlzZS5yZXNvbHZlKFwiaGVsbG9cIikpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBpbnB1dCA9PiBoYXNQcm9wZXJ0eShpbnB1dCwgXCJ0aGVuXCIpICYmIFwiY2F0Y2hcIiBpbiBpbnB1dCAmJiBpc0Z1bmN0aW9uKGlucHV0LnRoZW4pICYmIGlzRnVuY3Rpb24oaW5wdXQuY2F0Y2gpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZUxpa2UgPSBpbnB1dCA9PiBoYXNQcm9wZXJ0eShpbnB1dCwgXCJ0aGVuXCIpICYmIGlzRnVuY3Rpb24oaW5wdXQudGhlbik7XG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUHJlZGljYXRlLmlzUmVnRXhwKC9hLyksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFByZWRpY2F0ZS5pc1JlZ0V4cChcImFcIiksIGZhbHNlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDMuOS4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1JlZ0V4cCA9IGlucHV0ID0+IGlucHV0IGluc3RhbmNlb2YgUmVnRXhwO1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBvc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoYWIsIGJjKSA9PiBhID0+IGFiKGEpICYmIGJjKGEpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0ID0gKHNlbGYsIHRoYXQpID0+IChbYSwgYl0pID0+IHNlbGYoYSkgJiYgdGhhdChiKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSBjb2xsZWN0aW9uID0+IHtcbiAgcmV0dXJuIGFzID0+IHtcbiAgICBsZXQgY29sbGVjdGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IHAgb2YgY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb25JbmRleCA+PSBhcy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocChhc1tjb2xsZWN0aW9uSW5kZXhdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29sbGVjdGlvbkluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0TWFueSA9IChzZWxmLCBjb2xsZWN0aW9uKSA9PiB7XG4gIGNvbnN0IHJlc3QgPSBhbGwoY29sbGVjdGlvbik7XG4gIHJldHVybiAoW2hlYWQsIC4uLnRhaWxdKSA9PiBzZWxmKGhlYWQpID09PSBmYWxzZSA/IGZhbHNlIDogcmVzdCh0YWlsKTtcbn07XG4vKipcbiAqIFNpbWlsYXIgdG8gYFByb21pc2UuYWxsYCBidXQgb3BlcmF0ZXMgb24gYFByZWRpY2F0ZWBzLlxuICpcbiAqIGBgYFxuICogW1JlZmluZW1lbnQ8QSwgQj4sIFJlZmluZW1lbnQ8QywgRD4sIC4uLl0gLT4gUmVmaW5lbWVudDxbQSwgQywgLi4uXSwgW0IsIEQsIC4uLl0+XG4gKiBbUHJlZGljYXRlPEE+LCBQcmVkaWNhdGU8Qj4sIC4uLl0gLT4gUHJlZGljYXRlPFtBLCBCLCAuLi5dPlxuICogW1JlZmluZW1lbnQ8QSwgQj4sIFByZWRpY2F0ZTxDPiwgLi4uXSAtPiBSZWZpbmVtZW50PFtBLCBDLCAuLi5dLCBbQiwgQywgLi4uXT5cbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgdHVwbGUgPSAoLi4uZWxlbWVudHMpID0+IGFsbChlbGVtZW50cyk7XG4vKipcbiAqIGBgYFxuICogeyBhYjogUmVmaW5lbWVudDxBLCBCPjsgY2Q6IFJlZmluZW1lbnQ8QywgRD4sIC4uLiB9IC0+IFJlZmluZW1lbnQ8eyBhYjogQTsgY2Q6IEM7IC4uLiB9LCB7IGFiOiBCOyBjZDogRDsgLi4uIH0+XG4gKiB7IGE6IFByZWRpY2F0ZTxBLCBCPjsgYjogUHJlZGljYXRlPEI+LCAuLi4gfSAtPiBQcmVkaWNhdGU8eyBhOiBBOyBiOiBCOyAuLi4gfT5cbiAqIHsgYWI6IFJlZmluZW1lbnQ8QSwgQj47IGM6IFByZWRpY2F0ZTxDPiwgLi4uIH0gLT4gUmVmaW5lbWVudDx7IGFiOiBBOyBjOiBDOyAuLi4gfSwgeyBhYjogQjsgYzog0KE7IC4uLiB9PlxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJ1Y3QgPSBmaWVsZHMgPT4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgcmV0dXJuIGEgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghZmllbGRzW2tleV0oYVtrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcbi8qKlxuICogTmVnYXRlcyB0aGUgcmVzdWx0IG9mIGEgZ2l2ZW4gcHJlZGljYXRlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSBwcmVkaWNhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBQcmVkaWNhdGUsIE51bWJlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IGlzUG9zaXRpdmUgPSBQcmVkaWNhdGUubm90KE51bWJlci5sZXNzVGhhbigwKSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzUG9zaXRpdmUoLTEpLCBmYWxzZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQb3NpdGl2ZSgwKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNQb3NpdGl2ZSgxKSwgdHJ1ZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBub3QgPSBzZWxmID0+IGEgPT4gIXNlbGYoYSk7XG4vKipcbiAqIENvbWJpbmVzIHR3byBwcmVkaWNhdGVzIGludG8gYSBuZXcgcHJlZGljYXRlIHRoYXQgcmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcmVkaWNhdGVzIHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gdGhhdCAtIEEgcHJlZGljYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUHJlZGljYXRlLCBOdW1iZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBub25aZXJvID0gUHJlZGljYXRlLm9yKE51bWJlci5sZXNzVGhhbigwKSwgTnVtYmVyLmdyZWF0ZXJUaGFuKDApKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobm9uWmVybygtMSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG5vblplcm8oMCksIGZhbHNlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChub25aZXJvKDEpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG9yID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGEgPT4gc2VsZihhKSB8fCB0aGF0KGEpKTtcbi8qKlxuICogQ29tYmluZXMgdHdvIHByZWRpY2F0ZXMgaW50byBhIG5ldyBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiBib3RoIG9mIHRoZSBwcmVkaWNhdGVzIHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gdGhhdCAtIEEgcHJlZGljYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgbWluTGVuZ3RoID0gKG46IG51bWJlcikgPT4gKHM6IHN0cmluZykgPT4gcy5sZW5ndGggPj0gblxuICogY29uc3QgbWF4TGVuZ3RoID0gKG46IG51bWJlcikgPT4gKHM6IHN0cmluZykgPT4gcy5sZW5ndGggPD0gblxuICpcbiAqIGNvbnN0IGxlbmd0aCA9IChuOiBudW1iZXIpID0+IFByZWRpY2F0ZS5hbmQobWluTGVuZ3RoKG4pLCBtYXhMZW5ndGgobikpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChsZW5ndGgoMikoXCJhYVwiKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobGVuZ3RoKDIpKFwiYVwiKSwgZmFsc2UpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGxlbmd0aCgyKShcImFhYVwiKSwgZmFsc2UpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYW5kID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGEgPT4gc2VsZihhKSAmJiB0aGF0KGEpKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHhvciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBhID0+IHNlbGYoYSkgIT09IHRoYXQoYSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZXF2ID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGEgPT4gc2VsZihhKSA9PT0gdGhhdChhKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGxvZ2ljYWwgaW1wbGljYXRpb24gY29tYmluYXRvciBmb3IgcHJlZGljYXRlcy4gSW4gZm9ybWFsXG4gKiBsb2dpYywgdGhlIGltcGxpY2F0aW9uIG9wZXJhdG9yIGAtPmAgZGVub3RlcyB0aGF0IGlmIHRoZSBmaXJzdCBwcm9wb3NpdGlvblxuICogKGFudGVjZWRlbnQpIGlzIHRydWUsIHRoZW4gdGhlIHNlY29uZCBwcm9wb3NpdGlvbiAoY29uc2VxdWVudCkgbXVzdCBhbHNvIGJlXG4gKiB0cnVlLiBJbiBzaW1wbGVyIHRlcm1zLCBgcCBpbXBsaWVzIHFgIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBcImlmIHAgdGhlbiBxXCIuIElmXG4gKiB0aGUgZmlyc3QgcHJlZGljYXRlIGhvbGRzLCB0aGVuIHRoZSBzZWNvbmQgcHJlZGljYXRlIG11c3QgaG9sZFxuICogZm9yIHRoZSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEluIHByYWN0aWNhbCB0ZXJtcyB3aXRoaW4gVHlwZVNjcmlwdCwgYHAgaW1wbGllcyBxYCBpcyBlcXVpdmFsZW50IHRvIGAhcCB8fCAocCAmJiBxKWAuXG4gKlxuICogTm90ZSB0aGF0IGlmIHRoZSBhbnRlY2VkZW50IGlzIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgYHRydWVgIGJ5IGRlZmF1bHRcbiAqIGJlY2F1c2UgdGhlIG91dGNvbWUgb2YgdGhlIGNvbnNlcXVlbnQgY2Fubm90IGJlIGRldGVybWluZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCB0byBlbmZvcmNlIHJ1bGVzIG9yXG4gKiBjb25zdHJhaW50cyB0aGF0IGFyZSBjb250aW5nZW50IG9uIGNlcnRhaW4gY29uZGl0aW9ucy5cbiAqIEl0IHByb3ZlcyBlc3BlY2lhbGx5IGhlbHBmdWwgaW4gZGVmaW5pbmcgcHJvcGVydHkgdGVzdHMuXG4gKlxuICogVGhlIGV4YW1wbGUgYmVsb3cgaWxsdXN0cmF0ZXMgdGhlIHRyYW5zaXRpdmUgcHJvcGVydHkgb2Ygb3JkZXIgdXNpbmcgdGhlXG4gKiBgaW1wbGllc2AgZnVuY3Rpb24uIEluIHNpbXBsZSB0ZXJtcywgaWYgYGEgPD0gYmAgYW5kIGBiIDw9IGNgLCB0aGVuIGBhIDw9IGNgXG4gKiBtdXN0IGJlIHRydWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiB0eXBlIFRyaXBsZSA9IHtcbiAqICAgcmVhZG9ubHkgYTogbnVtYmVyXG4gKiAgIHJlYWRvbmx5IGI6IG51bWJlclxuICogICByZWFkb25seSBjOiBudW1iZXJcbiAqIH1cbiAqXG4gKiBjb25zdCB0cmFuc2l0aXZpdHkgPSBQcmVkaWNhdGUuaW1wbGllcyhcbiAqICAgLy8gYW50ZWNlZGVudFxuICogICAoaW5wdXQ6IFRyaXBsZSkgPT4gaW5wdXQuYSA8PSBpbnB1dC5iICYmIGlucHV0LmIgPD0gaW5wdXQuYyxcbiAqICAgLy8gY29uc2VxdWVudFxuICogICAoaW5wdXQ6IFRyaXBsZSkgPT4gaW5wdXQuYSA8PSBpbnB1dC5jXG4gKiApXG4gKlxuICogYXNzZXJ0LmVxdWFsKHRyYW5zaXRpdml0eSh7IGE6IDEsIGI6IDIsIGM6IDMgfSksIHRydWUpXG4gKiAvLyBhbnRlY2VkZW50IGlzIGBmYWxzZWAsIHNvIHRoZSByZXN1bHQgaXMgYHRydWVgXG4gKiBhc3NlcnQuZXF1YWwodHJhbnNpdGl2aXR5KHsgYTogMSwgYjogMCwgYzogMCB9KSwgdHJ1ZSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBsaWVzID0gLyojX19QVVJFX18qL2R1YWwoMiwgKGFudGVjZWRlbnQsIGNvbnNlcXVlbnQpID0+IGEgPT4gYW50ZWNlZGVudChhKSA/IGNvbnNlcXVlbnQoYSkgOiB0cnVlKTtcbi8qKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG5vciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBhID0+ICEoc2VsZihhKSB8fCB0aGF0KGEpKSk7XG4vKipcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBuYW5kID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IGEgPT4gIShzZWxmKGEpICYmIHRoYXQoYSkpKTtcbi8qKlxuICogQGNhdGVnb3J5IGVsZW1lbnRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gY29sbGVjdGlvbiA9PiBhID0+IHtcbiAgZm9yIChjb25zdCBwIG9mIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoIXAoYSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgZWxlbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc29tZSA9IGNvbGxlY3Rpb24gPT4gYSA9PiB7XG4gIGZvciAoY29uc3QgcCBvZiBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHAoYSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlZGljYXRlLmpzLm1hcCJdLCJuYW1lcyI6WyJkdWFsIiwiaXNGdW5jdGlvbiIsImlzRnVuY3Rpb25fIiwibWFwSW5wdXQiLCJzZWxmIiwiZiIsImIiLCJpc1R1cGxlT2YiLCJuIiwibGVuZ3RoIiwiaXNUdXBsZU9mQXRMZWFzdCIsImlzVHJ1dGh5IiwiaW5wdXQiLCJpc1NldCIsIlNldCIsImlzTWFwIiwiTWFwIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzQm9vbGVhbiIsImlzQmlnSW50IiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsInVuZGVmaW5lZCIsImlzTm90VW5kZWZpbmVkIiwiaXNOdWxsIiwiaXNOb3ROdWxsIiwiaXNOZXZlciIsIl8iLCJpc1Vua25vd24iLCJpc1JlY29yZE9yQXJyYXkiLCJpc09iamVjdCIsImhhc1Byb3BlcnR5IiwicHJvcGVydHkiLCJpc1RhZ2dlZCIsInRhZyIsImlzTnVsbGFibGUiLCJpc05vdE51bGxhYmxlIiwiaXNFcnJvciIsIkVycm9yIiwiaXNVaW50OEFycmF5IiwiVWludDhBcnJheSIsImlzRGF0ZSIsIkRhdGUiLCJpc0l0ZXJhYmxlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc1JlY29yZCIsIkFycmF5IiwiaXNBcnJheSIsImlzUmVhZG9ubHlSZWNvcmQiLCJpc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJpc1Byb21pc2VMaWtlIiwiaXNSZWdFeHAiLCJSZWdFeHAiLCJjb21wb3NlIiwiYWIiLCJiYyIsImEiLCJwcm9kdWN0IiwidGhhdCIsImFsbCIsImNvbGxlY3Rpb24iLCJhcyIsImNvbGxlY3Rpb25JbmRleCIsInAiLCJwcm9kdWN0TWFueSIsInJlc3QiLCJoZWFkIiwidGFpbCIsInR1cGxlIiwiZWxlbWVudHMiLCJzdHJ1Y3QiLCJmaWVsZHMiLCJrZXlzIiwiT2JqZWN0Iiwia2V5Iiwibm90Iiwib3IiLCJhbmQiLCJ4b3IiLCJlcXYiLCJpbXBsaWVzIiwiYW50ZWNlZGVudCIsImNvbnNlcXVlbnQiLCJub3IiLCJuYW5kIiwiZXZlcnkiLCJzb21lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Predicate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Record.js":
/*!************************************************!*\
  !*** ./node_modules/effect/dist/esm/Record.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   collect: () => (/* binding */ collect),\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   filterMap: () => (/* binding */ filterMap),\n/* harmony export */   fromEntries: () => (/* binding */ fromEntries),\n/* harmony export */   fromIterableBy: () => (/* binding */ fromIterableBy),\n/* harmony export */   fromIterableWith: () => (/* binding */ fromIterableWith),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getLefts: () => (/* binding */ getLefts),\n/* harmony export */   getRights: () => (/* binding */ getRights),\n/* harmony export */   getSomes: () => (/* binding */ getSomes),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   isEmptyReadonlyRecord: () => (/* binding */ isEmptyReadonlyRecord),\n/* harmony export */   isEmptyRecord: () => (/* binding */ isEmptyRecord),\n/* harmony export */   isSubrecord: () => (/* binding */ isSubrecord),\n/* harmony export */   isSubrecordBy: () => (/* binding */ isSubrecordBy),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapEntries: () => (/* binding */ mapEntries),\n/* harmony export */   mapKeys: () => (/* binding */ mapKeys),\n/* harmony export */   modify: () => (/* binding */ modify),\n/* harmony export */   modifyOption: () => (/* binding */ modifyOption),\n/* harmony export */   partition: () => (/* binding */ partition),\n/* harmony export */   partitionMap: () => (/* binding */ partitionMap),\n/* harmony export */   pop: () => (/* binding */ pop),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   replaceOption: () => (/* binding */ replaceOption),\n/* harmony export */   separate: () => (/* binding */ separate),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   singleton: () => (/* binding */ singleton),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   toEntries: () => (/* binding */ toEntries),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   values: () => (/* binding */ values)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _Option_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Option.js */ \"(ssr)/./node_modules/effect/dist/esm/Option.js\");\n/**\n * This module provides utility functions for working with records in TypeScript.\n *\n * @since 2.0.0\n */ \n\n\n\n/**\n * Creates a new, empty record.\n *\n * @category constructors\n * @since 2.0.0\n */ const empty = ()=>({});\n/**\n * Determine if a record is empty.\n *\n * @param self - record to test for emptiness.\n *\n * @example\n * ```ts\n * import { isEmptyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyRecord({}), true);\n * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isEmptyRecord = (self)=>keys(self).length === 0;\n/**\n * Determine if a record is empty.\n *\n * @param self - record to test for emptiness.\n *\n * @example\n * ```ts\n * import { isEmptyReadonlyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\n * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n * ```\n *\n * @category guards\n * @since 2.0.0\n */ const isEmptyReadonlyRecord = isEmptyRecord;\n/**\n * Takes an iterable and a projection function and returns a record.\n * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n *\n * @param self - An iterable of values to be mapped to a record.\n * @param f - A projection function that maps values of the iterable to a tuple of a key and a value.\n *\n * @example\n * ```ts\n * import { fromIterableWith } from \"effect/Record\"\n *\n * const input = [1, 2, 3, 4]\n *\n * assert.deepStrictEqual(\n *   fromIterableWith(input, a => [String(a), a * 2]),\n *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const fromIterableWith = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = empty();\n    for (const a of self){\n        const [k, b] = f(a);\n        out[k] = b;\n    }\n    return out;\n});\n/**\n * Creates a new record from an iterable, utilizing the provided function to determine the key for each element.\n *\n * @param items - An iterable containing elements.\n * @param f - A function that extracts the key for each element.\n *\n * @example\n * ```ts\n * import { fromIterableBy } from \"effect/Record\"\n *\n * const users = [\n *   { id: \"2\", name: \"name2\" },\n *   { id: \"1\", name: \"name1\" }\n * ]\n *\n * assert.deepStrictEqual(\n *   fromIterableBy(users, user => user.id),\n *   {\n *     \"2\": { id: \"2\", name: \"name2\" },\n *     \"1\": { id: \"1\", name: \"name1\" }\n *   }\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const fromIterableBy = (items, f)=>fromIterableWith(items, (a)=>[\n            f(a),\n            a\n        ]);\n/**\n * Builds a record from an iterable of key-value pairs.\n *\n * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\n * previous ones. So the resulting record will only have the value of the last occurrence of each key.\n *\n * @param self - The iterable of key-value pairs.\n *\n * @example\n * ```ts\n * import { fromEntries } from \"effect/Record\"\n *\n * const input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n *\n * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */ const fromEntries = Object.fromEntries;\n/**\n * Transforms the values of a record into an `Array` with a custom mapping function.\n *\n * @param self - The record to transform.\n * @param f - The custom mapping function to apply to each key/value of the record.\n *\n * @example\n * ```ts\n * import { collect } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const collect = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = [];\n    for (const key of keys(self)){\n        out.push(f(key, self[key]));\n    }\n    return out;\n});\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * ```ts\n * import { toEntries } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */ const toEntries = /*#__PURE__*/ collect((key, value)=>[\n        key,\n        value\n    ]);\n/**\n * Returns the number of key/value pairs in a record.\n *\n * @param self - A record to calculate the number of key/value pairs in.\n *\n * @example\n * ```ts\n * import { size } from \"effect/Record\";\n *\n * assert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n * ```\n *\n * @since 2.0.0\n */ const size = (self)=>keys(self).length;\n/**\n * Check if a given `key` exists in a record.\n *\n * @param self - the record to look in.\n * @param key - the key to look for in the record.\n *\n * @example\n * ```ts\n * import { empty, has } from \"effect/Record\"\n *\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n * ```\n *\n * @since 2.0.0\n */ const has = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, key)=>Object.prototype.hasOwnProperty.call(self, key));\n/**\n * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n *\n * @param self - The record to retrieve value from.\n * @param key - Key to retrieve from record.\n *\n * @example\n * ```ts\n * import { Record as R, Option } from \"effect\"\n *\n * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n *\n * assert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\n * assert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n * ```\n *\n * @since 2.0.0\n */ const get = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, key)=>has(self, key) ? _Option_js__WEBPACK_IMPORTED_MODULE_1__.some(self[key]) : _Option_js__WEBPACK_IMPORTED_MODULE_1__.none());\n/**\n * Apply a function to the element at the specified key, creating a new record.\n * If the key does not exist, the record is returned unchanged.\n *\n * @param self - The record to be updated.\n * @param key - The key of the element to modify.\n * @param f - The function to apply to the element.\n *\n * @example\n * ```ts\n * import { Record as R } from \"effect\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  R.modify({ a: 3 }, 'a', f),\n *  { a: 6 }\n * )\n * assert.deepStrictEqual(\n *  R.modify({ a: 3 } as Record<string, number>, 'b', f),\n *  { a: 3 }\n * )\n * ```\n *\n * @since 2.0.0\n */ const modify = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, key, f)=>{\n    if (!has(self, key)) {\n        return {\n            ...self\n        };\n    }\n    return {\n        ...self,\n        [key]: f(self[key])\n    };\n});\n/**\n * Apply a function to the element at the specified key, creating a new record,\n * or return `None` if the key doesn't exist.\n *\n * @param self - The record to be updated.\n * @param key - The key of the element to modify.\n * @param f - The function to apply to the element.\n *\n * @example\n * ```ts\n * import { Record as R, Option } from \"effect\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  R.modifyOption({ a: 3 }, 'a', f),\n *  Option.some({ a: 6 })\n * )\n * assert.deepStrictEqual(\n *  R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n *  Option.none()\n * )\n * ```\n *\n * @since 2.0.0\n */ const modifyOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, key, f)=>{\n    if (!has(self, key)) {\n        return _Option_js__WEBPACK_IMPORTED_MODULE_1__.none();\n    }\n    return _Option_js__WEBPACK_IMPORTED_MODULE_1__.some({\n        ...self,\n        [key]: f(self[key])\n    });\n});\n/**\n * Replaces a value in the record with the new value passed as parameter.\n *\n * @param self - The record to be updated.\n * @param key - The key to search for in the record.\n * @param b - The new value to replace the existing value with.\n *\n * @example\n * ```ts\n * import { Record, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n *   Option.some({ a: 10, b: 2, c: 3 })\n * )\n * assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n * ```\n *\n * @since 2.0.0\n */ const replaceOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, key, b)=>modifyOption(self, key, ()=>b));\n/**\n * If the given key exists in the record, returns a new record with the key removed,\n * otherwise returns a copy of the original record.\n *\n * @param self - the record to remove the key from.\n * @param key - the key to remove from the record.\n *\n * @example\n * ```ts\n * import { remove } from \"effect/Record\"\n *\n * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n * ```\n *\n * @since 2.0.0\n */ const remove = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, key)=>{\n    if (!has(self, key)) {\n        return {\n            ...self\n        };\n    }\n    const out = {\n        ...self\n    };\n    delete out[key];\n    return out;\n});\n/**\n * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n * of a tuple with the value and the record with the removed property.\n * If the key is not present, returns `O.none`.\n *\n * @param self - The input record.\n * @param key - The key of the property to retrieve.\n *\n * @example\n * ```ts\n * import { Record as R, Option } from \"effect\"\n *\n * assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\n * assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n * ```\n *\n * @category record\n * @since 2.0.0\n */ const pop = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, key)=>has(self, key) ? _Option_js__WEBPACK_IMPORTED_MODULE_1__.some([\n        self[key],\n        remove(self, key)\n    ]) : _Option_js__WEBPACK_IMPORTED_MODULE_1__.none());\n/**\n * Maps a record into another record by applying a transformation function to each of its values.\n *\n * @param self - The record to be mapped.\n * @param f - A transformation function that will be applied to each of the values in the record.\n *\n * @example\n * ```ts\n * import { map } from \"effect/Record\"\n *\n * const f = (n: number) => `-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n *\n * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = {\n        ...self\n    };\n    for (const key of keys(self)){\n        out[key] = f(self[key], key);\n    }\n    return out;\n});\n/**\n * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n *\n * @example\n * ```ts\n * import { mapKeys } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */ const mapKeys = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = {};\n    for (const key of keys(self)){\n        const a = self[key];\n        out[f(key, a)] = a;\n    }\n    return out;\n});\n/**\n * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n *\n * @example\n * ```ts\n * import { mapEntries } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */ const mapEntries = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = {};\n    for (const key of keys(self)){\n        const [k, b] = f(self[key], key);\n        out[k] = b;\n    }\n    return out;\n});\n/**\n * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n * If the function returns `Some`, the key-value pair is included in the output record.\n *\n * @param self - The input record.\n * @param f - The transformation function.\n *\n * @example\n * ```ts\n * import { Record, Option } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\n * assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n * ```\n *\n * @since 2.0.0\n */ const filterMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const out = empty();\n    for (const key of keys(self)){\n        const o = f(self[key], key);\n        if (_Option_js__WEBPACK_IMPORTED_MODULE_1__.isSome(o)) {\n            out[key] = o.value;\n        }\n    }\n    return out;\n});\n/**\n * Selects properties from a record whose values match the given predicate.\n *\n * @param self - The record to filter.\n * @param predicate - A function that returns a `boolean` value to determine if the entry should be included in the new record.\n *\n * @example\n * ```ts\n * import { filter } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3, d: 4 }\n * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const filter = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    const out = empty();\n    for (const key of keys(self)){\n        if (predicate(self[key], key)) {\n            out[key] = self[key];\n        }\n    }\n    return out;\n});\n/**\n * Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.\n *\n * @param self - A record with `Option` values.\n *\n * @example\n * ```ts\n * import { Record, Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),\n *   { a: 1, c: 2 }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getSomes = /*#__PURE__*/ filterMap(_Function_js__WEBPACK_IMPORTED_MODULE_0__.identity);\n/**\n * Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getLefts({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n *   { b: \"err\" }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getLefts = (self)=>{\n    const out = empty();\n    for (const key of keys(self)){\n        const value = self[key];\n        if (_Either_js__WEBPACK_IMPORTED_MODULE_2__.isLeft(value)) {\n            out[key] = value.left;\n        }\n    }\n    return out;\n};\n/**\n * Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.\n *\n * @example\n * ```ts\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.getRights({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n *   { a: 1, c: 2 }\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const getRights = (self)=>{\n    const out = empty();\n    for (const key of keys(self)){\n        const value = self[key];\n        if (_Either_js__WEBPACK_IMPORTED_MODULE_2__.isRight(value)) {\n            out[key] = value.right;\n        }\n    }\n    return out;\n};\n/**\n * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n *\n * @param self - The record to partition.\n * @param f - The predicate function to apply to each element.\n *\n * @example\n * ```ts\n * import { Record, Either } from \"effect\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\n * assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const partitionMap = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>{\n    const left = empty();\n    const right = empty();\n    for (const key of keys(self)){\n        const e = f(self[key], key);\n        if (_Either_js__WEBPACK_IMPORTED_MODULE_2__.isLeft(e)) {\n            left[key] = e.left;\n        } else {\n            right[key] = e.right;\n        }\n    }\n    return [\n        left,\n        right\n    ];\n});\n/**\n * Partitions a record of `Either` values into two separate records,\n * one with the `Left` values and one with the `Right` values.\n *\n * @param self - the record to partition.\n *\n * @example\n * ```ts\n * import { Record, Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Record.separate({ a: Either.left(\"e\"), b: Either.right(1) }),\n *   [{ a: \"e\" }, { b: 1 }]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const separate = /*#__PURE__*/ partitionMap(_Function_js__WEBPACK_IMPORTED_MODULE_0__.identity);\n/**\n * Partitions a record into two separate records based on the result of a predicate function.\n *\n * @param self - The input record to partition.\n * @param predicate - The partitioning function to determine the partitioning of each value of the record.\n *\n * @example\n * ```ts\n * import { partition } from \"effect/Record\"\n *\n * assert.deepStrictEqual(\n *   partition({ a: 1, b: 3 }, (n) => n > 2),\n *   [{ a: 1 }, { b: 3 }]\n * )\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */ const partition = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    const left = empty();\n    const right = empty();\n    for (const key of keys(self)){\n        if (predicate(self[key], key)) {\n            right[key] = self[key];\n        } else {\n            left[key] = self[key];\n        }\n    }\n    return [\n        left,\n        right\n    ];\n});\n/**\n * Retrieve the keys of a given record as an array.\n *\n * @param self - The object for which you want to get the keys.\n *\n * @since 2.0.0\n */ const keys = (self)=>Object.keys(self);\n/**\n * Retrieve the values of a given record as an array.\n *\n * @param self - The object for which you want to get the values.\n *\n * @since 2.0.0\n */ const values = (self)=>collect(self, (_, a)=>a);\n/**\n * Add a new key-value pair or update an existing key's value in a record.\n *\n * @param self - The record to which you want to add or update a key-value pair.\n * @param key - The key you want to add or update.\n * @param values - The value you want to associate with the key.\n *\n * @example\n * ```ts\n * import { set } from \"effect/Record\"\n *\n * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n * ```\n *\n * @since 2.0.0\n */ const set = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, key, value)=>{\n    return {\n        ...self,\n        [key]: value\n    };\n});\n/**\n * Replace a key's value in a record and return the updated record.\n * If the key does not exist in the record, a copy of the original record is returned.\n *\n * @param self - The original record.\n * @param key - The key to replace.\n * @param value - The new value to associate with the key.\n *\n * @example\n * ```ts\n * import { Record } from \"effect\"\n *\n * assert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n * assert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n * ```\n *\n * @since 2.0.0\n */ const replace = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, key, value)=>{\n    if (has(self, key)) {\n        return {\n            ...self,\n            [key]: value\n        };\n    }\n    return {\n        ...self\n    };\n});\n/**\n * Check if all the keys and values in one record are also found in another record.\n *\n * @param self - The first record to check.\n * @param that - The second record to compare against.\n * @param equivalence - A function to compare values.\n *\n * @since 2.0.0\n */ const isSubrecordBy = (equivalence)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>{\n        for (const key of keys(self)){\n            if (!has(that, key) || !equivalence(self[key], that[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n/**\n * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n * This comparison uses default equality checks (`Equal.equivalence()`).\n *\n * @param self - The first record to check.\n * @param that - The second record to compare against.\n *\n * @since 2.0.0\n */ const isSubrecord = /*#__PURE__*/ isSubrecordBy(/*#__PURE__*/ _Equal_js__WEBPACK_IMPORTED_MODULE_3__.equivalence());\n/**\n * Reduce a record to a single value by combining its entries with a specified function.\n *\n * @param self - The record to reduce.\n * @param zero - The initial value of the accumulator.\n * @param f - The function to combine entries (accumulator, value, key).\n *\n * @category folding\n * @since 2.0.0\n */ const reduce = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, zero, f)=>{\n    let out = zero;\n    for (const key of keys(self)){\n        out = f(out, self[key], key);\n    }\n    return out;\n});\n/**\n * Check if all entries in a record meet a specific condition.\n *\n * @param self - The record to check.\n * @param predicate - The condition to test entries (value, key).\n *\n * @since 2.0.0\n */ const every = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, refinement)=>{\n    for (const key of keys(self)){\n        if (!refinement(self[key], key)) {\n            return false;\n        }\n    }\n    return true;\n});\n/**\n * Check if any entry in a record meets a specific condition.\n *\n * @param self - The record to check.\n * @param predicate - The condition to test entries (value, key).\n *\n * @since 2.0.0\n */ const some = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, predicate)=>{\n    for (const key of keys(self)){\n        if (predicate(self[key], key)) {\n            return true;\n        }\n    }\n    return false;\n});\n/**\n * Merge two records, preserving entries that exist in either of the records.\n *\n * @param self - The first record.\n * @param that - The second record to combine with the first.\n * @param combine - A function to specify how to merge entries with the same key.\n *\n * @since 2.0.0\n */ const union = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, combine)=>{\n    if (isEmptyRecord(self)) {\n        return {\n            ...that\n        };\n    }\n    if (isEmptyRecord(that)) {\n        return {\n            ...self\n        };\n    }\n    const out = empty();\n    for (const key of keys(self)){\n        if (has(that, key)) {\n            out[key] = combine(self[key], that[key]);\n        } else {\n            out[key] = self[key];\n        }\n    }\n    for (const key of keys(that)){\n        if (!has(out, key)) {\n            out[key] = that[key];\n        }\n    }\n    return out;\n});\n/**\n * Merge two records, retaining only the entries that exist in both records.\n *\n * @param self - The first record.\n * @param that - The second record to merge with the first.\n * @param combine - A function to specify how to merge entries with the same key.\n *\n * @since 2.0.0\n */ const intersection = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, that, combine)=>{\n    const out = empty();\n    if (isEmptyRecord(self) || isEmptyRecord(that)) {\n        return out;\n    }\n    for (const key of keys(self)){\n        if (has(that, key)) {\n            out[key] = combine(self[key], that[key]);\n        }\n    }\n    return out;\n});\n/**\n * Merge two records, preserving only the entries that are unique to each record.\n *\n * @param self - The first record.\n * @param that - The second record to compare with the first.\n *\n * @since 2.0.0\n */ const difference = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>{\n    if (isEmptyRecord(self)) {\n        return {\n            ...that\n        };\n    }\n    if (isEmptyRecord(that)) {\n        return {\n            ...self\n        };\n    }\n    const out = {};\n    for (const key of keys(self)){\n        if (!has(that, key)) {\n            out[key] = self[key];\n        }\n    }\n    for (const key of keys(that)){\n        if (!has(self, key)) {\n            out[key] = that[key];\n        }\n    }\n    return out;\n});\n/**\n * Create an `Equivalence` for records using the provided `Equivalence` for values.\n *\n * @param equivalence - An `Equivalence` for the values contained in the records.\n *\n * @category instances\n * @since 2.0.0\n */ const getEquivalence = (equivalence)=>{\n    const is = isSubrecordBy(equivalence);\n    return (self, that)=>is(self, that) && is(that, self);\n};\n/**\n * Create a non-empty record from a single element.\n *\n * @param key - The key for the element.\n * @param value - The value associated with the key.\n *\n * @category constructors\n * @since 2.0.0\n */ const singleton = (key, value)=>({\n        [key]: value\n    }); //# sourceMappingURL=Record.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1JlY29yZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ2dDO0FBQ0c7QUFDVztBQUNUO0FBQ3RDOzs7OztDQUtDLEdBQ00sTUFBTUssUUFBUSxJQUFPLEVBQUMsR0FBRztBQUNoQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNQyxnQkFBZ0JDLENBQUFBLE9BQVFDLEtBQUtELE1BQU1FLE1BQU0sS0FBSyxFQUFFO0FBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLE1BQU1DLHdCQUF3QkosY0FBYztBQUNuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sTUFBTUssbUJBQW1CLFdBQVcsR0FBRVQsa0RBQUlBLENBQUMsR0FBRyxDQUFDSyxNQUFNSztJQUMxRCxNQUFNQyxNQUFNUjtJQUNaLEtBQUssTUFBTVMsS0FBS1AsS0FBTTtRQUNwQixNQUFNLENBQUNRLEdBQUdDLEVBQUUsR0FBR0osRUFBRUU7UUFDakJELEdBQUcsQ0FBQ0UsRUFBRSxHQUFHQztJQUNYO0lBQ0EsT0FBT0g7QUFDVCxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ00sTUFBTUksaUJBQWlCLENBQUNDLE9BQU9OLElBQU1ELGlCQUFpQk8sT0FBT0osQ0FBQUEsSUFBSztZQUFDRixFQUFFRTtZQUFJQTtTQUFFLEVBQUU7QUFDcEY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxNQUFNSyxjQUFjQyxPQUFPRCxXQUFXLENBQUM7QUFDOUM7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNRSxVQUFVLFdBQVcsR0FBRW5CLGtEQUFJQSxDQUFDLEdBQUcsQ0FBQ0ssTUFBTUs7SUFDakQsTUFBTUMsTUFBTSxFQUFFO0lBQ2QsS0FBSyxNQUFNUyxPQUFPZCxLQUFLRCxNQUFPO1FB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QUtiLGNBQWNDO0lBQ3pCLE9BQU8sQ0FBQ3hELE1BQU15RCxPQUFTVyxHQUFHcEUsTUFBTXlELFNBQVNXLEdBQUdYLE1BQU16RDtBQUNwRCxFQUFFO0FBQ0Y7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNcUUsWUFBWSxDQUFDdEQsS0FBS0csUUFBVztRQUN4QyxDQUFDSCxJQUFJLEVBQUVHO0lBQ1QsR0FBRyxDQUNILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vUmVjb3JkLmpzPzY2YjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIHJlY29yZHMgaW4gVHlwZVNjcmlwdC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0ICogYXMgRSBmcm9tIFwiLi9FaXRoZXIuanNcIjtcbmltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuL0VxdWFsLmpzXCI7XG5pbXBvcnQgeyBkdWFsLCBpZGVudGl0eSB9IGZyb20gXCIuL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBPcHRpb24gZnJvbSBcIi4vT3B0aW9uLmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHJlY29yZC5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5ID0gKCkgPT4gKHt9KTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVjb3JkIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gcmVjb3JkIHRvIHRlc3QgZm9yIGVtcHRpbmVzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGlzRW1wdHlSZWNvcmQgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChpc0VtcHR5UmVjb3JkKHt9KSwgdHJ1ZSk7XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRW1wdHlSZWNvcmQoeyBhOiAzIH0pLCBmYWxzZSk7XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ3VhcmRzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHlSZWNvcmQgPSBzZWxmID0+IGtleXMoc2VsZikubGVuZ3RoID09PSAwO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZWNvcmQgaXMgZW1wdHkuXG4gKlxuICogQHBhcmFtIHNlbGYgLSByZWNvcmQgdG8gdGVzdCBmb3IgZW1wdGluZXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNFbXB0eVJlYWRvbmx5UmVjb3JkIH0gZnJvbSBcImVmZmVjdC9SZWNvcmRcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNFbXB0eVJlYWRvbmx5UmVjb3JkKHt9KSwgdHJ1ZSk7XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzRW1wdHlSZWFkb25seVJlY29yZCh7IGE6IDMgfSksIGZhbHNlKTtcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBndWFyZHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaXNFbXB0eVJlYWRvbmx5UmVjb3JkID0gaXNFbXB0eVJlY29yZDtcbi8qKlxuICogVGFrZXMgYW4gaXRlcmFibGUgYW5kIGEgcHJvamVjdGlvbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIHJlY29yZC5cbiAqIFRoZSBwcm9qZWN0aW9uIGZ1bmN0aW9uIG1hcHMgZWFjaCB2YWx1ZSBvZiB0aGUgaXRlcmFibGUgdG8gYSB0dXBsZSBvZiBhIGtleSBhbmQgYSB2YWx1ZSwgd2hpY2ggaXMgdGhlbiBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIEFuIGl0ZXJhYmxlIG9mIHZhbHVlcyB0byBiZSBtYXBwZWQgdG8gYSByZWNvcmQuXG4gKiBAcGFyYW0gZiAtIEEgcHJvamVjdGlvbiBmdW5jdGlvbiB0aGF0IG1hcHMgdmFsdWVzIG9mIHRoZSBpdGVyYWJsZSB0byBhIHR1cGxlIG9mIGEga2V5IGFuZCBhIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUl0ZXJhYmxlV2l0aCB9IGZyb20gXCJlZmZlY3QvUmVjb3JkXCJcbiAqXG4gKiBjb25zdCBpbnB1dCA9IFsxLCAyLCAzLCA0XVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIGZyb21JdGVyYWJsZVdpdGgoaW5wdXQsIGEgPT4gW1N0cmluZyhhKSwgYSAqIDJdKSxcbiAqICAgeyAnMSc6IDIsICcyJzogNCwgJzMnOiA2LCAnNCc6IDggfVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tSXRlcmFibGVXaXRoID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgY29uc3Qgb3V0ID0gZW1wdHkoKTtcbiAgZm9yIChjb25zdCBhIG9mIHNlbGYpIHtcbiAgICBjb25zdCBbaywgYl0gPSBmKGEpO1xuICAgIG91dFtrXSA9IGI7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlY29yZCBmcm9tIGFuIGl0ZXJhYmxlLCB1dGlsaXppbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUga2V5IGZvciBlYWNoIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIGl0ZW1zIC0gQW4gaXRlcmFibGUgY29udGFpbmluZyBlbGVtZW50cy5cbiAqIEBwYXJhbSBmIC0gQSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSBrZXkgZm9yIGVhY2ggZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21JdGVyYWJsZUJ5IH0gZnJvbSBcImVmZmVjdC9SZWNvcmRcIlxuICpcbiAqIGNvbnN0IHVzZXJzID0gW1xuICogICB7IGlkOiBcIjJcIiwgbmFtZTogXCJuYW1lMlwiIH0sXG4gKiAgIHsgaWQ6IFwiMVwiLCBuYW1lOiBcIm5hbWUxXCIgfVxuICogXVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIGZyb21JdGVyYWJsZUJ5KHVzZXJzLCB1c2VyID0+IHVzZXIuaWQpLFxuICogICB7XG4gKiAgICAgXCIyXCI6IHsgaWQ6IFwiMlwiLCBuYW1lOiBcIm5hbWUyXCIgfSxcbiAqICAgICBcIjFcIjogeyBpZDogXCIxXCIsIG5hbWU6IFwibmFtZTFcIiB9XG4gKiAgIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZnJvbUl0ZXJhYmxlQnkgPSAoaXRlbXMsIGYpID0+IGZyb21JdGVyYWJsZVdpdGgoaXRlbXMsIGEgPT4gW2YoYSksIGFdKTtcbi8qKlxuICogQnVpbGRzIGEgcmVjb3JkIGZyb20gYW4gaXRlcmFibGUgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIElmIHRoZXJlIGFyZSBjb25mbGljdGluZyBrZXlzIHdoZW4gdXNpbmcgYGZyb21FbnRyaWVzYCwgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiB0aGUga2V5L3ZhbHVlIHBhaXIgd2lsbCBvdmVyd3JpdGUgdGhlXG4gKiBwcmV2aW91cyBvbmVzLiBTbyB0aGUgcmVzdWx0aW5nIHJlY29yZCB3aWxsIG9ubHkgaGF2ZSB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGtleS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBpdGVyYWJsZSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRW50cmllcyB9IGZyb20gXCJlZmZlY3QvUmVjb3JkXCJcbiAqXG4gKiBjb25zdCBpbnB1dDogQXJyYXk8W3N0cmluZywgbnVtYmVyXT4gPSBbW1wiYVwiLCAxXSwgW1wiYlwiLCAyXV1cbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGZyb21FbnRyaWVzKGlucHV0KSwgeyBhOiAxLCBiOiAyIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21FbnRyaWVzID0gT2JqZWN0LmZyb21FbnRyaWVzO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2YWx1ZXMgb2YgYSByZWNvcmQgaW50byBhbiBgQXJyYXlgIHdpdGggYSBjdXN0b20gbWFwcGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIGYgLSBUaGUgY3VzdG9tIG1hcHBpbmcgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBrZXkvdmFsdWUgb2YgdGhlIHJlY29yZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNvbGxlY3QgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogY29uc3QgeCA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGNvbGxlY3QoeCwgKGtleSwgbikgPT4gW2tleSwgbl0pLCBbW1wiYVwiLCAxXSwgW1wiYlwiLCAyXSwgW1wiY1wiLCAzXV0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgY29sbGVjdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKHNlbGYpKSB7XG4gICAgb3V0LnB1c2goZihrZXksIHNlbGZba2V5XSkpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbi8qKlxuICogVGFrZXMgYSByZWNvcmQgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdHVwbGVzIGNvbnRhaW5pbmcgaXRzIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gdHJhbnNmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdG9FbnRyaWVzIH0gZnJvbSBcImVmZmVjdC9SZWNvcmRcIlxuICpcbiAqIGNvbnN0IHggPSB7IGE6IDEsIGI6IDIsIGM6IDMgfVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh0b0VudHJpZXMoeCksIFtbXCJhXCIsIDFdLCBbXCJiXCIsIDJdLCBbXCJjXCIsIDNdXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB0b0VudHJpZXMgPSAvKiNfX1BVUkVfXyovY29sbGVjdCgoa2V5LCB2YWx1ZSkgPT4gW2tleSwgdmFsdWVdKTtcbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleS92YWx1ZSBwYWlycyBpbiBhIHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIEEgcmVjb3JkIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGtleS92YWx1ZSBwYWlycyBpbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNpemUgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiO1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc2l6ZSh7IGE6IFwiYVwiLCBiOiAxLCBjOiB0cnVlIH0pLCAzKTtcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2l6ZSA9IHNlbGYgPT4ga2V5cyhzZWxmKS5sZW5ndGg7XG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gYGtleWAgZXhpc3RzIGluIGEgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gdGhlIHJlY29yZCB0byBsb29rIGluLlxuICogQHBhcmFtIGtleSAtIHRoZSBrZXkgdG8gbG9vayBmb3IgaW4gdGhlIHJlY29yZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVtcHR5LCBoYXMgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChoYXMoeyBhOiAxLCBiOiAyIH0sIFwiYVwiKSwgdHJ1ZSk7XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGhhcyhlbXB0eTxzdHJpbmc+KCksIFwiY1wiKSwgZmFsc2UpO1xuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBoYXMgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwga2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZiwga2V5KSk7XG4vKipcbiAqIFJldHJpZXZlIGEgdmFsdWUgYXQgYSBwYXJ0aWN1bGFyIGtleSBmcm9tIGEgcmVjb3JkLCByZXR1cm5pbmcgaXQgd3JhcHBlZCBpbiBhbiBgT3B0aW9uYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gcmV0cmlldmUgdmFsdWUgZnJvbS5cbiAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gcmV0cmlldmUgZnJvbSByZWNvcmQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQgYXMgUiwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgcGVyc29uOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHsgbmFtZTogXCJKb2huIERvZVwiLCBhZ2U6IDM1IH1cbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFIuZ2V0KHBlcnNvbiwgXCJuYW1lXCIpLCBPcHRpb24uc29tZShcIkpvaG4gRG9lXCIpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChSLmdldChwZXJzb24sIFwiZW1haWxcIiksIE9wdGlvbi5ub25lKCkpXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBrZXkpID0+IGhhcyhzZWxmLCBrZXkpID8gT3B0aW9uLnNvbWUoc2VsZltrZXldKSA6IE9wdGlvbi5ub25lKCkpO1xuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQga2V5LCBjcmVhdGluZyBhIG5ldyByZWNvcmQuXG4gKiBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGUgcmVjb3JkIGlzIHJldHVybmVkIHVuY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gYmUgdXBkYXRlZC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSBmIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmVjb3JkIGFzIFIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBmID0gKHg6IG51bWJlcikgPT4geCAqIDJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogIFIubW9kaWZ5KHsgYTogMyB9LCAnYScsIGYpLFxuICogIHsgYTogNiB9XG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogIFIubW9kaWZ5KHsgYTogMyB9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj4sICdiJywgZiksXG4gKiAgeyBhOiAzIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5ID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGtleSwgZikgPT4ge1xuICBpZiAoIWhhcyhzZWxmLCBrZXkpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGZcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2VsZixcbiAgICBba2V5XTogZihzZWxmW2tleV0pXG4gIH07XG59KTtcbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiB0byB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGtleSwgY3JlYXRpbmcgYSBuZXcgcmVjb3JkLFxuICogb3IgcmV0dXJuIGBOb25lYCBpZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgcmVjb3JkIHRvIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBtb2RpZnkuXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFJlY29yZCBhcyBSLCBPcHRpb24gfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBmID0gKHg6IG51bWJlcikgPT4geCAqIDJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogIFIubW9kaWZ5T3B0aW9uKHsgYTogMyB9LCAnYScsIGYpLFxuICogIE9wdGlvbi5zb21lKHsgYTogNiB9KVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICBSLm1vZGlmeU9wdGlvbih7IGE6IDMgfSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCAnYicsIGYpLFxuICogIE9wdGlvbi5ub25lKClcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5T3B0aW9uID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIGtleSwgZikgPT4ge1xuICBpZiAoIWhhcyhzZWxmLCBrZXkpKSB7XG4gICAgcmV0dXJuIE9wdGlvbi5ub25lKCk7XG4gIH1cbiAgcmV0dXJuIE9wdGlvbi5zb21lKHtcbiAgICAuLi5zZWxmLFxuICAgIFtrZXldOiBmKHNlbGZba2V5XSlcbiAgfSk7XG59KTtcbi8qKlxuICogUmVwbGFjZXMgYSB2YWx1ZSBpbiB0aGUgcmVjb3JkIHdpdGggdGhlIG5ldyB2YWx1ZSBwYXNzZWQgYXMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIHJlY29yZCB0byBiZSB1cGRhdGVkLlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2VhcmNoIGZvciBpbiB0aGUgcmVjb3JkLlxuICogQHBhcmFtIGIgLSBUaGUgbmV3IHZhbHVlIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIHZhbHVlIHdpdGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIFJlY29yZC5yZXBsYWNlT3B0aW9uKHsgYTogMSwgYjogMiwgYzogMyB9LCAnYScsIDEwKSxcbiAqICAgT3B0aW9uLnNvbWUoeyBhOiAxMCwgYjogMiwgYzogMyB9KVxuICogKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChSZWNvcmQucmVwbGFjZU9wdGlvbihSZWNvcmQuZW1wdHk8c3RyaW5nPigpLCAnYScsIDEwKSwgT3B0aW9uLm5vbmUoKSlcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZU9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBrZXksIGIpID0+IG1vZGlmeU9wdGlvbihzZWxmLCBrZXksICgpID0+IGIpKTtcbi8qKlxuICogSWYgdGhlIGdpdmVuIGtleSBleGlzdHMgaW4gdGhlIHJlY29yZCwgcmV0dXJucyBhIG5ldyByZWNvcmQgd2l0aCB0aGUga2V5IHJlbW92ZWQsXG4gKiBvdGhlcndpc2UgcmV0dXJucyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIHRoZSByZWNvcmQgdG8gcmVtb3ZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBrZXkgLSB0aGUga2V5IHRvIHJlbW92ZSBmcm9tIHRoZSByZWNvcmQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyByZW1vdmUgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyZW1vdmUoeyBhOiAxLCBiOiAyIH0sIFwiYVwiKSwgeyBiOiAyIH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBrZXkpID0+IHtcbiAgaWYgKCFoYXMoc2VsZiwga2V5KSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxmXG4gICAgfTtcbiAgfVxuICBjb25zdCBvdXQgPSB7XG4gICAgLi4uc2VsZlxuICB9O1xuICBkZWxldGUgb3V0W2tleV07XG4gIHJldHVybiBvdXQ7XG59KTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gYGtleWAgZnJvbSBhIHJlY29yZCBhbmQgcmV0dXJucyBhbiBgT3B0aW9uYFxuICogb2YgYSB0dXBsZSB3aXRoIHRoZSB2YWx1ZSBhbmQgdGhlIHJlY29yZCB3aXRoIHRoZSByZW1vdmVkIHByb3BlcnR5LlxuICogSWYgdGhlIGtleSBpcyBub3QgcHJlc2VudCwgcmV0dXJucyBgTy5ub25lYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBpbnB1dCByZWNvcmQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQgYXMgUiwgT3B0aW9uIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChSLnBvcCh7IGE6IDEsIGI6IDIgfSwgXCJhXCIpLCBPcHRpb24uc29tZShbMSwgeyBiOiAyIH1dKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUi5wb3AoeyBhOiAxLCBiOiAyIH0gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgXCJjXCIpLCBPcHRpb24ubm9uZSgpKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IHJlY29yZFxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBwb3AgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwga2V5KSA9PiBoYXMoc2VsZiwga2V5KSA/IE9wdGlvbi5zb21lKFtzZWxmW2tleV0sIHJlbW92ZShzZWxmLCBrZXkpXSkgOiBPcHRpb24ubm9uZSgpKTtcbi8qKlxuICogTWFwcyBhIHJlY29yZCBpbnRvIGFub3RoZXIgcmVjb3JkIGJ5IGFwcGx5aW5nIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gZWFjaCBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIHJlY29yZCB0byBiZSBtYXBwZWQuXG4gKiBAcGFyYW0gZiAtIEEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gZWFjaCBvZiB0aGUgdmFsdWVzIGluIHRoZSByZWNvcmQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBtYXAgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogY29uc3QgZiA9IChuOiBudW1iZXIpID0+IGAtJHtufWBcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hcCh7IGE6IDMsIGI6IDUgfSwgZiksIHsgYTogXCItM1wiLCBiOiBcIi01XCIgfSlcbiAqXG4gKiBjb25zdCBnID0gKG46IG51bWJlciwga2V5OiBzdHJpbmcpID0+IGAke2tleS50b1VwcGVyQ2FzZSgpfS0ke259YFxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobWFwKHsgYTogMywgYjogNSB9LCBnKSwgeyBhOiBcIkEtM1wiLCBiOiBcIkItNVwiIH0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4ge1xuICBjb25zdCBvdXQgPSB7XG4gICAgLi4uc2VsZlxuICB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKHNlbGYpKSB7XG4gICAgb3V0W2tleV0gPSBmKHNlbGZba2V5XSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4vKipcbiAqIE1hcHMgdGhlIGtleXMgb2YgYSBgUmVhZG9ubHlSZWNvcmRgIHdoaWxlIHByZXNlcnZpbmcgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFwS2V5cyB9IGZyb20gXCJlZmZlY3QvUmVjb3JkXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hcEtleXMoeyBhOiAzLCBiOiA1IH0sIChrZXkpID0+IGtleS50b1VwcGVyQ2FzZSgpKSwgeyBBOiAzLCBCOiA1IH0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBLZXlzID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMoc2VsZikpIHtcbiAgICBjb25zdCBhID0gc2VsZltrZXldO1xuICAgIG91dFtmKGtleSwgYSldID0gYTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4vKipcbiAqIE1hcHMgZW50cmllcyBvZiBhIGBSZWFkb25seVJlY29yZGAgdXNpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCBhbGxvd2luZyBtb2RpZmljYXRpb24gb2YgYm90aCBrZXlzIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IG1hcEVudHJpZXMgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChtYXBFbnRyaWVzKHsgYTogMywgYjogNSB9LCAoYSwga2V5KSA9PiBba2V5LnRvVXBwZXJDYXNlKCksIGEgKyAxXSksIHsgQTogNCwgQjogNiB9KVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IG1hcHBpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgbWFwRW50cmllcyA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKHNlbGYpKSB7XG4gICAgY29uc3QgW2ssIGJdID0gZihzZWxmW2tleV0sIGtleSk7XG4gICAgb3V0W2tdID0gYjtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4vKipcbiAqIFRyYW5zZm9ybXMgYSByZWNvcmQgaW50byBhIHJlY29yZCBieSBhcHBseWluZyB0aGUgZnVuY3Rpb24gYGZgIHRvIGVhY2gga2V5IGFuZCB2YWx1ZSBpbiB0aGUgb3JpZ2luYWwgcmVjb3JkLlxuICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYFNvbWVgLCB0aGUga2V5LXZhbHVlIHBhaXIgaXMgaW5jbHVkZWQgaW4gdGhlIG91dHB1dCByZWNvcmQuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgaW5wdXQgcmVjb3JkLlxuICogQHBhcmFtIGYgLSBUaGUgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHggPSB7IGE6IDEsIGI6IDIsIGM6IDMgfVxuICogY29uc3QgZiA9IChhOiBudW1iZXIsIGtleTogc3RyaW5nKSA9PiBhID4gMiA/IE9wdGlvbi5zb21lKGEgKiAyKSA6IE9wdGlvbi5ub25lKClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUmVjb3JkLmZpbHRlck1hcCh4LCBmKSwgeyBjOiA2IH0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlck1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiB7XG4gIGNvbnN0IG91dCA9IGVtcHR5KCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMoc2VsZikpIHtcbiAgICBjb25zdCBvID0gZihzZWxmW2tleV0sIGtleSk7XG4gICAgaWYgKE9wdGlvbi5pc1NvbWUobykpIHtcbiAgICAgIG91dFtrZXldID0gby52YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBTZWxlY3RzIHByb3BlcnRpZXMgZnJvbSBhIHJlY29yZCB3aG9zZSB2YWx1ZXMgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gZmlsdGVyLlxuICogQHBhcmFtIHByZWRpY2F0ZSAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYGJvb2xlYW5gIHZhbHVlIHRvIGRldGVybWluZSBpZiB0aGUgZW50cnkgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcmVjb3JkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSBcImVmZmVjdC9SZWNvcmRcIlxuICpcbiAqIGNvbnN0IHggPSB7IGE6IDEsIGI6IDIsIGM6IDMsIGQ6IDQgfVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChmaWx0ZXIoeCwgKG4pID0+IG4gPiAyKSwgeyBjOiAzLCBkOiA0IH0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbHRlciA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3Qgb3V0ID0gZW1wdHkoKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyhzZWxmKSkge1xuICAgIGlmIChwcmVkaWNhdGUoc2VsZltrZXldLCBrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IHNlbGZba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBHaXZlbiBhIHJlY29yZCB3aXRoIGBPcHRpb25gIHZhbHVlcywgcmV0dXJucyBhIG5ldyByZWNvcmQgY29udGFpbmluZyBvbmx5IHRoZSBgU29tZWAgdmFsdWVzLCBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBrZXlzLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSByZWNvcmQgd2l0aCBgT3B0aW9uYCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQsIE9wdGlvbiB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIFJlY29yZC5nZXRTb21lcyh7IGE6IE9wdGlvbi5zb21lKDEpLCBiOiBPcHRpb24ubm9uZSgpLCBjOiBPcHRpb24uc29tZSgyKSB9KSxcbiAqICAgeyBhOiAxLCBjOiAyIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0U29tZXMgPSAvKiNfX1BVUkVfXyovZmlsdGVyTWFwKGlkZW50aXR5KTtcbi8qKlxuICogR2l2ZW4gYSByZWNvcmQgd2l0aCBgRWl0aGVyYCB2YWx1ZXMsIHJldHVybnMgYSBuZXcgcmVjb3JkIGNvbnRhaW5pbmcgb25seSB0aGUgYExlZnRgIHZhbHVlcywgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwga2V5cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFJlY29yZCwgRWl0aGVyIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgUmVjb3JkLmdldExlZnRzKHsgYTogRWl0aGVyLnJpZ2h0KDEpLCBiOiBFaXRoZXIubGVmdChcImVyclwiKSwgYzogRWl0aGVyLnJpZ2h0KDIpIH0pLFxuICogICB7IGI6IFwiZXJyXCIgfVxuICogKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMZWZ0cyA9IHNlbGYgPT4ge1xuICBjb25zdCBvdXQgPSBlbXB0eSgpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKHNlbGYpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzZWxmW2tleV07XG4gICAgaWYgKEUuaXNMZWZ0KHZhbHVlKSkge1xuICAgICAgb3V0W2tleV0gPSB2YWx1ZS5sZWZ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogR2l2ZW4gYSByZWNvcmQgd2l0aCBgRWl0aGVyYCB2YWx1ZXMsIHJldHVybnMgYSBuZXcgcmVjb3JkIGNvbnRhaW5pbmcgb25seSB0aGUgYFJpZ2h0YCB2YWx1ZXMsIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIGtleXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQsIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIFJlY29yZC5nZXRSaWdodHMoeyBhOiBFaXRoZXIucmlnaHQoMSksIGI6IEVpdGhlci5sZWZ0KFwiZXJyXCIpLCBjOiBFaXRoZXIucmlnaHQoMikgfSksXG4gKiAgIHsgYTogMSwgYzogMiB9XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJpZ2h0cyA9IHNlbGYgPT4ge1xuICBjb25zdCBvdXQgPSBlbXB0eSgpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKHNlbGYpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzZWxmW2tleV07XG4gICAgaWYgKEUuaXNSaWdodCh2YWx1ZSkpIHtcbiAgICAgIG91dFtrZXldID0gdmFsdWUucmlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBQYXJ0aXRpb25zIHRoZSBlbGVtZW50cyBvZiBhIHJlY29yZCBpbnRvIHR3byBncm91cHM6IHRob3NlIHRoYXQgbWF0Y2ggYSBwcmVkaWNhdGUsIGFuZCB0aG9zZSB0aGF0IGRvbid0LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIHJlY29yZCB0byBwYXJ0aXRpb24uXG4gKiBAcGFyYW0gZiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmVjb3JkLCBFaXRoZXIgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCB4ID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbiAqIGNvbnN0IGYgPSAobjogbnVtYmVyKSA9PiAobiAlIDIgPT09IDAgPyBFaXRoZXIucmlnaHQobikgOiBFaXRoZXIubGVmdChuKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUmVjb3JkLnBhcnRpdGlvbk1hcCh4LCBmKSwgW3sgYTogMSwgYzogMyB9LCB7IGI6IDJ9XSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcGFydGl0aW9uTWFwID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIGYpID0+IHtcbiAgY29uc3QgbGVmdCA9IGVtcHR5KCk7XG4gIGNvbnN0IHJpZ2h0ID0gZW1wdHkoKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyhzZWxmKSkge1xuICAgIGNvbnN0IGUgPSBmKHNlbGZba2V5XSwga2V5KTtcbiAgICBpZiAoRS5pc0xlZnQoZSkpIHtcbiAgICAgIGxlZnRba2V5XSA9IGUubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHRba2V5XSA9IGUucmlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufSk7XG4vKipcbiAqIFBhcnRpdGlvbnMgYSByZWNvcmQgb2YgYEVpdGhlcmAgdmFsdWVzIGludG8gdHdvIHNlcGFyYXRlIHJlY29yZHMsXG4gKiBvbmUgd2l0aCB0aGUgYExlZnRgIHZhbHVlcyBhbmQgb25lIHdpdGggdGhlIGBSaWdodGAgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gdGhlIHJlY29yZCB0byBwYXJ0aXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWNvcmQsIEVpdGhlciB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIFJlY29yZC5zZXBhcmF0ZSh7IGE6IEVpdGhlci5sZWZ0KFwiZVwiKSwgYjogRWl0aGVyLnJpZ2h0KDEpIH0pLFxuICogICBbeyBhOiBcImVcIiB9LCB7IGI6IDEgfV1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc2VwYXJhdGUgPSAvKiNfX1BVUkVfXyovcGFydGl0aW9uTWFwKGlkZW50aXR5KTtcbi8qKlxuICogUGFydGl0aW9ucyBhIHJlY29yZCBpbnRvIHR3byBzZXBhcmF0ZSByZWNvcmRzIGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgaW5wdXQgcmVjb3JkIHRvIHBhcnRpdGlvbi5cbiAqIEBwYXJhbSBwcmVkaWNhdGUgLSBUaGUgcGFydGl0aW9uaW5nIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgcGFydGl0aW9uaW5nIG9mIGVhY2ggdmFsdWUgb2YgdGhlIHJlY29yZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHBhcnRpdGlvbiB9IGZyb20gXCJlZmZlY3QvUmVjb3JkXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwYXJ0aXRpb24oeyBhOiAxLCBiOiAzIH0sIChuKSA9PiBuID4gMiksXG4gKiAgIFt7IGE6IDEgfSwgeyBiOiAzIH1dXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnRpdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgbGVmdCA9IGVtcHR5KCk7XG4gIGNvbnN0IHJpZ2h0ID0gZW1wdHkoKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyhzZWxmKSkge1xuICAgIGlmIChwcmVkaWNhdGUoc2VsZltrZXldLCBrZXkpKSB7XG4gICAgICByaWdodFtrZXldID0gc2VsZltrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0W2tleV0gPSBzZWxmW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufSk7XG4vKipcbiAqIFJldHJpZXZlIHRoZSBrZXlzIG9mIGEgZ2l2ZW4gcmVjb3JkIGFzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIG9iamVjdCBmb3Igd2hpY2ggeW91IHdhbnQgdG8gZ2V0IHRoZSBrZXlzLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qga2V5cyA9IHNlbGYgPT4gT2JqZWN0LmtleXMoc2VsZik7XG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYSBnaXZlbiByZWNvcmQgYXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgb2JqZWN0IGZvciB3aGljaCB5b3Ugd2FudCB0byBnZXQgdGhlIHZhbHVlcy5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbHVlcyA9IHNlbGYgPT4gY29sbGVjdChzZWxmLCAoXywgYSkgPT4gYSk7XG4vKipcbiAqIEFkZCBhIG5ldyBrZXktdmFsdWUgcGFpciBvciB1cGRhdGUgYW4gZXhpc3Rpbmcga2V5J3MgdmFsdWUgaW4gYSByZWNvcmQuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgcmVjb3JkIHRvIHdoaWNoIHlvdSB3YW50IHRvIGFkZCBvciB1cGRhdGUgYSBrZXktdmFsdWUgcGFpci5cbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHlvdSB3YW50IHRvIGFkZCBvciB1cGRhdGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlIHlvdSB3YW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXQgfSBmcm9tIFwiZWZmZWN0L1JlY29yZFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChzZXQoXCJhXCIsIDUpKHsgYTogMSwgYjogMiB9KSwgeyBhOiA1LCBiOiAyIH0pO1xuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChzZXQoXCJjXCIsIDUpKHsgYTogMSwgYjogMiB9KSwgeyBhOiAxLCBiOiAyLCBjOiA1IH0pO1xuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwga2V5LCB2YWx1ZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnNlbGYsXG4gICAgW2tleV06IHZhbHVlXG4gIH07XG59KTtcbi8qKlxuICogUmVwbGFjZSBhIGtleSdzIHZhbHVlIGluIGEgcmVjb3JkIGFuZCByZXR1cm4gdGhlIHVwZGF0ZWQgcmVjb3JkLlxuICogSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcmVjb3JkLCBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIHJlY29yZCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBvcmlnaW5hbCByZWNvcmQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byByZXBsYWNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBhc3NvY2lhdGUgd2l0aCB0aGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmVjb3JkIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChSZWNvcmQucmVwbGFjZShcImFcIiwgMykoeyBhOiAxLCBiOiAyIH0pLCB7IGE6IDMsIGI6IDIgfSk7XG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFJlY29yZC5yZXBsYWNlKFwiY1wiLCAzKSh7IGE6IDEsIGI6IDIgfSksIHsgYTogMSwgYjogMiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZSA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCBrZXksIHZhbHVlKSA9PiB7XG4gIGlmIChoYXMoc2VsZiwga2V5KSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxmLFxuICAgICAgW2tleV06IHZhbHVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlbGZcbiAgfTtcbn0pO1xuLyoqXG4gKiBDaGVjayBpZiBhbGwgdGhlIGtleXMgYW5kIHZhbHVlcyBpbiBvbmUgcmVjb3JkIGFyZSBhbHNvIGZvdW5kIGluIGFub3RoZXIgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGZpcnN0IHJlY29yZCB0byBjaGVjay5cbiAqIEBwYXJhbSB0aGF0IC0gVGhlIHNlY29uZCByZWNvcmQgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVxdWl2YWxlbmNlIC0gQSBmdW5jdGlvbiB0byBjb21wYXJlIHZhbHVlcy5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzU3VicmVjb3JkQnkgPSBlcXVpdmFsZW5jZSA9PiBkdWFsKDIsIChzZWxmLCB0aGF0KSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMoc2VsZikpIHtcbiAgICBpZiAoIWhhcyh0aGF0LCBrZXkpIHx8ICFlcXVpdmFsZW5jZShzZWxmW2tleV0sIHRoYXRba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2sgaWYgb25lIHJlY29yZCBpcyBhIHN1YnJlY29yZCBvZiBhbm90aGVyLCBtZWFuaW5nIGl0IGNvbnRhaW5zIGFsbCB0aGUga2V5cyBhbmQgdmFsdWVzIGZvdW5kIGluIHRoZSBzZWNvbmQgcmVjb3JkLlxuICogVGhpcyBjb21wYXJpc29uIHVzZXMgZGVmYXVsdCBlcXVhbGl0eSBjaGVja3MgKGBFcXVhbC5lcXVpdmFsZW5jZSgpYCkuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgcmVjb3JkIHRvIGNoZWNrLlxuICogQHBhcmFtIHRoYXQgLSBUaGUgc2Vjb25kIHJlY29yZCB0byBjb21wYXJlIGFnYWluc3QuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBpc1N1YnJlY29yZCA9IC8qI19fUFVSRV9fKi9pc1N1YnJlY29yZEJ5KCAvKiNfX1BVUkVfXyovRXF1YWwuZXF1aXZhbGVuY2UoKSk7XG4vKipcbiAqIFJlZHVjZSBhIHJlY29yZCB0byBhIHNpbmdsZSB2YWx1ZSBieSBjb21iaW5pbmcgaXRzIGVudHJpZXMgd2l0aCBhIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gcmVkdWNlLlxuICogQHBhcmFtIHplcm8gLSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVudHJpZXMgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5KS5cbiAqXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCByZWR1Y2UgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgemVybywgZikgPT4ge1xuICBsZXQgb3V0ID0gemVybztcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyhzZWxmKSkge1xuICAgIG91dCA9IGYob3V0LCBzZWxmW2tleV0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBDaGVjayBpZiBhbGwgZW50cmllcyBpbiBhIHJlY29yZCBtZWV0IGEgc3BlY2lmaWMgY29uZGl0aW9uLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIHJlY29yZCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcmVkaWNhdGUgLSBUaGUgY29uZGl0aW9uIHRvIHRlc3QgZW50cmllcyAodmFsdWUsIGtleSkuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBldmVyeSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCByZWZpbmVtZW50KSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMoc2VsZikpIHtcbiAgICBpZiAoIXJlZmluZW1lbnQoc2VsZltrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrIGlmIGFueSBlbnRyeSBpbiBhIHJlY29yZCBtZWV0cyBhIHNwZWNpZmljIGNvbmRpdGlvbi5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSByZWNvcmQgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJlZGljYXRlIC0gVGhlIGNvbmRpdGlvbiB0byB0ZXN0IGVudHJpZXMgKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3Qgc29tZSA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBwcmVkaWNhdGUpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyhzZWxmKSkge1xuICAgIGlmIChwcmVkaWNhdGUoc2VsZltrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG4vKipcbiAqIE1lcmdlIHR3byByZWNvcmRzLCBwcmVzZXJ2aW5nIGVudHJpZXMgdGhhdCBleGlzdCBpbiBlaXRoZXIgb2YgdGhlIHJlY29yZHMuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgcmVjb3JkLlxuICogQHBhcmFtIHRoYXQgLSBUaGUgc2Vjb25kIHJlY29yZCB0byBjb21iaW5lIHdpdGggdGhlIGZpcnN0LlxuICogQHBhcmFtIGNvbWJpbmUgLSBBIGZ1bmN0aW9uIHRvIHNwZWNpZnkgaG93IHRvIG1lcmdlIGVudHJpZXMgd2l0aCB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCB1bmlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDMsIChzZWxmLCB0aGF0LCBjb21iaW5lKSA9PiB7XG4gIGlmIChpc0VtcHR5UmVjb3JkKHNlbGYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoYXRcbiAgICB9O1xuICB9XG4gIGlmIChpc0VtcHR5UmVjb3JkKHRoYXQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGZcbiAgICB9O1xuICB9XG4gIGNvbnN0IG91dCA9IGVtcHR5KCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMoc2VsZikpIHtcbiAgICBpZiAoaGFzKHRoYXQsIGtleSkpIHtcbiAgICAgIG91dFtrZXldID0gY29tYmluZShzZWxmW2tleV0sIHRoYXRba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtrZXldID0gc2VsZltrZXldO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKHRoYXQpKSB7XG4gICAgaWYgKCFoYXMob3V0LCBrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IHRoYXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBNZXJnZSB0d28gcmVjb3JkcywgcmV0YWluaW5nIG9ubHkgdGhlIGVudHJpZXMgdGhhdCBleGlzdCBpbiBib3RoIHJlY29yZHMuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgZmlyc3QgcmVjb3JkLlxuICogQHBhcmFtIHRoYXQgLSBUaGUgc2Vjb25kIHJlY29yZCB0byBtZXJnZSB3aXRoIHRoZSBmaXJzdC5cbiAqIEBwYXJhbSBjb21iaW5lIC0gQSBmdW5jdGlvbiB0byBzcGVjaWZ5IGhvdyB0byBtZXJnZSBlbnRyaWVzIHdpdGggdGhlIHNhbWUga2V5LlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgaW50ZXJzZWN0aW9uID0gLyojX19QVVJFX18qL2R1YWwoMywgKHNlbGYsIHRoYXQsIGNvbWJpbmUpID0+IHtcbiAgY29uc3Qgb3V0ID0gZW1wdHkoKTtcbiAgaWYgKGlzRW1wdHlSZWNvcmQoc2VsZikgfHwgaXNFbXB0eVJlY29yZCh0aGF0KSkge1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyhzZWxmKSkge1xuICAgIGlmIChoYXModGhhdCwga2V5KSkge1xuICAgICAgb3V0W2tleV0gPSBjb21iaW5lKHNlbGZba2V5XSwgdGhhdFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuLyoqXG4gKiBNZXJnZSB0d28gcmVjb3JkcywgcHJlc2VydmluZyBvbmx5IHRoZSBlbnRyaWVzIHRoYXQgYXJlIHVuaXF1ZSB0byBlYWNoIHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBmaXJzdCByZWNvcmQuXG4gKiBAcGFyYW0gdGhhdCAtIFRoZSBzZWNvbmQgcmVjb3JkIHRvIGNvbXBhcmUgd2l0aCB0aGUgZmlyc3QuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBkaWZmZXJlbmNlID0gLyojX19QVVJFX18qL2R1YWwoMiwgKHNlbGYsIHRoYXQpID0+IHtcbiAgaWYgKGlzRW1wdHlSZWNvcmQoc2VsZikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhhdFxuICAgIH07XG4gIH1cbiAgaWYgKGlzRW1wdHlSZWNvcmQodGhhdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2VsZlxuICAgIH07XG4gIH1cbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMoc2VsZikpIHtcbiAgICBpZiAoIWhhcyh0aGF0LCBrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IHNlbGZba2V5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyh0aGF0KSkge1xuICAgIGlmICghaGFzKHNlbGYsIGtleSkpIHtcbiAgICAgIG91dFtrZXldID0gdGhhdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG4vKipcbiAqIENyZWF0ZSBhbiBgRXF1aXZhbGVuY2VgIGZvciByZWNvcmRzIHVzaW5nIHRoZSBwcm92aWRlZCBgRXF1aXZhbGVuY2VgIGZvciB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIGVxdWl2YWxlbmNlIC0gQW4gYEVxdWl2YWxlbmNlYCBmb3IgdGhlIHZhbHVlcyBjb250YWluZWQgaW4gdGhlIHJlY29yZHMuXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFcXVpdmFsZW5jZSA9IGVxdWl2YWxlbmNlID0+IHtcbiAgY29uc3QgaXMgPSBpc1N1YnJlY29yZEJ5KGVxdWl2YWxlbmNlKTtcbiAgcmV0dXJuIChzZWxmLCB0aGF0KSA9PiBpcyhzZWxmLCB0aGF0KSAmJiBpcyh0aGF0LCBzZWxmKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIG5vbi1lbXB0eSByZWNvcmQgZnJvbSBhIHNpbmdsZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IGZvciB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHNpbmdsZXRvbiA9IChrZXksIHZhbHVlKSA9PiAoe1xuICBba2V5XTogdmFsdWVcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVjb3JkLmpzLm1hcCJdLCJuYW1lcyI6WyJFIiwiRXF1YWwiLCJkdWFsIiwiaWRlbnRpdHkiLCJPcHRpb24iLCJlbXB0eSIsImlzRW1wdHlSZWNvcmQiLCJzZWxmIiwia2V5cyIsImxlbmd0aCIsImlzRW1wdHlSZWFkb25seVJlY29yZCIsImZyb21JdGVyYWJsZVdpdGgiLCJmIiwib3V0IiwiYSIsImsiLCJiIiwiZnJvbUl0ZXJhYmxlQnkiLCJpdGVtcyIsImZyb21FbnRyaWVzIiwiT2JqZWN0IiwiY29sbGVjdCIsImtleSIsInB1c2giLCJ0b0VudHJpZXMiLCJ2YWx1ZSIsInNpemUiLCJoYXMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJnZXQiLCJzb21lIiwibm9uZSIsIm1vZGlmeSIsIm1vZGlmeU9wdGlvbiIsInJlcGxhY2VPcHRpb24iLCJyZW1vdmUiLCJwb3AiLCJtYXAiLCJtYXBLZXlzIiwibWFwRW50cmllcyIsImZpbHRlck1hcCIsIm8iLCJpc1NvbWUiLCJmaWx0ZXIiLCJwcmVkaWNhdGUiLCJnZXRTb21lcyIsImdldExlZnRzIiwiaXNMZWZ0IiwibGVmdCIsImdldFJpZ2h0cyIsImlzUmlnaHQiLCJyaWdodCIsInBhcnRpdGlvbk1hcCIsImUiLCJzZXBhcmF0ZSIsInBhcnRpdGlvbiIsInZhbHVlcyIsIl8iLCJzZXQiLCJyZXBsYWNlIiwiaXNTdWJyZWNvcmRCeSIsImVxdWl2YWxlbmNlIiwidGhhdCIsImlzU3VicmVjb3JkIiwicmVkdWNlIiwiemVybyIsImV2ZXJ5IiwicmVmaW5lbWVudCIsInVuaW9uIiwiY29tYmluZSIsImludGVyc2VjdGlvbiIsImRpZmZlcmVuY2UiLCJnZXRFcXVpdmFsZW5jZSIsImlzIiwic2luZ2xldG9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Record.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Redacted.js":
/*!**************************************************!*\
  !*** ./node_modules/effect/dist/esm/Redacted.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedactedTypeId: () => (/* binding */ RedactedTypeId),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   isRedacted: () => (/* binding */ isRedacted),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   unsafeWipe: () => (/* binding */ unsafeWipe),\n/* harmony export */   value: () => (/* binding */ value)\n/* harmony export */ });\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _internal_redacted_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/redacted.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/redacted.js\");\n\n\n/**\n * @since 3.3.0\n * @category symbols\n */ const RedactedTypeId = _internal_redacted_js__WEBPACK_IMPORTED_MODULE_0__.RedactedTypeId;\n/**\n * @since 3.3.0\n * @category refinements\n */ const isRedacted = _internal_redacted_js__WEBPACK_IMPORTED_MODULE_0__.isRedacted;\n/**\n * This function creates a `Redacted<A>` instance from a given value `A`,\n * securely hiding its content.\n *\n * @example\n * ```ts\n * import { Redacted } from \"effect\"\n *\n * const API_KEY = Redacted.make(\"1234567890\")\n * ```\n *\n * @since 3.3.0\n * @category constructors\n */ const make = _internal_redacted_js__WEBPACK_IMPORTED_MODULE_0__.make;\n/**\n * Retrieves the original value from a `Redacted` instance. Use this function\n * with caution, as it exposes the sensitive data.\n *\n * @example\n * ```ts\n * import { Redacted } from \"effect\"\n *\n * const API_KEY = Redacted.make(\"1234567890\")\n *\n * assert.equal(Redacted.value(API_KEY), \"1234567890\")\n * ```\n *\n * @since 3.3.0\n * @category getters\n */ const value = _internal_redacted_js__WEBPACK_IMPORTED_MODULE_0__.value;\n/**\n * Erases the underlying value of a `Redacted` instance, rendering it unusable.\n * This function is intended to ensure that sensitive data does not remain in\n * memory longer than necessary.\n *\n * @example\n * ```ts\n * import { Redacted } from \"effect\"\n *\n * const API_KEY = Redacted.make(\"1234567890\")\n *\n * assert.equal(Redacted.value(API_KEY), \"1234567890\")\n *\n * Redacted.unsafeWipe(API_KEY)\n *\n * assert.throws(() => Redacted.value(API_KEY), new Error(\"Unable to get redacted value\"))\n * ```\n *\n * @since 3.3.0\n * @category unsafe\n */ const unsafeWipe = _internal_redacted_js__WEBPACK_IMPORTED_MODULE_0__.unsafeWipe;\n/**\n * Generates an equivalence relation for `Redacted<A>` values based on an\n * equivalence relation for the underlying values `A`. This function is useful\n * for comparing `Redacted` instances without exposing their contents.\n *\n * @example\n * ```ts\n * import { Redacted, Equivalence } from \"effect\"\n *\n * const API_KEY1 = Redacted.make(\"1234567890\")\n * const API_KEY2 = Redacted.make(\"1-34567890\")\n * const API_KEY3 = Redacted.make(\"1234567890\")\n *\n * const equivalence = Redacted.getEquivalence(Equivalence.string)\n *\n * assert.equal(equivalence(API_KEY1, API_KEY2), false)\n * assert.equal(equivalence(API_KEY1, API_KEY3), true)\n * ```\n *\n * @category equivalence\n * @since 3.3.0\n */ const getEquivalence = (isEquivalent)=>_Equivalence_js__WEBPACK_IMPORTED_MODULE_1__.make((x, y)=>isEquivalent(value(x), value(y))); //# sourceMappingURL=Redacted.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1JlZGFjdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0k7QUFDcEQ7OztDQUdDLEdBQ00sTUFBTUUsaUJBQWlCRCxpRUFBd0IsQ0FBQztBQUN2RDs7O0NBR0MsR0FDTSxNQUFNRSxhQUFhRiw2REFBb0IsQ0FBQztBQUMvQzs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUcsT0FBT0gsdURBQWMsQ0FBQztBQUNuQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNSSxRQUFRSix3REFBZSxDQUFDO0FBQ3JDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLE1BQU1LLGFBQWFMLDZEQUFvQixDQUFDO0FBQy9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDTSxNQUFNTSxpQkFBaUJDLENBQUFBLGVBQWdCUixpREFBZ0IsQ0FBQyxDQUFDUyxHQUFHQyxJQUFNRixhQUFhSCxNQUFNSSxJQUFJSixNQUFNSyxLQUFLLENBQzNHLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vUmVkYWN0ZWQuanM/MTFjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcXVpdmFsZW5jZSBmcm9tIFwiLi9FcXVpdmFsZW5jZS5qc1wiO1xuaW1wb3J0ICogYXMgcmVkYWN0ZWRfIGZyb20gXCIuL2ludGVybmFsL3JlZGFjdGVkLmpzXCI7XG4vKipcbiAqIEBzaW5jZSAzLjMuMFxuICogQGNhdGVnb3J5IHN5bWJvbHNcbiAqL1xuZXhwb3J0IGNvbnN0IFJlZGFjdGVkVHlwZUlkID0gcmVkYWN0ZWRfLlJlZGFjdGVkVHlwZUlkO1xuLyoqXG4gKiBAc2luY2UgMy4zLjBcbiAqIEBjYXRlZ29yeSByZWZpbmVtZW50c1xuICovXG5leHBvcnQgY29uc3QgaXNSZWRhY3RlZCA9IHJlZGFjdGVkXy5pc1JlZGFjdGVkO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBgUmVkYWN0ZWQ8QT5gIGluc3RhbmNlIGZyb20gYSBnaXZlbiB2YWx1ZSBgQWAsXG4gKiBzZWN1cmVseSBoaWRpbmcgaXRzIGNvbnRlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSZWRhY3RlZCB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IEFQSV9LRVkgPSBSZWRhY3RlZC5tYWtlKFwiMTIzNDU2Nzg5MFwiKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuMy4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gcmVkYWN0ZWRfLm1ha2U7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgb3JpZ2luYWwgdmFsdWUgZnJvbSBhIGBSZWRhY3RlZGAgaW5zdGFuY2UuIFVzZSB0aGlzIGZ1bmN0aW9uXG4gKiB3aXRoIGNhdXRpb24sIGFzIGl0IGV4cG9zZXMgdGhlIHNlbnNpdGl2ZSBkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmVkYWN0ZWQgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBBUElfS0VZID0gUmVkYWN0ZWQubWFrZShcIjEyMzQ1Njc4OTBcIilcbiAqXG4gKiBhc3NlcnQuZXF1YWwoUmVkYWN0ZWQudmFsdWUoQVBJX0tFWSksIFwiMTIzNDU2Nzg5MFwiKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuMy4wXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICovXG5leHBvcnQgY29uc3QgdmFsdWUgPSByZWRhY3RlZF8udmFsdWU7XG4vKipcbiAqIEVyYXNlcyB0aGUgdW5kZXJseWluZyB2YWx1ZSBvZiBhIGBSZWRhY3RlZGAgaW5zdGFuY2UsIHJlbmRlcmluZyBpdCB1bnVzYWJsZS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gZW5zdXJlIHRoYXQgc2Vuc2l0aXZlIGRhdGEgZG9lcyBub3QgcmVtYWluIGluXG4gKiBtZW1vcnkgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmVkYWN0ZWQgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBjb25zdCBBUElfS0VZID0gUmVkYWN0ZWQubWFrZShcIjEyMzQ1Njc4OTBcIilcbiAqXG4gKiBhc3NlcnQuZXF1YWwoUmVkYWN0ZWQudmFsdWUoQVBJX0tFWSksIFwiMTIzNDU2Nzg5MFwiKVxuICpcbiAqIFJlZGFjdGVkLnVuc2FmZVdpcGUoQVBJX0tFWSlcbiAqXG4gKiBhc3NlcnQudGhyb3dzKCgpID0+IFJlZGFjdGVkLnZhbHVlKEFQSV9LRVkpLCBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IHJlZGFjdGVkIHZhbHVlXCIpKVxuICogYGBgXG4gKlxuICogQHNpbmNlIDMuMy4wXG4gKiBAY2F0ZWdvcnkgdW5zYWZlXG4gKi9cbmV4cG9ydCBjb25zdCB1bnNhZmVXaXBlID0gcmVkYWN0ZWRfLnVuc2FmZVdpcGU7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBlcXVpdmFsZW5jZSByZWxhdGlvbiBmb3IgYFJlZGFjdGVkPEE+YCB2YWx1ZXMgYmFzZWQgb24gYW5cbiAqIGVxdWl2YWxlbmNlIHJlbGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyB2YWx1ZXMgYEFgLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bFxuICogZm9yIGNvbXBhcmluZyBgUmVkYWN0ZWRgIGluc3RhbmNlcyB3aXRob3V0IGV4cG9zaW5nIHRoZWlyIGNvbnRlbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmVkYWN0ZWQsIEVxdWl2YWxlbmNlIH0gZnJvbSBcImVmZmVjdFwiXG4gKlxuICogY29uc3QgQVBJX0tFWTEgPSBSZWRhY3RlZC5tYWtlKFwiMTIzNDU2Nzg5MFwiKVxuICogY29uc3QgQVBJX0tFWTIgPSBSZWRhY3RlZC5tYWtlKFwiMS0zNDU2Nzg5MFwiKVxuICogY29uc3QgQVBJX0tFWTMgPSBSZWRhY3RlZC5tYWtlKFwiMTIzNDU2Nzg5MFwiKVxuICpcbiAqIGNvbnN0IGVxdWl2YWxlbmNlID0gUmVkYWN0ZWQuZ2V0RXF1aXZhbGVuY2UoRXF1aXZhbGVuY2Uuc3RyaW5nKVxuICpcbiAqIGFzc2VydC5lcXVhbChlcXVpdmFsZW5jZShBUElfS0VZMSwgQVBJX0tFWTIpLCBmYWxzZSlcbiAqIGFzc2VydC5lcXVhbChlcXVpdmFsZW5jZShBUElfS0VZMSwgQVBJX0tFWTMpLCB0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGVxdWl2YWxlbmNlXG4gKiBAc2luY2UgMy4zLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVxdWl2YWxlbmNlID0gaXNFcXVpdmFsZW50ID0+IEVxdWl2YWxlbmNlLm1ha2UoKHgsIHkpID0+IGlzRXF1aXZhbGVudCh2YWx1ZSh4KSwgdmFsdWUoeSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZGFjdGVkLmpzLm1hcCJdLCJuYW1lcyI6WyJFcXVpdmFsZW5jZSIsInJlZGFjdGVkXyIsIlJlZGFjdGVkVHlwZUlkIiwiaXNSZWRhY3RlZCIsIm1ha2UiLCJ2YWx1ZSIsInVuc2FmZVdpcGUiLCJnZXRFcXVpdmFsZW5jZSIsImlzRXF1aXZhbGVudCIsIngiLCJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Redacted.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Tuple.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Tuple.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendElement: () => (/* binding */ appendElement),\n/* harmony export */   at: () => (/* binding */ at),\n/* harmony export */   getEquivalence: () => (/* binding */ getEquivalence),\n/* harmony export */   getFirst: () => (/* binding */ getFirst),\n/* harmony export */   getOrder: () => (/* binding */ getOrder),\n/* harmony export */   getSecond: () => (/* binding */ getSecond),\n/* harmony export */   isTupleOf: () => (/* reexport safe */ _Predicate_js__WEBPACK_IMPORTED_MODULE_3__.isTupleOf),\n/* harmony export */   isTupleOfAtLeast: () => (/* reexport safe */ _Predicate_js__WEBPACK_IMPORTED_MODULE_3__.isTupleOfAtLeast),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapBoth: () => (/* binding */ mapBoth),\n/* harmony export */   mapFirst: () => (/* binding */ mapFirst),\n/* harmony export */   mapSecond: () => (/* binding */ mapSecond),\n/* harmony export */   swap: () => (/* binding */ swap)\n/* harmony export */ });\n/* harmony import */ var _Equivalence_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Equivalence.js */ \"(ssr)/./node_modules/effect/dist/esm/Equivalence.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _Order_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Order.js */ \"(ssr)/./node_modules/effect/dist/esm/Order.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/**\n * This module provides utility functions for working with tuples in TypeScript.\n *\n * @since 2.0.0\n */ \n\n\n/**\n * Constructs a new tuple from the provided values.\n *\n * @param elements - The list of elements to create the tuple from.\n *\n * @example\n * ```ts\n * import { make } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */ const make = (...elements)=>elements;\n/**\n * Return the first element of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * ```ts\n * import { getFirst } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getFirst = (self)=>self[0];\n/**\n * Return the second element of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * ```ts\n * import { getSecond } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(getSecond([\"hello\", 42]), 42)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */ const getSecond = (self)=>self[1];\n/**\n * Transforms each element of tuple using the given function, treating tuple homomorphically\n *\n * @param self - A tuple.\n * @param f - The function to transform elements of the tuple.\n *\n * @example\n * ```ts\n * import { pipe, Tuple } from \"effect\"\n *\n * const result = pipe(\n *   [\"a\", 1, false] as const,\n *   Tuple.map((el) => el.toString().toUpperCase())\n * )\n * assert.deepStrictEqual(result, ['A', '1', 'FALSE'])\n * ```\n *\n * @category mapping\n * @since 3.9.0\n */ const map = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, fn)=>self.map((element)=>fn(element)));\n/**\n * Transforms both elements of a tuple using the given functions.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the first element of the tuple.\n * @param g - The function to transform the second element of the tuple.\n *\n * @example\n * ```ts\n * import { mapBoth } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapBoth([\"hello\", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),\n *   [\"HELLO\", \"42\"]\n * )\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */ const mapBoth = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, { onFirst, onSecond })=>[\n        onFirst(self[0]),\n        onSecond(self[1])\n    ]);\n/**\n * Transforms the first component of a tuple using a given function.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the first element of the tuple.\n *\n * @example\n * ```ts\n * import { mapFirst } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapFirst([\"hello\", 42], s => s.toUpperCase()),\n *   [\"HELLO\", 42]\n * )\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */ const mapFirst = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>[\n        f(self[0]),\n        self[1]\n    ]);\n/**\n * Transforms the second component of a tuple using a given function.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the second element of the tuple.\n *\n * @example\n * ```ts\n * import { mapSecond } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapSecond([\"hello\", 42], n => n.toString()),\n *   [\"hello\", \"42\"]\n * )\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */ const mapSecond = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, f)=>[\n        self[0],\n        f(self[1])\n    ]);\n/**\n * Swaps the two elements of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * ```ts\n * import { swap } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])\n * ```\n *\n * @since 2.0.0\n */ const swap = (self)=>[\n        self[1],\n        self[0]\n    ];\n/**\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */ const getEquivalence = _Equivalence_js__WEBPACK_IMPORTED_MODULE_1__.tuple;\n/**\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */ const getOrder = _Order_js__WEBPACK_IMPORTED_MODULE_2__.tuple;\n/**\n * Appends an element to the end of a tuple.\n *\n * @category concatenating\n * @since 2.0.0\n */ const appendElement = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, that)=>[\n        ...self,\n        that\n    ]);\n/**\n * Retrieves the element at a specified index from a tuple.\n *\n * @param self - A tuple from which to retrieve the element.\n * @param index - The index of the element to retrieve.\n *\n * @example\n * ```ts\n * import { Tuple } from \"effect\"\n *\n * assert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')\n * ```\n *\n * @category getters\n * @since 3.4.0\n */ const at = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, index)=>self[index]);\n //# sourceMappingURL=Tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1R1cGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDK0M7QUFDWDtBQUNEO0FBQ3BDOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTUcsT0FBTyxDQUFDLEdBQUdDLFdBQWFBLFNBQVM7QUFDOUM7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxNQUFNQyxXQUFXQyxDQUFBQSxPQUFRQSxJQUFJLENBQUMsRUFBRSxDQUFDO0FBQ3hDOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTUMsWUFBWUQsQ0FBQUEsT0FBUUEsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUN6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLE1BQU1FLE1BQU0sV0FBVyxHQUFFUCxrREFBSUEsQ0FBQyxHQUFHLENBQUNLLE1BQU1HLEtBQU9ILEtBQUtFLEdBQUcsQ0FBQ0UsQ0FBQUEsVUFBV0QsR0FBR0MsV0FBVztBQUN4Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLE1BQU1DLFVBQVUsV0FBVyxHQUFFVixrREFBSUEsQ0FBQyxHQUFHLENBQUNLLE1BQU0sRUFDakRNLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUs7UUFBQ0QsUUFBUU4sSUFBSSxDQUFDLEVBQUU7UUFBR08sU0FBU1AsSUFBSSxDQUFDLEVBQUU7S0FBRSxFQUFFO0FBQzdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxNQUFNUSxXQUFXLFdBQVcsR0FBRWIsa0RBQUlBLENBQUMsR0FBRyxDQUFDSyxNQUFNUyxJQUFNO1FBQUNBLEVBQUVULElBQUksQ0FBQyxFQUFFO1FBQUdBLElBQUksQ0FBQyxFQUFFO0tBQUMsRUFBRTtBQUNqRjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sTUFBTVUsWUFBWSxXQUFXLEdBQUVmLGtEQUFJQSxDQUFDLEdBQUcsQ0FBQ0ssTUFBTVMsSUFBTTtRQUFDVCxJQUFJLENBQUMsRUFBRTtRQUFFUyxFQUFFVCxJQUFJLENBQUMsRUFBRTtLQUFFLEVBQUU7QUFDbEY7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1XLE9BQU9YLENBQUFBLE9BQVE7UUFBQ0EsSUFBSSxDQUFDLEVBQUU7UUFBRUEsSUFBSSxDQUFDLEVBQUU7S0FBQyxDQUFDO0FBQy9DOzs7Ozs7Q0FNQyxHQUNNLE1BQU1ZLGlCQUFpQmxCLGtEQUFpQixDQUFDO0FBQ2hEOzs7Ozs7OztDQVFDLEdBQ00sTUFBTW9CLFdBQVdsQiw0Q0FBVyxDQUFDO0FBQ3BDOzs7OztDQUtDLEdBQ00sTUFBTW1CLGdCQUFnQixXQUFXLEdBQUVwQixrREFBSUEsQ0FBQyxHQUFHLENBQUNLLE1BQU1nQixPQUFTO1dBQUloQjtRQUFNZ0I7S0FBSyxFQUFFO0FBQ25GOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLE1BQU1DLEtBQUssV0FBVyxHQUFFdEIsa0RBQUlBLENBQUMsR0FBRyxDQUFDSyxNQUFNa0IsUUFBVWxCLElBQUksQ0FBQ2tCLE1BQU0sRUFBRTtBQXVENUIsQ0FDekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9UdXBsZS5qcz83YjliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCB0dXBsZXMgaW4gVHlwZVNjcmlwdC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuaW1wb3J0ICogYXMgRXF1aXZhbGVuY2UgZnJvbSBcIi4vRXF1aXZhbGVuY2UuanNcIjtcbmltcG9ydCB7IGR1YWwgfSBmcm9tIFwiLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgb3JkZXIgZnJvbSBcIi4vT3JkZXIuanNcIjtcbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB0dXBsZSBmcm9tIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gY3JlYXRlIHRoZSB0dXBsZSBmcm9tLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFrZSB9IGZyb20gXCJlZmZlY3QvVHVwbGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwobWFrZSgxLCAnaGVsbG8nLCB0cnVlKSwgWzEsICdoZWxsbycsIHRydWVdKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gKC4uLmVsZW1lbnRzKSA9PiBlbGVtZW50cztcbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50IG9mIGEgdHVwbGUuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBBIHR1cGxlIG9mIGxlbmd0aCBgMmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnZXRGaXJzdCB9IGZyb20gXCJlZmZlY3QvVHVwbGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0Rmlyc3QoW1wiaGVsbG9cIiwgNDJdKSwgXCJoZWxsb1wiKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0Rmlyc3QgPSBzZWxmID0+IHNlbGZbMF07XG4vKipcbiAqIFJldHVybiB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0dXBsZS5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIEEgdHVwbGUgb2YgbGVuZ3RoIGAyYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdldFNlY29uZCB9IGZyb20gXCJlZmZlY3QvVHVwbGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0U2Vjb25kKFtcImhlbGxvXCIsIDQyXSksIDQyKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IGdldHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgZ2V0U2Vjb25kID0gc2VsZiA9PiBzZWxmWzFdO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGVhY2ggZWxlbWVudCBvZiB0dXBsZSB1c2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb24sIHRyZWF0aW5nIHR1cGxlIGhvbW9tb3JwaGljYWxseVxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSB0dXBsZS5cbiAqIEBwYXJhbSBmIC0gVGhlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBlbGVtZW50cyBvZiB0aGUgdHVwbGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwaXBlLCBUdXBsZSB9IGZyb20gXCJlZmZlY3RcIlxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpcGUoXG4gKiAgIFtcImFcIiwgMSwgZmFsc2VdIGFzIGNvbnN0LFxuICogICBUdXBsZS5tYXAoKGVsKSA9PiBlbC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkpXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHJlc3VsdCwgWydBJywgJzEnLCAnRkFMU0UnXSlcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMy45LjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmbikgPT4gc2VsZi5tYXAoZWxlbWVudCA9PiBmbihlbGVtZW50KSkpO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGJvdGggZWxlbWVudHMgb2YgYSB0dXBsZSB1c2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSB0dXBsZSBvZiBsZW5ndGggYDJgLlxuICogQHBhcmFtIGYgLSBUaGUgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSB0dXBsZS5cbiAqIEBwYXJhbSBnIC0gVGhlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFwQm90aCB9IGZyb20gXCJlZmZlY3QvVHVwbGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoXG4gKiAgIG1hcEJvdGgoW1wiaGVsbG9cIiwgNDJdLCB7IG9uRmlyc3Q6IHMgPT4gcy50b1VwcGVyQ2FzZSgpLCBvblNlY29uZDogbiA9PiBuLnRvU3RyaW5nKCkgfSksXG4gKiAgIFtcIkhFTExPXCIsIFwiNDJcIl1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcEJvdGggPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwge1xuICBvbkZpcnN0LFxuICBvblNlY29uZFxufSkgPT4gW29uRmlyc3Qoc2VsZlswXSksIG9uU2Vjb25kKHNlbGZbMV0pXSk7XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGZpcnN0IGNvbXBvbmVudCBvZiBhIHR1cGxlIHVzaW5nIGEgZ2l2ZW4gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHNlbGYgLSBBIHR1cGxlIG9mIGxlbmd0aCBgMmAuXG4gKiBAcGFyYW0gZiAtIFRoZSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFwRmlyc3QgfSBmcm9tIFwiZWZmZWN0L1R1cGxlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBtYXBGaXJzdChbXCJoZWxsb1wiLCA0Ml0sIHMgPT4gcy50b1VwcGVyQ2FzZSgpKSxcbiAqICAgW1wiSEVMTE9cIiwgNDJdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBGaXJzdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBmKSA9PiBbZihzZWxmWzBdKSwgc2VsZlsxXV0pO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBzZWNvbmQgY29tcG9uZW50IG9mIGEgdHVwbGUgdXNpbmcgYSBnaXZlbiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIEEgdHVwbGUgb2YgbGVuZ3RoIGAyYC5cbiAqIEBwYXJhbSBmIC0gVGhlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWFwU2Vjb25kIH0gZnJvbSBcImVmZmVjdC9UdXBsZVwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgbWFwU2Vjb25kKFtcImhlbGxvXCIsIDQyXSwgbiA9PiBuLnRvU3RyaW5nKCkpLFxuICogICBbXCJoZWxsb1wiLCBcIjQyXCJdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBTZWNvbmQgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgZikgPT4gW3NlbGZbMF0sIGYoc2VsZlsxXSldKTtcbi8qKlxuICogU3dhcHMgdGhlIHR3byBlbGVtZW50cyBvZiBhIHR1cGxlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSB0dXBsZSBvZiBsZW5ndGggYDJgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc3dhcCB9IGZyb20gXCJlZmZlY3QvVHVwbGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc3dhcChbXCJoZWxsb1wiLCA0Ml0pLCBbNDIsIFwiaGVsbG9cIl0pXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IHN3YXAgPSBzZWxmID0+IFtzZWxmWzFdLCBzZWxmWzBdXTtcbi8qKlxuICogR2l2ZW4gYSB0dXBsZSBvZiBgRXF1aXZhbGVuY2VgcyByZXR1cm5zIGEgbmV3IGBFcXVpdmFsZW5jZWAgdGhhdCBjb21wYXJlcyB2YWx1ZXMgb2YgYSB0dXBsZVxuICogYnkgYXBwbHlpbmcgZWFjaCBgRXF1aXZhbGVuY2VgIHRvIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgdGhlIHR1cGxlLlxuICpcbiAqIEBjYXRlZ29yeSBjb21iaW5hdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFcXVpdmFsZW5jZSA9IEVxdWl2YWxlbmNlLnR1cGxlO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYE9yZGVyYCBmb3IgYSB0dXBsZSBvZiB2YWx1ZXMgYmFzZWQgb24gdGhlIGdpdmVuIGBPcmRlcmBzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHR1cGxlLlxuICogVGhlIHJldHVybmVkIGBPcmRlcmAgY29tcGFyZXMgdHdvIHR1cGxlcyBvZiB0aGUgc2FtZSB0eXBlIGJ5IGFwcGx5aW5nIHRoZSBjb3JyZXNwb25kaW5nIGBPcmRlcmAgdG8gZWFjaCBlbGVtZW50IGluIHRoZSB0dXBsZS5cbiAqIEl0IGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGNvbXBhcmUgdHdvIHR1cGxlcyBvZiB0aGUgc2FtZSB0eXBlIGFuZCB5b3UgaGF2ZSBhIHNwZWNpZmljIHdheSBvZiBjb21wYXJpbmcgZWFjaCBlbGVtZW50XG4gKiBvZiB0aGUgdHVwbGUuXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yZGVyID0gb3JkZXIudHVwbGU7XG4vKipcbiAqIEFwcGVuZHMgYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIGEgdHVwbGUuXG4gKlxuICogQGNhdGVnb3J5IGNvbmNhdGVuYXRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kRWxlbWVudCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0aGF0KSA9PiBbLi4uc2VsZiwgdGhhdF0pO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXggZnJvbSBhIHR1cGxlLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gQSB0dXBsZSBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHJpZXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgVHVwbGUgfSBmcm9tIFwiZWZmZWN0XCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFR1cGxlLmF0KFsxLCAnaGVsbG8nLCB0cnVlXSwgMSksICdoZWxsbycpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgZ2V0dGVyc1xuICogQHNpbmNlIDMuNC4wXG4gKi9cbmV4cG9ydCBjb25zdCBhdCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBpbmRleCkgPT4gc2VsZltpbmRleF0pO1xuZXhwb3J0IHtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBBcnJheWAgaXMgYSB0dXBsZSB3aXRoIGV4YWN0bHkgYE5gIGVsZW1lbnRzLCBuYXJyb3dpbmcgZG93biB0aGUgdHlwZSB0byBgVHVwbGVPZmAuXG4gKlxuICogQW4gYEFycmF5YCBpcyBjb25zaWRlcmVkIHRvIGJlIGEgYFR1cGxlT2ZgIGlmIGl0cyBsZW5ndGggaXMgZXhhY3RseSBgTmAuXG4gKlxuICogQHBhcmFtIHNlbGYgLSBUaGUgYEFycmF5YCB0byBjaGVjay5cbiAqIEBwYXJhbSBuIC0gVGhlIGV4YWN0IG51bWJlciBvZiBlbGVtZW50cyB0aGF0IHRoZSBgQXJyYXlgIHNob3VsZCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgYSBgVHVwbGVPZmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpc1R1cGxlT2YgfSBmcm9tIFwiZWZmZWN0L1R1cGxlXCJcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGlzVHVwbGVPZihbMSwgMiwgM10sIDMpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mKFsxLCAyLCAzXSwgMiksIGZhbHNlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mKFsxLCAyLCAzXSwgNCksIGZhbHNlKTtcbiAqXG4gKiBjb25zdCBhcnI6IG51bWJlcltdID0gWzEsIDIsIDNdO1xuICogaWYgKGlzVHVwbGVPZihhcnIsIDMpKSB7XG4gKiAgIGNvbnNvbGUubG9nKGFycik7XG4gKiAgIC8vIF4/IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICogfVxuICpcbiAqIGBgYFxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDMuMy4wXG4gKi9cbmlzVHVwbGVPZixcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBBcnJheWAgaXMgYSB0dXBsZSB3aXRoIGF0IGxlYXN0IGBOYCBlbGVtZW50cywgbmFycm93aW5nIGRvd24gdGhlIHR5cGUgdG8gYFR1cGxlT2ZBdExlYXN0YC5cbiAqXG4gKiBBbiBgQXJyYXlgIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBgVHVwbGVPZkF0TGVhc3RgIGlmIGl0cyBsZW5ndGggaXMgYXQgbGVhc3QgYE5gLlxuICpcbiAqIEBwYXJhbSBzZWxmIC0gVGhlIGBBcnJheWAgdG8gY2hlY2suXG4gKiBAcGFyYW0gbiAtIFRoZSBtaW5pbXVtIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IHRoZSBgQXJyYXlgIHNob3VsZCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgYSBgVHVwbGVPZkF0TGVhc3RgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaXNUdXBsZU9mQXRMZWFzdCB9IGZyb20gXCJlZmZlY3QvVHVwbGVcIlxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDMpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDIpLCB0cnVlKTtcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaXNUdXBsZU9mQXRMZWFzdChbMSwgMiwgM10sIDQpLCBmYWxzZSk7XG4gKlxuICogY29uc3QgYXJyOiBudW1iZXJbXSA9IFsxLCAyLCAzLCA0XTtcbiAqIGlmIChpc1R1cGxlT2ZBdExlYXN0KGFyciwgMykpIHtcbiAqICAgY29uc29sZS5sb2coYXJyKTtcbiAqICAgLy8gXj8gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIC4uLm51bWJlcltdXVxuICogfVxuICpcbiAqIGBgYFxuICogQGNhdGVnb3J5IGd1YXJkc1xuICogQHNpbmNlIDMuMy4wXG4gKi9cbmlzVHVwbGVPZkF0TGVhc3QgfSBmcm9tIFwiLi9QcmVkaWNhdGUuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR1cGxlLmpzLm1hcCJdLCJuYW1lcyI6WyJFcXVpdmFsZW5jZSIsImR1YWwiLCJvcmRlciIsIm1ha2UiLCJlbGVtZW50cyIsImdldEZpcnN0Iiwic2VsZiIsImdldFNlY29uZCIsIm1hcCIsImZuIiwiZWxlbWVudCIsIm1hcEJvdGgiLCJvbkZpcnN0Iiwib25TZWNvbmQiLCJtYXBGaXJzdCIsImYiLCJtYXBTZWNvbmQiLCJzd2FwIiwiZ2V0RXF1aXZhbGVuY2UiLCJ0dXBsZSIsImdldE9yZGVyIiwiYXBwZW5kRWxlbWVudCIsInRoYXQiLCJhdCIsImluZGV4IiwiaXNUdXBsZU9mIiwiaXNUdXBsZU9mQXRMZWFzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/Utils.js":
/*!***********************************************!*\
  !*** ./node_modules/effect/dist/esm/Utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenKindImpl: () => (/* binding */ GenKindImpl),\n/* harmony export */   GenKindTypeId: () => (/* binding */ GenKindTypeId),\n/* harmony export */   PCGRandom: () => (/* binding */ PCGRandom),\n/* harmony export */   SingleShotGen: () => (/* binding */ SingleShotGen),\n/* harmony export */   YieldWrap: () => (/* binding */ YieldWrap),\n/* harmony export */   YieldWrapTypeId: () => (/* binding */ YieldWrapTypeId),\n/* harmony export */   adapter: () => (/* binding */ adapter),\n/* harmony export */   internalCall: () => (/* binding */ internalCall),\n/* harmony export */   isGenKind: () => (/* binding */ isGenKind),\n/* harmony export */   isGeneratorFunction: () => (/* binding */ isGeneratorFunction),\n/* harmony export */   makeGenKind: () => (/* binding */ makeGenKind),\n/* harmony export */   structuralRegion: () => (/* binding */ structuralRegion),\n/* harmony export */   structuralRegionState: () => (/* binding */ structuralRegionState),\n/* harmony export */   yieldWrapGet: () => (/* binding */ yieldWrapGet)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/errors.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/**\n * @since 2.0.0\n */ \n\n\n\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 2.0.0\n */ /**\n * @category symbols\n * @since 2.0.0\n */ const GenKindTypeId = /*#__PURE__*/ Symbol.for(\"effect/Gen/GenKind\");\n/**\n * @category predicates\n * @since 3.0.6\n */ const isGenKind = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(u) && GenKindTypeId in u;\n/**\n * @category constructors\n * @since 2.0.0\n */ class GenKindImpl {\n    constructor(/**\n   * @since 2.0.0\n   */ value){\n        /**\n   * @since 2.0.0\n   */ this[GenKindTypeId] = GenKindTypeId;\n        this.value = value;\n    }\n    /**\n   * @since 2.0.0\n   */ get _F() {\n        return _Function_js__WEBPACK_IMPORTED_MODULE_1__.identity;\n    }\n    /**\n   * @since 2.0.0\n   */ get _R() {\n        return (_)=>_;\n    }\n    /**\n   * @since 2.0.0\n   */ get _O() {\n        return (_)=>_;\n    }\n    /**\n   * @since 2.0.0\n   */ get _E() {\n        return (_)=>_;\n    }\n    /**\n   * @since 2.0.0\n   */ [Symbol.iterator]() {\n        return new SingleShotGen(this);\n    }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */ class SingleShotGen {\n    constructor(self){\n        this.called = false;\n        this.self = self;\n    }\n    /**\n   * @since 2.0.0\n   */ next(a) {\n        return this.called ? {\n            value: a,\n            done: true\n        } : (this.called = true, {\n            value: this.self,\n            done: false\n        });\n    }\n    /**\n   * @since 2.0.0\n   */ return(a) {\n        return {\n            value: a,\n            done: true\n        };\n    }\n    /**\n   * @since 2.0.0\n   */ throw(e) {\n        throw e;\n    }\n    /**\n   * @since 2.0.0\n   */ [Symbol.iterator]() {\n        return new SingleShotGen(this.self);\n    }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */ const makeGenKind = (kind)=>new GenKindImpl(kind);\n/**\n * @category adapters\n * @since 2.0.0\n */ const adapter = ()=>function() {\n        let x = arguments[0];\n        for(let i = 1; i < arguments.length; i++){\n            x = arguments[i](x);\n        }\n        return new GenKindImpl(x);\n    };\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */ class PCGRandom {\n    constructor(seedHi, seedLo, incHi, incLo){\n        if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(seedLo) && (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(seedHi)) {\n            seedLo = Math.random() * 0xffffffff >>> 0;\n            seedHi = 0;\n        } else if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(seedLo)) {\n            seedLo = seedHi;\n            seedHi = 0;\n        }\n        if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(incLo) && (0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(incHi)) {\n            incLo = this._state ? this._state[3] : defaultIncLo;\n            incHi = this._state ? this._state[2] : defaultIncHi;\n        } else if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isNullable)(incLo)) {\n            incLo = incHi;\n            incHi = 0;\n        }\n        this._state = new Int32Array([\n            0,\n            0,\n            incHi >>> 0,\n            ((incLo || 0) | 1) >>> 0\n        ]);\n        this._next();\n        add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n        this._next();\n        return this;\n    }\n    /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */ getState() {\n        return [\n            this._state[0],\n            this._state[1],\n            this._state[2],\n            this._state[3]\n        ];\n    }\n    /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */ setState(state) {\n        this._state[0] = state[0];\n        this._state[1] = state[1];\n        this._state[2] = state[2];\n        this._state[3] = state[3] | 1;\n    }\n    /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */ integer(max) {\n        return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;\n    }\n    /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */ number() {\n        const hi = (this._next() & 0x03ffffff) * 1.0;\n        const lo = (this._next() & 0x07ffffff) * 1.0;\n        return (hi * BIT_27 + lo) / BIT_53;\n    }\n    /** @internal */ _next() {\n        // save current state (what we'll use for this number)\n        const oldHi = this._state[0] >>> 0;\n        const oldLo = this._state[1] >>> 0;\n        // churn LCG.\n        mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n        add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n        // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n        let xsHi = oldHi >>> 18;\n        let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n        xsHi = (xsHi ^ oldHi) >>> 0;\n        xsLo = (xsLo ^ oldLo) >>> 0;\n        const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n        // rotate xorshifted right a random amount, based on the most sig. 5 bits\n        // bits of the old state.\n        const rot = oldHi >>> 27;\n        const rot2 = (-rot >>> 0 & 31) >>> 0;\n        return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n    }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n    let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n    let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n    let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n    let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n    c0 = c0 << 16 >>> 0;\n    lo = lo + c0 >>> 0;\n    if (lo >>> 0 < c0 >>> 0) {\n        hi = hi + 1 >>> 0;\n    }\n    c1 = c1 << 16 >>> 0;\n    lo = lo + c1 >>> 0;\n    if (lo >>> 0 < c1 >>> 0) {\n        hi = hi + 1 >>> 0;\n    }\n    hi = hi + Math.imul(aLo, bHi) >>> 0;\n    hi = hi + Math.imul(aHi, bLo) >>> 0;\n    out[0] = hi;\n    out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n    let hi = aHi + bHi >>> 0;\n    const lo = aLo + bLo >>> 0;\n    if (lo >>> 0 < aLo >>> 0) {\n        hi = hi + 1 | 0;\n    }\n    out[0] = hi;\n    out[1] = lo;\n}\n/**\n * @since 3.0.6\n */ const YieldWrapTypeId = /*#__PURE__*/ Symbol.for(\"effect/Utils/YieldWrap\");\n/**\n * @since 3.0.6\n */ class YieldWrap {\n    /**\n   * @since 3.0.6\n   */ #value;\n    constructor(value){\n        this.#value = value;\n    }\n    /**\n   * @since 3.0.6\n   */ [YieldWrapTypeId]() {\n        return this.#value;\n    }\n}\n/**\n * @since 3.0.6\n */ function yieldWrapGet(self) {\n    if (typeof self === \"object\" && self !== null && YieldWrapTypeId in self) {\n        return self[YieldWrapTypeId]();\n    }\n    throw new Error((0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_2__.getBugErrorMessage)(\"yieldWrapGet\"));\n}\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */ const structuralRegionState = /*#__PURE__*/ (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_3__.globalValue)(\"effect/Utils/isStructuralRegion\", ()=>({\n        enabled: false,\n        tester: undefined\n    }));\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */ const structuralRegion = (body, tester)=>{\n    const current = structuralRegionState.enabled;\n    const currentTester = structuralRegionState.tester;\n    structuralRegionState.enabled = true;\n    if (tester) {\n        structuralRegionState.tester = tester;\n    }\n    try {\n        return body();\n    } finally{\n        structuralRegionState.enabled = current;\n        structuralRegionState.tester = currentTester;\n    }\n};\nconst tracingFunction = (name)=>{\n    const wrap = {\n        [name] (body) {\n            return body();\n        }\n    };\n    return function(fn) {\n        return wrap[name](fn);\n    };\n};\n/**\n * @since 3.2.2\n * @status experimental\n * @category tracing\n */ const internalCall = /*#__PURE__*/ tracingFunction(\"effect_internal_function\");\nconst genConstructor = (function*() {}).constructor;\n/**\n * @since 3.11.0\n */ const isGeneratorFunction = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(u) && u.constructor === genConstructor; //# sourceMappingURL=Utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL1V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ3dDO0FBQ007QUFDVztBQUNKO0FBQ3REOzs7Ozs7Ozs7OztDQVdDLEdBQ0Q7OztDQUdDLEdBQ00sTUFBTUssZ0JBQWdCLFdBQVcsR0FBRUMsT0FBT0MsR0FBRyxDQUFDLHNCQUFzQjtBQUMzRTs7O0NBR0MsR0FDTSxNQUFNQyxZQUFZQyxDQUFBQSxJQUFLTCx1REFBUUEsQ0FBQ0ssTUFBTUosaUJBQWlCSSxFQUFFO0FBQ2hFOzs7Q0FHQyxHQUNNLE1BQU1DO0lBRVhDLFlBQ0E7O0dBRUMsR0FDREMsS0FBSyxDQUFFO1FBMkJQOztHQUVDLE9BQ0QsQ0FBQ1AsY0FBYyxHQUFHQTtRQTdCaEIsSUFBSSxDQUFDTyxLQUFLLEdBQUdBO0lBQ2Y7SUFDQTs7R0FFQyxHQUNELElBQUlDLEtBQUs7UUFDUCxPQUFPYixrREFBUUE7SUFDakI7SUFDQTs7R0FFQyxHQUNELElBQUljLEtBQUs7UUFDUCxPQUFPQyxDQUFBQSxJQUFLQTtJQUNkO0lBQ0E7O0dBRUMsR0FDRCxJQUFJQyxLQUFLO1FBQ1AsT0FBT0QsQ0FBQUEsSUFBS0E7SUFDZDtJQUNBOztHQUVDLEdBQ0QsSUFBSUUsS0FBSztRQUNQLE9BQU9GLENBQUFBLElBQUtBO0lBQ2Q7SUFLQTs7R0FFQyxHQUNELENBQUNULE9BQU9ZLFFBQVEsQ0FBQyxHQUFHO1FBQ2xCLE9BQU8sSUFBSUMsY0FBYyxJQUFJO0lBQy9CO0FBQ0Y7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQTtJQUdYUixZQUFZUyxJQUFJLENBQUU7YUFEbEJDLFNBQVM7UUFFUCxJQUFJLENBQUNELElBQUksR0FBR0E7SUFDZDtJQUNBOztHQUVDLEdBQ0RFLEtBQUtDLENBQUMsRUFBRTtRQUNOLE9BQU8sSUFBSSxDQUFDRixNQUFNLEdBQUc7WUFDbkJULE9BQU9XO1lBQ1BDLE1BQU07UUFDUixJQUFL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LElBQUlDLFFBQVE7UUFDVkYsc0JBQXNCRSxNQUFNLEdBQUdBO0lBQ2pDO0lBQ0EsSUFBSTtRQUNGLE9BQU9HO0lBQ1QsU0FBVTtRQUNSTCxzQkFBc0JDLE9BQU8sR0FBR0s7UUFDaENOLHNCQUFzQkUsTUFBTSxHQUFHSztJQUNqQztBQUNGLEVBQUU7QUFDRixNQUFNQyxrQkFBa0JDLENBQUFBO0lBQ3RCLE1BQU1DLE9BQU87UUFDWCxDQUFDRCxLQUFLLEVBQUNKLElBQUk7WUFDVCxPQUFPQTtRQUNUO0lBQ0Y7SUFDQSxPQUFPLFNBQVVNLEVBQUU7UUFDakIsT0FBT0QsSUFBSSxDQUFDRCxLQUFLLENBQUNFO0lBQ3BCO0FBQ0Y7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUMsZUFBZSxXQUFXLEdBQUVKLGdCQUFnQiw0QkFBNEI7QUFDckYsTUFBTUssaUJBQWlCLGNBQWMsR0FBRXJGLFdBQVc7QUFDbEQ7O0NBRUMsR0FDTSxNQUFNc0Ysc0JBQXNCeEYsQ0FBQUEsSUFBS0wsdURBQVFBLENBQUNLLE1BQU1BLEVBQUVFLFdBQVcsS0FBS3FGLGVBQWUsQ0FDeEYsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9VdGlscy5qcz80OTNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSBcIi4vRnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IGdsb2JhbFZhbHVlIH0gZnJvbSBcIi4vR2xvYmFsVmFsdWUuanNcIjtcbmltcG9ydCB7IGdldEJ1Z0Vycm9yTWVzc2FnZSB9IGZyb20gXCIuL2ludGVybmFsL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgaXNOdWxsYWJsZSwgaXNPYmplY3QgfSBmcm9tIFwiLi9QcmVkaWNhdGUuanNcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBUaG9tIENoaW92b2xvbmksIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKiBBIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGJhc2VkIG9uIHRoZSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUENHIGFsZ29yaXRobSxcbiAqIGFzIGRlc2NyaWJlZCBoZXJlOiBodHRwOi8vd3d3LnBjZy1yYW5kb20ub3JnL1xuICpcbiAqIEFkYXB0ZWQgZm9yIFR5cGVTY3JpcHQgZnJvbSBUaG9tJ3Mgb3JpZ2luYWwgY29kZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdGhvbWNjL3BjZy1yYW5kb21cbiAqXG4gKiBmb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZnJwdG9vbHNcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuLyoqXG4gKiBAY2F0ZWdvcnkgc3ltYm9sc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBHZW5LaW5kVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvR2VuL0dlbktpbmRcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBwcmVkaWNhdGVzXG4gKiBAc2luY2UgMy4wLjZcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR2VuS2luZCA9IHUgPT4gaXNPYmplY3QodSkgJiYgR2VuS2luZFR5cGVJZCBpbiB1O1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNsYXNzIEdlbktpbmRJbXBsIHtcbiAgdmFsdWU7XG4gIGNvbnN0cnVjdG9yKFxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICB2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDIuMC4wXG4gICAqL1xuICBnZXQgX0YoKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGdldCBfUigpIHtcbiAgICByZXR1cm4gXyA9PiBfO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGdldCBfTygpIHtcbiAgICByZXR1cm4gXyA9PiBfO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIGdldCBfRSgpIHtcbiAgICByZXR1cm4gXyA9PiBfO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtHZW5LaW5kVHlwZUlkXSA9IEdlbktpbmRUeXBlSWQ7XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgU2luZ2xlU2hvdEdlbih0aGlzKTtcbiAgfVxufVxuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbmdsZVNob3RHZW4ge1xuICBzZWxmO1xuICBjYWxsZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgbmV4dChhKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGVkID8ge1xuICAgICAgdmFsdWU6IGEsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfSA6ICh0aGlzLmNhbGxlZCA9IHRydWUsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnNlbGYsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHJldHVybihhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgdGhyb3coZSkge1xuICAgIHRocm93IGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5nbGVTaG90R2VuKHRoaXMuc2VsZik7XG4gIH1cbn1cbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlR2VuS2luZCA9IGtpbmQgPT4gbmV3IEdlbktpbmRJbXBsKGtpbmQpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY29uc3QgYWRhcHRlciA9ICgpID0+IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHggPSBhcmd1bWVudHNbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXSh4KTtcbiAgfVxuICByZXR1cm4gbmV3IEdlbktpbmRJbXBsKHgpO1xufTtcbmNvbnN0IGRlZmF1bHRJbmNIaSA9IDB4MTQwNTdiN2U7XG5jb25zdCBkZWZhdWx0SW5jTG8gPSAweGY3Njc4MTRmO1xuY29uc3QgTVVMX0hJID0gMHg1ODUxZjQyZCA+Pj4gMDtcbmNvbnN0IE1VTF9MTyA9IDB4NGM5NTdmMmQgPj4+IDA7XG5jb25zdCBCSVRfNTMgPSA5MDA3MTk5MjU0NzQwOTkyLjA7XG5jb25zdCBCSVRfMjcgPSAxMzQyMTc3MjguMDtcbi8qKlxuICogUENHIGlzIGEgZmFtaWx5IG9mIHNpbXBsZSBmYXN0IHNwYWNlLWVmZmljaWVudCBzdGF0aXN0aWNhbGx5IGdvb2QgYWxnb3JpdGhtc1xuICogZm9yIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbi4gVW5saWtlIG1hbnkgZ2VuZXJhbC1wdXJwb3NlIFJOR3MsIHRoZXkgYXJlIGFsc29cbiAqIGhhcmQgdG8gcHJlZGljdC5cbiAqXG4gKiBAY2F0ZWdvcnkgbW9kZWxcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgY2xhc3MgUENHUmFuZG9tIHtcbiAgX3N0YXRlO1xuICBjb25zdHJ1Y3RvcihzZWVkSGksIHNlZWRMbywgaW5jSGksIGluY0xvKSB7XG4gICAgaWYgKGlzTnVsbGFibGUoc2VlZExvKSAmJiBpc051bGxhYmxlKHNlZWRIaSkpIHtcbiAgICAgIHNlZWRMbyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmID4+PiAwO1xuICAgICAgc2VlZEhpID0gMDtcbiAgICB9IGVsc2UgaWYgKGlzTnVsbGFibGUoc2VlZExvKSkge1xuICAgICAgc2VlZExvID0gc2VlZEhpO1xuICAgICAgc2VlZEhpID0gMDtcbiAgICB9XG4gICAgaWYgKGlzTnVsbGFibGUoaW5jTG8pICYmIGlzTnVsbGFibGUoaW5jSGkpKSB7XG4gICAgICBpbmNMbyA9IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGVbM10gOiBkZWZhdWx0SW5jTG87XG4gICAgICBpbmNIaSA9IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGVbMl0gOiBkZWZhdWx0SW5jSGk7XG4gICAgfSBlbHNlIGlmIChpc051bGxhYmxlKGluY0xvKSkge1xuICAgICAgaW5jTG8gPSBpbmNIaTtcbiAgICAgIGluY0hpID0gMDtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgSW50MzJBcnJheShbMCwgMCwgaW5jSGkgPj4+IDAsICgoaW5jTG8gfHwgMCkgfCAxKSA+Pj4gMF0pO1xuICAgIHRoaXMuX25leHQoKTtcbiAgICBhZGQ2NCh0aGlzLl9zdGF0ZSwgdGhpcy5fc3RhdGVbMF0sIHRoaXMuX3N0YXRlWzFdLCBzZWVkSGkgPj4+IDAsIHNlZWRMbyA+Pj4gMCk7XG4gICAgdGhpcy5fbmV4dCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBhcyBhXG4gICAqIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl9zdGF0ZVswXSwgdGhpcy5fc3RhdGVbMV0sIHRoaXMuX3N0YXRlWzJdLCB0aGlzLl9zdGF0ZVszXV07XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmUgc3RhdGUgcHJldmlvdXNseSByZXRyaWV2ZWQgdXNpbmcgYGdldFN0YXRlKClgLlxuICAgKlxuICAgKiBAc2luY2UgMi4wLjBcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5fc3RhdGVbMF0gPSBzdGF0ZVswXTtcbiAgICB0aGlzLl9zdGF0ZVsxXSA9IHN0YXRlWzFdO1xuICAgIHRoaXMuX3N0YXRlWzJdID0gc3RhdGVbMl07XG4gICAgdGhpcy5fc3RhdGVbM10gPSBzdGF0ZVszXSB8IDE7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHVuaWZvcm1seSBkaXN0cmlidXRlZCAzMiBiaXQgaW50ZWdlciBiZXR3ZWVuIFswLCBtYXgpLlxuICAgKlxuICAgKiBAY2F0ZWdvcnkgZ2V0dGVyXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgaW50ZWdlcihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLm51bWJlcigpICogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpICUgbWF4O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgSUVFRS03NTQgZG91YmxlIGJldHdlZW4gMC4wIGFuZCAxLjAsIHdpdGhcbiAgICogNTMgYml0cyBvZiBwcmVjaXNpb24gKGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2EgaXMgcmFuZG9taXplZCkuXG4gICAqXG4gICAqIEBjYXRlZ29yeSBnZXR0ZXJzXG4gICAqIEBzaW5jZSAyLjAuMFxuICAgKi9cbiAgbnVtYmVyKCkge1xuICAgIGNvbnN0IGhpID0gKHRoaXMuX25leHQoKSAmIDB4MDNmZmZmZmYpICogMS4wO1xuICAgIGNvbnN0IGxvID0gKHRoaXMuX25leHQoKSAmIDB4MDdmZmZmZmYpICogMS4wO1xuICAgIHJldHVybiAoaGkgKiBCSVRfMjcgKyBsbykgLyBCSVRfNTM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfbmV4dCgpIHtcbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGUgKHdoYXQgd2UnbGwgdXNlIGZvciB0aGlzIG51bWJlcilcbiAgICBjb25zdCBvbGRIaSA9IHRoaXMuX3N0YXRlWzBdID4+PiAwO1xuICAgIGNvbnN0IG9sZExvID0gdGhpcy5fc3RhdGVbMV0gPj4+IDA7XG4gICAgLy8gY2h1cm4gTENHLlxuICAgIG11bDY0KHRoaXMuX3N0YXRlLCBvbGRIaSwgb2xkTG8sIE1VTF9ISSwgTVVMX0xPKTtcbiAgICBhZGQ2NCh0aGlzLl9zdGF0ZSwgdGhpcy5fc3RhdGVbMF0sIHRoaXMuX3N0YXRlWzFdLCB0aGlzLl9zdGF0ZVsyXSwgdGhpcy5fc3RhdGVbM10pO1xuICAgIC8vIGdldCBsZWFzdCBzaWcuIDMyIGJpdHMgb2YgKChvbGRzdGF0ZSA+PiAxOCkgXiBvbGRzdGF0ZSkgPj4gMjdcbiAgICBsZXQgeHNIaSA9IG9sZEhpID4+PiAxODtcbiAgICBsZXQgeHNMbyA9IChvbGRMbyA+Pj4gMTggfCBvbGRIaSA8PCAxNCkgPj4+IDA7XG4gICAgeHNIaSA9ICh4c0hpIF4gb2xkSGkpID4+PiAwO1xuICAgIHhzTG8gPSAoeHNMbyBeIG9sZExvKSA+Pj4gMDtcbiAgICBjb25zdCB4b3JzaGlmdGVkID0gKHhzTG8gPj4+IDI3IHwgeHNIaSA8PCA1KSA+Pj4gMDtcbiAgICAvLyByb3RhdGUgeG9yc2hpZnRlZCByaWdodCBhIHJhbmRvbSBhbW91bnQsIGJhc2VkIG9uIHRoZSBtb3N0IHNpZy4gNSBiaXRzXG4gICAgLy8gYml0cyBvZiB0aGUgb2xkIHN0YXRlLlxuICAgIGNvbnN0IHJvdCA9IG9sZEhpID4+PiAyNztcbiAgICBjb25zdCByb3QyID0gKC1yb3QgPj4+IDAgJiAzMSkgPj4+IDA7XG4gICAgcmV0dXJuICh4b3JzaGlmdGVkID4+PiByb3QgfCB4b3JzaGlmdGVkIDw8IHJvdDIpID4+PiAwO1xuICB9XG59XG5mdW5jdGlvbiBtdWw2NChvdXQsIGFIaSwgYUxvLCBiSGksIGJMbykge1xuICBsZXQgYzEgPSAoYUxvID4+PiAxNikgKiAoYkxvICYgMHhmZmZmKSA+Pj4gMDtcbiAgbGV0IGMwID0gKGFMbyAmIDB4ZmZmZikgKiAoYkxvID4+PiAxNikgPj4+IDA7XG4gIGxldCBsbyA9IChhTG8gJiAweGZmZmYpICogKGJMbyAmIDB4ZmZmZikgPj4+IDA7XG4gIGxldCBoaSA9IChhTG8gPj4+IDE2KSAqIChiTG8gPj4+IDE2KSArICgoYzAgPj4+IDE2KSArIChjMSA+Pj4gMTYpKSA+Pj4gMDtcbiAgYzAgPSBjMCA8PCAxNiA+Pj4gMDtcbiAgbG8gPSBsbyArIGMwID4+PiAwO1xuICBpZiAobG8gPj4+IDAgPCBjMCA+Pj4gMCkge1xuICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICB9XG4gIGMxID0gYzEgPDwgMTYgPj4+IDA7XG4gIGxvID0gbG8gKyBjMSA+Pj4gMDtcbiAgaWYgKGxvID4+PiAwIDwgYzEgPj4+IDApIHtcbiAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgfVxuICBoaSA9IGhpICsgTWF0aC5pbXVsKGFMbywgYkhpKSA+Pj4gMDtcbiAgaGkgPSBoaSArIE1hdGguaW11bChhSGksIGJMbykgPj4+IDA7XG4gIG91dFswXSA9IGhpO1xuICBvdXRbMV0gPSBsbztcbn1cbi8vIGFkZCB0d28gNjQgYml0IG51bWJlcnMgKGdpdmVuIGluIHBhcnRzKSwgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW4gYG91dGAuXG5mdW5jdGlvbiBhZGQ2NChvdXQsIGFIaSwgYUxvLCBiSGksIGJMbykge1xuICBsZXQgaGkgPSBhSGkgKyBiSGkgPj4+IDA7XG4gIGNvbnN0IGxvID0gYUxvICsgYkxvID4+PiAwO1xuICBpZiAobG8gPj4+IDAgPCBhTG8gPj4+IDApIHtcbiAgICBoaSA9IGhpICsgMSB8IDA7XG4gIH1cbiAgb3V0WzBdID0gaGk7XG4gIG91dFsxXSA9IGxvO1xufVxuLyoqXG4gKiBAc2luY2UgMy4wLjZcbiAqL1xuZXhwb3J0IGNvbnN0IFlpZWxkV3JhcFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L1V0aWxzL1lpZWxkV3JhcFwiKTtcbi8qKlxuICogQHNpbmNlIDMuMC42XG4gKi9cbmV4cG9ydCBjbGFzcyBZaWVsZFdyYXAge1xuICAvKipcbiAgICogQHNpbmNlIDMuMC42XG4gICAqL1xuICAjdmFsdWU7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy4jdmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIDMuMC42XG4gICAqL1xuICBbWWllbGRXcmFwVHlwZUlkXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdmFsdWU7XG4gIH1cbn1cbi8qKlxuICogQHNpbmNlIDMuMC42XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5aWVsZFdyYXBHZXQoc2VsZikge1xuICBpZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZiAhPT0gbnVsbCAmJiBZaWVsZFdyYXBUeXBlSWQgaW4gc2VsZikge1xuICAgIHJldHVybiBzZWxmW1lpZWxkV3JhcFR5cGVJZF0oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoZ2V0QnVnRXJyb3JNZXNzYWdlKFwieWllbGRXcmFwR2V0XCIpKTtcbn1cbi8qKlxuICogTm90ZTogdGhpcyBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBtYWRlIGF2YWlsYWJsZSB0byBhbGxvdyBjdXN0b20gbWF0Y2hlcnMgaW4gdGVzdHMsIG5vdCB0byBiZSBkaXJlY3RseSB1c2VkIHlldCBpbiB1c2VyIGNvZGVcbiAqXG4gKiBAc2luY2UgMy4xLjFcbiAqIEBzdGF0dXMgZXhwZXJpbWVudGFsXG4gKiBAY2F0ZWdvcnkgbW9kaWZpZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUgPSAvKiNfX1BVUkVfXyovZ2xvYmFsVmFsdWUoXCJlZmZlY3QvVXRpbHMvaXNTdHJ1Y3R1cmFsUmVnaW9uXCIsICgpID0+ICh7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICB0ZXN0ZXI6IHVuZGVmaW5lZFxufSkpO1xuLyoqXG4gKiBOb3RlOiB0aGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIG1hZGUgYXZhaWxhYmxlIHRvIGFsbG93IGN1c3RvbSBtYXRjaGVycyBpbiB0ZXN0cywgbm90IHRvIGJlIGRpcmVjdGx5IHVzZWQgeWV0IGluIHVzZXIgY29kZVxuICpcbiAqIEBzaW5jZSAzLjEuMVxuICogQHN0YXR1cyBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSBtb2RpZmllcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cnVjdHVyYWxSZWdpb24gPSAoYm9keSwgdGVzdGVyKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnQgPSBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUuZW5hYmxlZDtcbiAgY29uc3QgY3VycmVudFRlc3RlciA9IHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXI7XG4gIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS5lbmFibGVkID0gdHJ1ZTtcbiAgaWYgKHRlc3Rlcikge1xuICAgIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS50ZXN0ZXIgPSB0ZXN0ZXI7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYm9keSgpO1xuICB9IGZpbmFsbHkge1xuICAgIHN0cnVjdHVyYWxSZWdpb25TdGF0ZS5lbmFibGVkID0gY3VycmVudDtcbiAgICBzdHJ1Y3R1cmFsUmVnaW9uU3RhdGUudGVzdGVyID0gY3VycmVudFRlc3RlcjtcbiAgfVxufTtcbmNvbnN0IHRyYWNpbmdGdW5jdGlvbiA9IG5hbWUgPT4ge1xuICBjb25zdCB3cmFwID0ge1xuICAgIFtuYW1lXShib2R5KSB7XG4gICAgICByZXR1cm4gYm9keSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiB3cmFwW25hbWVdKGZuKTtcbiAgfTtcbn07XG4vKipcbiAqIEBzaW5jZSAzLjIuMlxuICogQHN0YXR1cyBleHBlcmltZW50YWxcbiAqIEBjYXRlZ29yeSB0cmFjaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbENhbGwgPSAvKiNfX1BVUkVfXyovdHJhY2luZ0Z1bmN0aW9uKFwiZWZmZWN0X2ludGVybmFsX2Z1bmN0aW9uXCIpO1xuY29uc3QgZ2VuQ29uc3RydWN0b3IgPSBmdW5jdGlvbiogKCkge30uY29uc3RydWN0b3I7XG4vKipcbiAqIEBzaW5jZSAzLjExLjBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR2VuZXJhdG9yRnVuY3Rpb24gPSB1ID0+IGlzT2JqZWN0KHUpICYmIHUuY29uc3RydWN0b3IgPT09IGdlbkNvbnN0cnVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImlkZW50aXR5IiwiZ2xvYmFsVmFsdWUiLCJnZXRCdWdFcnJvck1lc3NhZ2UiLCJpc051bGxhYmxlIiwiaXNPYmplY3QiLCJHZW5LaW5kVHlwZUlkIiwiU3ltYm9sIiwiZm9yIiwiaXNHZW5LaW5kIiwidSIsIkdlbktpbmRJbXBsIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsIl9GIiwiX1IiLCJfIiwiX08iLCJfRSIsIml0ZXJhdG9yIiwiU2luZ2xlU2hvdEdlbiIsInNlbGYiLCJjYWxsZWQiLCJuZXh0IiwiYSIsImRvbmUiLCJyZXR1cm4iLCJ0aHJvdyIsImUiLCJtYWtlR2VuS2luZCIsImtpbmQiLCJhZGFwdGVyIiwieCIsImFyZ3VtZW50cyIsImkiLCJsZW5ndGgiLCJkZWZhdWx0SW5jSGkiLCJkZWZhdWx0SW5jTG8iLCJNVUxfSEkiLCJNVUxfTE8iLCJCSVRfNTMiLCJCSVRfMjciLCJQQ0dSYW5kb20iLCJzZWVkSGkiLCJzZWVkTG8iLCJpbmNIaSIsImluY0xvIiwiTWF0aCIsInJhbmRvbSIsIl9zdGF0ZSIsIkludDMyQXJyYXkiLCJfbmV4dCIsImFkZDY0IiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN0YXRlIiwiaW50ZWdlciIsIm1heCIsInJvdW5kIiwibnVtYmVyIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImhpIiwibG8iLCJvbGRIaSIsIm9sZExvIiwibXVsNjQiLCJ4c0hpIiwieHNMbyIsInhvcnNoaWZ0ZWQiLCJyb3QiLCJyb3QyIiwib3V0IiwiYUhpIiwiYUxvIiwiYkhpIiwiYkxvIiwiYzEiLCJjMCIsImltdWwiLCJZaWVsZFdyYXBUeXBlSWQiLCJZaWVsZFdyYXAiLCJ5aWVsZFdyYXBHZXQiLCJFcnJvciIsInN0cnVjdHVyYWxSZWdpb25TdGF0ZSIsImVuYWJsZWQiLCJ0ZXN0ZXIiLCJ1bmRlZmluZWQiLCJzdHJ1Y3R1cmFsUmVnaW9uIiwiYm9keSIsImN1cnJlbnQiLCJjdXJyZW50VGVzdGVyIiwidHJhY2luZ0Z1bmN0aW9uIiwibmFtZSIsIndyYXAiLCJmbiIsImludGVybmFsQ2FsbCIsImdlbkNvbnN0cnVjdG9yIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/Utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/array.js":
/*!********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/array.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNonEmptyArray: () => (/* binding */ isNonEmptyArray)\n/* harmony export */ });\n/**\n * @since 2.0.0\n */ /** @internal */ const isNonEmptyArray = (self)=>self.length > 0; //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNELGNBQWMsR0FDUCxNQUFNQSxrQkFBa0JDLENBQUFBLE9BQVFBLEtBQUtDLE1BQU0sR0FBRyxFQUFFLENBQ3ZELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvYXJyYXkuanM/ZDMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNOb25FbXB0eUFycmF5ID0gc2VsZiA9PiBzZWxmLmxlbmd0aCA+IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOlsiaXNOb25FbXB0eUFycmF5Iiwic2VsZiIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/context.js":
/*!**********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/context.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextProto: () => (/* binding */ ContextProto),\n/* harmony export */   Reference: () => (/* binding */ Reference),\n/* harmony export */   ReferenceProto: () => (/* binding */ ReferenceProto),\n/* harmony export */   ReferenceTypeId: () => (/* binding */ ReferenceTypeId),\n/* harmony export */   STMTypeId: () => (/* binding */ STMTypeId),\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   TagProto: () => (/* binding */ TagProto),\n/* harmony export */   TagTypeId: () => (/* binding */ TagTypeId),\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getOption: () => (/* binding */ getOption),\n/* harmony export */   getOrElse: () => (/* binding */ getOrElse),\n/* harmony export */   isContext: () => (/* binding */ isContext),\n/* harmony export */   isReference: () => (/* binding */ isReference),\n/* harmony export */   isTag: () => (/* binding */ isTag),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   makeContext: () => (/* binding */ makeContext),\n/* harmony export */   makeGenericTag: () => (/* binding */ makeGenericTag),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeAll: () => (/* binding */ mergeAll),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   unsafeGet: () => (/* binding */ unsafeGet),\n/* harmony export */   unsafeGetReference: () => (/* binding */ unsafeGetReference)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/* harmony import */ var _option_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./option.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/option.js\");\n\n\n\n\n\n\n\n\n\n/** @internal */ const TagTypeId = /*#__PURE__*/ Symbol.for(\"effect/Context/Tag\");\n/** @internal */ const ReferenceTypeId = /*#__PURE__*/ Symbol.for(\"effect/Context/Reference\");\n/** @internal */ const STMSymbolKey = \"effect/STM\";\n/** @internal */ const STMTypeId = /*#__PURE__*/ Symbol.for(STMSymbolKey);\n/** @internal */ const TagProto = {\n    ..._effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype,\n    _op: \"Tag\",\n    [STMTypeId]: _effectable_js__WEBPACK_IMPORTED_MODULE_0__.effectVariance,\n    [TagTypeId]: {\n        _Service: (_)=>_,\n        _Identifier: (_)=>_\n    },\n    toString () {\n        return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"Tag\",\n            key: this.key,\n            stack: this.stack\n        };\n    },\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol] () {\n        return this.toJSON();\n    },\n    of (self) {\n        return self;\n    },\n    context (self) {\n        return make(this, self);\n    }\n};\nconst ReferenceProto = {\n    ...TagProto,\n    [ReferenceTypeId]: ReferenceTypeId\n};\n/** @internal */ const makeGenericTag = (key)=>{\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 2;\n    const creationError = new Error();\n    Error.stackTraceLimit = limit;\n    const tag = Object.create(TagProto);\n    Object.defineProperty(tag, \"stack\", {\n        get () {\n            return creationError.stack;\n        }\n    });\n    tag.key = key;\n    return tag;\n};\n/** @internal */ const Tag = (id)=>()=>{\n        const limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 2;\n        const creationError = new Error();\n        Error.stackTraceLimit = limit;\n        function TagClass() {}\n        Object.setPrototypeOf(TagClass, TagProto);\n        TagClass.key = id;\n        Object.defineProperty(TagClass, \"stack\", {\n            get () {\n                return creationError.stack;\n            }\n        });\n        return TagClass;\n    };\n/** @internal */ const Reference = ()=>(id, options)=>{\n        const limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 2;\n        const creationError = new Error();\n        Error.stackTraceLimit = limit;\n        function ReferenceClass() {}\n        Object.setPrototypeOf(ReferenceClass, ReferenceProto);\n        ReferenceClass.key = id;\n        ReferenceClass.defaultValue = options.defaultValue;\n        Object.defineProperty(ReferenceClass, \"stack\", {\n            get () {\n                return creationError.stack;\n            }\n        });\n        return ReferenceClass;\n    };\n/** @internal */ const TypeId = /*#__PURE__*/ Symbol.for(\"effect/Context\");\n/** @internal */ const ContextProto = {\n    [TypeId]: {\n        _Services: (_)=>_\n    },\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol] (that) {\n        if (isContext(that)) {\n            if (this.unsafeMap.size === that.unsafeMap.size) {\n                for (const k of this.unsafeMap.keys()){\n                    if (!that.unsafeMap.has(k) || !_Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol] () {\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_3__.number(this.unsafeMap.size));\n    },\n    pipe () {\n        return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_4__.pipeArguments)(this, arguments);\n    },\n    toString () {\n        return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n    },\n    toJSON () {\n        return {\n            _id: \"Context\",\n            services: Array.from(this.unsafeMap).map(_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)\n        };\n    },\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol] () {\n        return this.toJSON();\n    }\n};\n/** @internal */ const makeContext = (unsafeMap)=>{\n    const context = Object.create(ContextProto);\n    context.unsafeMap = unsafeMap;\n    return context;\n};\nconst serviceNotFoundError = (tag)=>{\n    const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : \"\"}`);\n    if (tag.stack) {\n        const lines = tag.stack.split(\"\\n\");\n        if (lines.length > 2) {\n            const afterAt = lines[2].match(/at (.*)/);\n            if (afterAt) {\n                error.message = error.message + ` (defined at ${afterAt[1]})`;\n            }\n        }\n    }\n    if (error.stack) {\n        const lines = error.stack.split(\"\\n\");\n        lines.splice(1, 3);\n        error.stack = lines.join(\"\\n\");\n    }\n    return error;\n};\n/** @internal */ const isContext = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_5__.hasProperty)(u, TypeId);\n/** @internal */ const isTag = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_5__.hasProperty)(u, TagTypeId);\n/** @internal */ const isReference = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_5__.hasProperty)(u, ReferenceTypeId);\nconst _empty = /*#__PURE__*/ makeContext(/*#__PURE__*/ new Map());\n/** @internal */ const empty = ()=>_empty;\n/** @internal */ const make = (tag, service)=>makeContext(new Map([\n        [\n            tag.key,\n            service\n        ]\n    ]));\n/** @internal */ const add = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(3, (self, tag, service)=>{\n    const map = new Map(self.unsafeMap);\n    map.set(tag.key, service);\n    return makeContext(map);\n});\nconst defaultValueCache = /*#__PURE__*/ (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_7__.globalValue)(\"effect/Context/defaultValueCache\", ()=>new Map());\nconst getDefaultValue = (tag)=>{\n    if (defaultValueCache.has(tag.key)) {\n        return defaultValueCache.get(tag.key);\n    }\n    const value = tag.defaultValue();\n    defaultValueCache.set(tag.key, value);\n    return value;\n};\n/** @internal */ const unsafeGetReference = (self, tag)=>{\n    return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);\n};\n/** @internal */ const unsafeGet = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, tag)=>{\n    if (!self.unsafeMap.has(tag.key)) {\n        if (ReferenceTypeId in tag) return getDefaultValue(tag);\n        throw serviceNotFoundError(tag);\n    }\n    return self.unsafeMap.get(tag.key);\n});\n/** @internal */ const get = unsafeGet;\n/** @internal */ const getOrElse = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(3, (self, tag, orElse)=>{\n    if (!self.unsafeMap.has(tag.key)) {\n        return isReference(tag) ? getDefaultValue(tag) : orElse();\n    }\n    return self.unsafeMap.get(tag.key);\n});\n/** @internal */ const getOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, tag)=>{\n    if (!self.unsafeMap.has(tag.key)) {\n        return isReference(tag) ? _option_js__WEBPACK_IMPORTED_MODULE_8__.some(getDefaultValue(tag)) : _option_js__WEBPACK_IMPORTED_MODULE_8__.none;\n    }\n    return _option_js__WEBPACK_IMPORTED_MODULE_8__.some(self.unsafeMap.get(tag.key));\n});\n/** @internal */ const merge = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, that)=>{\n    const map = new Map(self.unsafeMap);\n    for (const [tag, s] of that.unsafeMap){\n        map.set(tag, s);\n    }\n    return makeContext(map);\n});\n/** @internal */ const mergeAll = (...ctxs)=>{\n    const map = new Map();\n    for (const ctx of ctxs){\n        for (const [tag, s] of ctx.unsafeMap){\n            map.set(tag, s);\n        }\n    }\n    return makeContext(map);\n};\n/** @internal */ const pick = (...tags)=>(self)=>{\n        const tagSet = new Set(tags.map((_)=>_.key));\n        const newEnv = new Map();\n        for (const [tag, s] of self.unsafeMap.entries()){\n            if (tagSet.has(tag)) {\n                newEnv.set(tag, s);\n            }\n        }\n        return makeContext(newEnv);\n    };\n/** @internal */ const omit = (...tags)=>(self)=>{\n        const newEnv = new Map(self.unsafeMap);\n        for (const tag of tags){\n            newEnv.delete(tag.key);\n        }\n        return makeContext(newEnv);\n    }; //# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQztBQUNVO0FBQ2I7QUFDbUM7QUFDdkI7QUFDRDtBQUNvQjtBQUM1QjtBQUN0QyxjQUFjLEdBQ1AsTUFBTVksWUFBWSxXQUFXLEdBQUVDLE9BQU9DLEdBQUcsQ0FBQyxzQkFBc0I7QUFDdkUsY0FBYyxHQUNQLE1BQU1DLGtCQUFrQixXQUFXLEdBQUVGLE9BQU9DLEdBQUcsQ0FBQyw0QkFBNEI7QUFDbkYsY0FBYyxHQUNkLE1BQU1FLGVBQWU7QUFDckIsY0FBYyxHQUNQLE1BQU1DLFlBQVksV0FBVyxHQUFFSixPQUFPQyxHQUFHLENBQUNFLGNBQWM7QUFDL0QsY0FBYyxHQUNQLE1BQU1FLFdBQVc7SUFDdEIsR0FBR1QsMkRBQWU7SUFDbEJVLEtBQUs7SUFDTCxDQUFDRixVQUFVLEVBQUVQLDBEQUFjQTtJQUMzQixDQUFDRSxVQUFVLEVBQUU7UUFDWFEsVUFBVUMsQ0FBQUEsSUFBS0E7UUFDZkMsYUFBYUQsQ0FBQUEsSUFBS0E7SUFDcEI7SUFDQUU7UUFDRSxPQUFPbkIsdURBQU1BLENBQUMsSUFBSSxDQUFDRSxNQUFNO0lBQzNCO0lBQ0FBO1FBQ0UsT0FBTztZQUNMa0IsS0FBSztZQUNMQyxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNuQjtJQUNGO0lBQ0EsQ0FBQ3JCLDhEQUFpQkEsQ0FBQztRQUNqQixPQUFPLElBQUksQ0FBQ0MsTUFBTTtJQUNwQjtJQUNBcUIsSUFBR0MsSUFBSTtRQUNMLE9BQU9BO0lBQ1Q7SUFDQUMsU0FBUUQsSUFBSTtRQUNWLE9BQU9FLEtBQUssSUFBSSxFQUFFRjtJQUNwQjtBQUNGLEVBQUU7QUFDSyxNQUFNRyxpQkFBaUI7SUFDNUIsR0FBR2IsUUFBUTtJQUNYLENBQUNILGdCQUFn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TUFBTSxDQUFDNUUsSUFBSVosR0FBRztRQUN2QjtRQUNBLE9BQU82QyxZQUFZd0M7SUFDckIsRUFBRSxDQUNGLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R3aXN0ZWQtY2FudGluYS8uL25vZGVfbW9kdWxlcy9lZmZlY3QvZGlzdC9lc20vaW50ZXJuYWwvY29udGV4dC5qcz9kZWVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuLi9FcXVhbC5qc1wiO1xuaW1wb3J0IHsgZHVhbCB9IGZyb20gXCIuLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVmFsdWUgfSBmcm9tIFwiLi4vR2xvYmFsVmFsdWUuanNcIjtcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSBcIi4uL0hhc2guanNcIjtcbmltcG9ydCB7IGZvcm1hdCwgTm9kZUluc3BlY3RTeW1ib2wsIHRvSlNPTiB9IGZyb20gXCIuLi9JbnNwZWN0YWJsZS5qc1wiO1xuaW1wb3J0IHsgcGlwZUFyZ3VtZW50cyB9IGZyb20gXCIuLi9QaXBlYWJsZS5qc1wiO1xuaW1wb3J0IHsgaGFzUHJvcGVydHkgfSBmcm9tIFwiLi4vUHJlZGljYXRlLmpzXCI7XG5pbXBvcnQgeyBFZmZlY3RQcm90b3R5cGUsIGVmZmVjdFZhcmlhbmNlIH0gZnJvbSBcIi4vZWZmZWN0YWJsZS5qc1wiO1xuaW1wb3J0ICogYXMgb3B0aW9uIGZyb20gXCIuL29wdGlvbi5qc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFRhZ1R5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L0NvbnRleHQvVGFnXCIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFJlZmVyZW5jZVR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L0NvbnRleHQvUmVmZXJlbmNlXCIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgU1RNU3ltYm9sS2V5ID0gXCJlZmZlY3QvU1RNXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgU1RNVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoU1RNU3ltYm9sS2V5KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBUYWdQcm90byA9IHtcbiAgLi4uRWZmZWN0UHJvdG90eXBlLFxuICBfb3A6IFwiVGFnXCIsXG4gIFtTVE1UeXBlSWRdOiBlZmZlY3RWYXJpYW5jZSxcbiAgW1RhZ1R5cGVJZF06IHtcbiAgICBfU2VydmljZTogXyA9PiBfLFxuICAgIF9JZGVudGlmaWVyOiBfID0+IF9cbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiVGFnXCIsXG4gICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICB9O1xuICB9LFxuICBbTm9kZUluc3BlY3RTeW1ib2xdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICBvZihzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIGNvbnRleHQoc2VsZikge1xuICAgIHJldHVybiBtYWtlKHRoaXMsIHNlbGYpO1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IFJlZmVyZW5jZVByb3RvID0ge1xuICAuLi5UYWdQcm90byxcbiAgW1JlZmVyZW5jZVR5cGVJZF06IFJlZmVyZW5jZVR5cGVJZFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBtYWtlR2VuZXJpY1RhZyA9IGtleSA9PiB7XG4gIGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAyO1xuICBjb25zdCBjcmVhdGlvbkVycm9yID0gbmV3IEVycm9yKCk7XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICBjb25zdCB0YWcgPSBPYmplY3QuY3JlYXRlKFRhZ1Byb3RvKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhZywgXCJzdGFja1wiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGNyZWF0aW9uRXJyb3Iuc3RhY2s7XG4gICAgfVxuICB9KTtcbiAgdGFnLmtleSA9IGtleTtcbiAgcmV0dXJuIHRhZztcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgVGFnID0gaWQgPT4gKCkgPT4ge1xuICBjb25zdCBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMjtcbiAgY29uc3QgY3JlYXRpb25FcnJvciA9IG5ldyBFcnJvcigpO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgZnVuY3Rpb24gVGFnQ2xhc3MoKSB7fVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoVGFnQ2xhc3MsIFRhZ1Byb3RvKTtcbiAgVGFnQ2xhc3Mua2V5ID0gaWQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWdDbGFzcywgXCJzdGFja1wiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGNyZWF0aW9uRXJyb3Iuc3RhY2s7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFRhZ0NsYXNzO1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBSZWZlcmVuY2UgPSAoKSA9PiAoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDI7XG4gIGNvbnN0IGNyZWF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gIGZ1bmN0aW9uIFJlZmVyZW5jZUNsYXNzKCkge31cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFJlZmVyZW5jZUNsYXNzLCBSZWZlcmVuY2VQcm90byk7XG4gIFJlZmVyZW5jZUNsYXNzLmtleSA9IGlkO1xuICBSZWZlcmVuY2VDbGFzcy5kZWZhdWx0VmFsdWUgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZUNsYXNzLCBcInN0YWNrXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRpb25FcnJvci5zdGFjaztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVmZXJlbmNlQ2xhc3M7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L0NvbnRleHRcIik7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgQ29udGV4dFByb3RvID0ge1xuICBbVHlwZUlkXToge1xuICAgIF9TZXJ2aWNlczogXyA9PiBfXG4gIH0sXG4gIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICBpZiAoaXNDb250ZXh0KHRoYXQpKSB7XG4gICAgICBpZiAodGhpcy51bnNhZmVNYXAuc2l6ZSA9PT0gdGhhdC51bnNhZmVNYXAuc2l6ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdGhpcy51bnNhZmVNYXAua2V5cygpKSB7XG4gICAgICAgICAgaWYgKCF0aGF0LnVuc2FmZU1hcC5oYXMoaykgfHwgIUVxdWFsLmVxdWFscyh0aGlzLnVuc2FmZU1hcC5nZXQoayksIHRoYXQudW5zYWZlTWFwLmdldChrKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgW0hhc2guc3ltYm9sXSgpIHtcbiAgICByZXR1cm4gSGFzaC5jYWNoZWQodGhpcywgSGFzaC5udW1iZXIodGhpcy51bnNhZmVNYXAuc2l6ZSkpO1xuICB9LFxuICBwaXBlKCkge1xuICAgIHJldHVybiBwaXBlQXJndW1lbnRzKHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy50b0pTT04oKSk7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIkNvbnRleHRcIixcbiAgICAgIHNlcnZpY2VzOiBBcnJheS5mcm9tKHRoaXMudW5zYWZlTWFwKS5tYXAodG9KU09OKVxuICAgIH07XG4gIH0sXG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCk7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWFrZUNvbnRleHQgPSB1bnNhZmVNYXAgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShDb250ZXh0UHJvdG8pO1xuICBjb250ZXh0LnVuc2FmZU1hcCA9IHVuc2FmZU1hcDtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuY29uc3Qgc2VydmljZU5vdEZvdW5kRXJyb3IgPSB0YWcgPT4ge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgU2VydmljZSBub3QgZm91bmQke3RhZy5rZXkgPyBgOiAke1N0cmluZyh0YWcua2V5KX1gIDogXCJcIn1gKTtcbiAgaWYgKHRhZy5zdGFjaykge1xuICAgIGNvbnN0IGxpbmVzID0gdGFnLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zdCBhZnRlckF0ID0gbGluZXNbMl0ubWF0Y2goL2F0ICguKikvKTtcbiAgICAgIGlmIChhZnRlckF0KSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlICsgYCAoZGVmaW5lZCBhdCAke2FmdGVyQXRbMV19KWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChlcnJvci5zdGFjaykge1xuICAgIGNvbnN0IGxpbmVzID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgbGluZXMuc3BsaWNlKDEsIDMpO1xuICAgIGVycm9yLnN0YWNrID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGlzQ29udGV4dCA9IHUgPT4gaGFzUHJvcGVydHkodSwgVHlwZUlkKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc1RhZyA9IHUgPT4gaGFzUHJvcGVydHkodSwgVGFnVHlwZUlkKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc1JlZmVyZW5jZSA9IHUgPT4gaGFzUHJvcGVydHkodSwgUmVmZXJlbmNlVHlwZUlkKTtcbmNvbnN0IF9lbXB0eSA9IC8qI19fUFVSRV9fKi9tYWtlQ29udGV4dCggLyojX19QVVJFX18qL25ldyBNYXAoKSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZW1wdHkgPSAoKSA9PiBfZW1wdHk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWFrZSA9ICh0YWcsIHNlcnZpY2UpID0+IG1ha2VDb250ZXh0KG5ldyBNYXAoW1t0YWcua2V5LCBzZXJ2aWNlXV0pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBhZGQgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGFnLCBzZXJ2aWNlKSA9PiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoc2VsZi51bnNhZmVNYXApO1xuICBtYXAuc2V0KHRhZy5rZXksIHNlcnZpY2UpO1xuICByZXR1cm4gbWFrZUNvbnRleHQobWFwKTtcbn0pO1xuY29uc3QgZGVmYXVsdFZhbHVlQ2FjaGUgPSAvKiNfX1BVUkVfXyovZ2xvYmFsVmFsdWUoXCJlZmZlY3QvQ29udGV4dC9kZWZhdWx0VmFsdWVDYWNoZVwiLCAoKSA9PiBuZXcgTWFwKCkpO1xuY29uc3QgZ2V0RGVmYXVsdFZhbHVlID0gdGFnID0+IHtcbiAgaWYgKGRlZmF1bHRWYWx1ZUNhY2hlLmhhcyh0YWcua2V5KSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWVDYWNoZS5nZXQodGFnLmtleSk7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSB0YWcuZGVmYXVsdFZhbHVlKCk7XG4gIGRlZmF1bHRWYWx1ZUNhY2hlLnNldCh0YWcua2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdW5zYWZlR2V0UmVmZXJlbmNlID0gKHNlbGYsIHRhZykgPT4ge1xuICByZXR1cm4gc2VsZi51bnNhZmVNYXAuaGFzKHRhZy5rZXkpID8gc2VsZi51bnNhZmVNYXAuZ2V0KHRhZy5rZXkpIDogZ2V0RGVmYXVsdFZhbHVlKHRhZyk7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUdldCA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0YWcpID0+IHtcbiAgaWYgKCFzZWxmLnVuc2FmZU1hcC5oYXModGFnLmtleSkpIHtcbiAgICBpZiAoUmVmZXJlbmNlVHlwZUlkIGluIHRhZykgcmV0dXJuIGdldERlZmF1bHRWYWx1ZSh0YWcpO1xuICAgIHRocm93IHNlcnZpY2VOb3RGb3VuZEVycm9yKHRhZyk7XG4gIH1cbiAgcmV0dXJuIHNlbGYudW5zYWZlTWFwLmdldCh0YWcua2V5KTtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGdldCA9IHVuc2FmZUdldDtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSAvKiNfX1BVUkVfXyovZHVhbCgzLCAoc2VsZiwgdGFnLCBvckVsc2UpID0+IHtcbiAgaWYgKCFzZWxmLnVuc2FmZU1hcC5oYXModGFnLmtleSkpIHtcbiAgICByZXR1cm4gaXNSZWZlcmVuY2UodGFnKSA/IGdldERlZmF1bHRWYWx1ZSh0YWcpIDogb3JFbHNlKCk7XG4gIH1cbiAgcmV0dXJuIHNlbGYudW5zYWZlTWFwLmdldCh0YWcua2V5KTtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGdldE9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCB0YWcpID0+IHtcbiAgaWYgKCFzZWxmLnVuc2FmZU1hcC5oYXModGFnLmtleSkpIHtcbiAgICByZXR1cm4gaXNSZWZlcmVuY2UodGFnKSA/IG9wdGlvbi5zb21lKGdldERlZmF1bHRWYWx1ZSh0YWcpKSA6IG9wdGlvbi5ub25lO1xuICB9XG4gIHJldHVybiBvcHRpb24uc29tZShzZWxmLnVuc2FmZU1hcC5nZXQodGFnLmtleSkpO1xufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWVyZ2UgPSAvKiNfX1BVUkVfXyovZHVhbCgyLCAoc2VsZiwgdGhhdCkgPT4ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKHNlbGYudW5zYWZlTWFwKTtcbiAgZm9yIChjb25zdCBbdGFnLCBzXSBvZiB0aGF0LnVuc2FmZU1hcCkge1xuICAgIG1hcC5zZXQodGFnLCBzKTtcbiAgfVxuICByZXR1cm4gbWFrZUNvbnRleHQobWFwKTtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlQWxsID0gKC4uLmN0eHMpID0+IHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGN0eCBvZiBjdHhzKSB7XG4gICAgZm9yIChjb25zdCBbdGFnLCBzXSBvZiBjdHgudW5zYWZlTWFwKSB7XG4gICAgICBtYXAuc2V0KHRhZywgcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYWtlQ29udGV4dChtYXApO1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwaWNrID0gKC4uLnRhZ3MpID0+IHNlbGYgPT4ge1xuICBjb25zdCB0YWdTZXQgPSBuZXcgU2V0KHRhZ3MubWFwKF8gPT4gXy5rZXkpKTtcbiAgY29uc3QgbmV3RW52ID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IFt0YWcsIHNdIG9mIHNlbGYudW5zYWZlTWFwLmVudHJpZXMoKSkge1xuICAgIGlmICh0YWdTZXQuaGFzKHRhZykpIHtcbiAgICAgIG5ld0Vudi5zZXQodGFnLCBzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1ha2VDb250ZXh0KG5ld0Vudik7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG9taXQgPSAoLi4udGFncykgPT4gc2VsZiA9PiB7XG4gIGNvbnN0IG5ld0VudiA9IG5ldyBNYXAoc2VsZi51bnNhZmVNYXApO1xuICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgbmV3RW52LmRlbGV0ZSh0YWcua2V5KTtcbiAgfVxuICByZXR1cm4gbWFrZUNvbnRleHQobmV3RW52KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJFcXVhbCIsImR1YWwiLCJnbG9iYWxWYWx1ZSIsIkhhc2giLCJmb3JtYXQiLCJOb2RlSW5zcGVjdFN5bWJvbCIsInRvSlNPTiIsInBpcGVBcmd1bWVudHMiLCJoYXNQcm9wZXJ0eSIsIkVmZmVjdFByb3RvdHlwZSIsImVmZmVjdFZhcmlhbmNlIiwib3B0aW9uIiwiVGFnVHlwZUlkIiwiU3ltYm9sIiwiZm9yIiwiUmVmZXJlbmNlVHlwZUlkIiwiU1RNU3ltYm9sS2V5IiwiU1RNVHlwZUlkIiwiVGFnUHJvdG8iLCJfb3AiLCJfU2VydmljZSIsIl8iLCJfSWRlbnRpZmllciIsInRvU3RyaW5nIiwiX2lkIiwia2V5Iiwic3RhY2siLCJvZiIsInNlbGYiLCJjb250ZXh0IiwibWFrZSIsIlJlZmVyZW5jZVByb3RvIiwibWFrZUdlbmVyaWNUYWciLCJsaW1pdCIsIkVycm9yIiwic3RhY2tUcmFjZUxpbWl0IiwiY3JlYXRpb25FcnJvciIsInRhZyIsIk9iamVjdCIsImNyZWF0ZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiVGFnIiwiaWQiLCJUYWdDbGFzcyIsInNldFByb3RvdHlwZU9mIiwiUmVmZXJlbmNlIiwib3B0aW9ucyIsIlJlZmVyZW5jZUNsYXNzIiwiZGVmYXVsdFZhbHVlIiwiVHlwZUlkIiwiQ29udGV4dFByb3RvIiwiX1NlcnZpY2VzIiwic3ltYm9sIiwidGhhdCIsImlzQ29udGV4dCIsInVuc2FmZU1hcCIsInNpemUiLCJrIiwia2V5cyIsImhhcyIsImVxdWFscyIsImNhY2hlZCIsIm51bWJlciIsInBpcGUiLCJhcmd1bWVudHMiLCJzZXJ2aWNlcyIsIkFycmF5IiwiZnJvbSIsIm1hcCIsIm1ha2VDb250ZXh0Iiwic2VydmljZU5vdEZvdW5kRXJyb3IiLCJlcnJvciIsIlN0cmluZyIsImxpbmVzIiwic3BsaXQiLCJsZW5ndGgiLCJhZnRlckF0IiwibWF0Y2giLCJtZXNzYWdlIiwic3BsaWNlIiwiam9pbiIsInUiLCJpc1RhZyIsImlzUmVmZXJlbmNlIiwiX2VtcHR5IiwiTWFwIiwiZW1wdHkiLCJzZXJ2aWNlIiwiYWRkIiwic2V0IiwiZGVmYXVsdFZhbHVlQ2FjaGUiLCJnZXREZWZhdWx0VmFsdWUiLCJ2YWx1ZSIsInVuc2FmZUdldFJlZmVyZW5jZSIsInVuc2FmZUdldCIsImdldE9yRWxzZSIsIm9yRWxzZSIsImdldE9wdGlvbiIsInNvbWUiLCJub25lIiwibWVyZ2UiLCJzIiwibWVyZ2VBbGwiLCJjdHhzIiwiY3R4IiwicGljayIsInRhZ3MiLCJ0YWdTZXQiLCJTZXQiLCJuZXdFbnYiLCJlbnRyaWVzIiwib21pdCIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js":
/*!*************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/doNotation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   bindTo: () => (/* binding */ bindTo),\n/* harmony export */   let_: () => (/* binding */ let_)\n/* harmony export */ });\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n\n/** @internal */ const let_ = (map)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, name, f)=>map(self, (a)=>Object.assign({}, a, {\n                [name]: f(a)\n            })));\n/** @internal */ const bindTo = (map)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(2, (self, name)=>map(self, (a)=>({\n                [name]: a\n            })));\n/** @internal */ const bind = (map, flatMap)=>(0,_Function_js__WEBPACK_IMPORTED_MODULE_0__.dual)(3, (self, name, f)=>flatMap(self, (a)=>map(f(a), (b)=>Object.assign({}, a, {\n                    [name]: b\n                })))); //# sourceMappingURL=doNotation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2RvTm90YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUN0QyxjQUFjLEdBQ1AsTUFBTUMsT0FBT0MsQ0FBQUEsTUFBT0Ysa0RBQUlBLENBQUMsR0FBRyxDQUFDRyxNQUFNQyxNQUFNQyxJQUFNSCxJQUFJQyxNQUFNRyxDQUFBQSxJQUFLQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHRixHQUFHO2dCQUN4RixDQUFDRixLQUFLLEVBQUVDLEVBQUVDO1lBQ1osS0FBSztBQUNMLGNBQWMsR0FDUCxNQUFNRyxTQUFTUCxDQUFBQSxNQUFPRixrREFBSUEsQ0FBQyxHQUFHLENBQUNHLE1BQU1DLE9BQVNGLElBQUlDLE1BQU1HLENBQUFBLElBQU07Z0JBQ25FLENBQUNGLEtBQUssRUFBRUU7WUFDVixLQUFLO0FBQ0wsY0FBYyxHQUNQLE1BQU1JLE9BQU8sQ0FBQ1IsS0FBS1MsVUFBWVgsa0RBQUlBLENBQUMsR0FBRyxDQUFDRyxNQUFNQyxNQUFNQyxJQUFNTSxRQUFRUixNQUFNRyxDQUFBQSxJQUFLSixJQUFJRyxFQUFFQyxJQUFJTSxDQUFBQSxJQUFLTCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHRixHQUFHO29CQUN0SCxDQUFDRixLQUFLLEVBQUVRO2dCQUNWLE1BQU0sQ0FDTixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2RvTm90YXRpb24uanM/NTUyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkdWFsIH0gZnJvbSBcIi4uL0Z1bmN0aW9uLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbGV0XyA9IG1hcCA9PiBkdWFsKDMsIChzZWxmLCBuYW1lLCBmKSA9PiBtYXAoc2VsZiwgYSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCB7XG4gIFtuYW1lXTogZihhKVxufSkpKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBiaW5kVG8gPSBtYXAgPT4gZHVhbCgyLCAoc2VsZiwgbmFtZSkgPT4gbWFwKHNlbGYsIGEgPT4gKHtcbiAgW25hbWVdOiBhXG59KSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGJpbmQgPSAobWFwLCBmbGF0TWFwKSA9PiBkdWFsKDMsIChzZWxmLCBuYW1lLCBmKSA9PiBmbGF0TWFwKHNlbGYsIGEgPT4gbWFwKGYoYSksIGIgPT4gT2JqZWN0LmFzc2lnbih7fSwgYSwge1xuICBbbmFtZV06IGJcbn0pKSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9Ob3RhdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiZHVhbCIsImxldF8iLCJtYXAiLCJzZWxmIiwibmFtZSIsImYiLCJhIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZFRvIiwiYmluZCIsImZsYXRNYXAiLCJiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/doNotation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/effectable.js":
/*!*************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/effectable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base: () => (/* binding */ Base),\n/* harmony export */   ChannelTypeId: () => (/* binding */ ChannelTypeId),\n/* harmony export */   CommitPrototype: () => (/* binding */ CommitPrototype),\n/* harmony export */   EffectPrototype: () => (/* binding */ EffectPrototype),\n/* harmony export */   EffectTypeId: () => (/* binding */ EffectTypeId),\n/* harmony export */   SinkTypeId: () => (/* binding */ SinkTypeId),\n/* harmony export */   StreamTypeId: () => (/* binding */ StreamTypeId),\n/* harmony export */   StructuralBase: () => (/* binding */ StructuralBase),\n/* harmony export */   StructuralCommitPrototype: () => (/* binding */ StructuralCommitPrototype),\n/* harmony export */   StructuralPrototype: () => (/* binding */ StructuralPrototype),\n/* harmony export */   effectVariance: () => (/* binding */ effectVariance)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Utils.js */ \"(ssr)/./node_modules/effect/dist/esm/Utils.js\");\n/* harmony import */ var _opCodes_effect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./opCodes/effect.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/opCodes/effect.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/version.js\");\n\n\n\n\n\n\n/** @internal */ const EffectTypeId = /*#__PURE__*/ Symbol.for(\"effect/Effect\");\n/** @internal */ const StreamTypeId = /*#__PURE__*/ Symbol.for(\"effect/Stream\");\n/** @internal */ const SinkTypeId = /*#__PURE__*/ Symbol.for(\"effect/Sink\");\n/** @internal */ const ChannelTypeId = /*#__PURE__*/ Symbol.for(\"effect/Channel\");\n/** @internal */ const effectVariance = {\n    /* c8 ignore next */ _R: (_)=>_,\n    /* c8 ignore next */ _E: (_)=>_,\n    /* c8 ignore next */ _A: (_)=>_,\n    _V: /*#__PURE__*/ _version_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentVersion()\n};\nconst sinkVariance = {\n    /* c8 ignore next */ _A: (_)=>_,\n    /* c8 ignore next */ _In: (_)=>_,\n    /* c8 ignore next */ _L: (_)=>_,\n    /* c8 ignore next */ _E: (_)=>_,\n    /* c8 ignore next */ _R: (_)=>_\n};\nconst channelVariance = {\n    /* c8 ignore next */ _Env: (_)=>_,\n    /* c8 ignore next */ _InErr: (_)=>_,\n    /* c8 ignore next */ _InElem: (_)=>_,\n    /* c8 ignore next */ _InDone: (_)=>_,\n    /* c8 ignore next */ _OutErr: (_)=>_,\n    /* c8 ignore next */ _OutElem: (_)=>_,\n    /* c8 ignore next */ _OutDone: (_)=>_\n};\n/** @internal */ const EffectPrototype = {\n    [EffectTypeId]: effectVariance,\n    [StreamTypeId]: effectVariance,\n    [SinkTypeId]: sinkVariance,\n    [ChannelTypeId]: channelVariance,\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_1__.symbol] (that) {\n        return this === that;\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_2__.symbol] () {\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_2__.random(this));\n    },\n    [Symbol.iterator] () {\n        return new _Utils_js__WEBPACK_IMPORTED_MODULE_3__.SingleShotGen(new _Utils_js__WEBPACK_IMPORTED_MODULE_3__.YieldWrap(this));\n    },\n    pipe () {\n        return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_4__.pipeArguments)(this, arguments);\n    }\n};\n/** @internal */ const StructuralPrototype = {\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_2__.symbol] () {\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_2__.structure(this));\n    },\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_1__.symbol] (that) {\n        const selfKeys = Object.keys(this);\n        const thatKeys = Object.keys(that);\n        if (selfKeys.length !== thatKeys.length) {\n            return false;\n        }\n        for (const key of selfKeys){\n            if (!(key in that && _Equal_js__WEBPACK_IMPORTED_MODULE_1__.equals(this[key], that[key]))) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n/** @internal */ const CommitPrototype = {\n    ...EffectPrototype,\n    _op: _opCodes_effect_js__WEBPACK_IMPORTED_MODULE_5__.OP_COMMIT\n};\n/** @internal */ const StructuralCommitPrototype = {\n    ...CommitPrototype,\n    ...StructuralPrototype\n};\n/** @internal */ const Base = /*#__PURE__*/ function() {\n    function Base() {}\n    Base.prototype = CommitPrototype;\n    return Base;\n}();\n/** @internal */ const StructuralBase = /*#__PURE__*/ function() {\n    function Base() {}\n    Base.prototype = StructuralCommitPrototype;\n    return Base;\n}(); //# sourceMappingURL=effectable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VmZmVjdGFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRjtBQUNZO0FBQ1E7QUFDUjtBQUNQO0FBQ3hDLGNBQWMsR0FDUCxNQUFNTyxlQUFlLFdBQVcsR0FBRUMsT0FBT0MsR0FBRyxDQUFDLGlCQUFpQjtBQUNyRSxjQUFjLEdBQ1AsTUFBTUMsZUFBZSxXQUFXLEdBQUVGLE9BQU9DLEdBQUcsQ0FBQyxpQkFBaUI7QUFDckUsY0FBYyxHQUNQLE1BQU1FLGFBQWEsV0FBVyxHQUFFSCxPQUFPQyxHQUFHLENBQUMsZUFBZTtBQUNqRSxjQUFjLEdBQ1AsTUFBTUcsZ0JBQWdCLFdBQVcsR0FBRUosT0FBT0MsR0FBRyxDQUFDLGtCQUFrQjtBQUN2RSxjQUFjLEdBQ1AsTUFBTUksaUJBQWlCO0lBQzVCLGtCQUFrQixHQUNsQkMsSUFBSUMsQ0FBQUEsSUFBS0E7SUFDVCxrQkFBa0IsR0FDbEJDLElBQUlELENBQUFBLElBQUtBO0lBQ1Qsa0JBQWtCLEdBQ2xCRSxJQUFJRixDQUFBQSxJQUFLQTtJQUNURyxJQUFJLFdBQVcsR0FBRVosMERBQXlCO0FBQzVDLEVBQUU7QUFDRixNQUFNYyxlQUFlO0lBQ25CLGtCQUFrQixHQUNsQkgsSUFBSUYsQ0FBQUEsSUFBS0E7SUFDVCxrQkFBa0IsR0FDbEJNLEtBQUtOLENBQUFBLElBQUtBO0lBQ1Ysa0JBQWtCLEdBQ2xCTyxJQUFJUCxDQUFBQSxJQUFLQTtJQUNULGtCQUFrQixHQUNsQkMsSUFBSUQsQ0FBQUEsSUFBS0E7SUFDVCxrQkFBa0IsR0FDbEJELElBQUlDLENBQUFBLElBQUtBO0FBQ1g7QUFDQSxNQUFNUSxrQkFBa0I7SUFDdEIsa0JBQWtCLEdBQ2xCQyxNQUFNVCxDQUFBQSxJQUFLQTtJQUNYLGtCQUFrQixHQUNsQlUsUUFBUVYsQ0FBQUEsSUFBS0E7SUFDYixrQkFBa0IsR0FDbEJXLFNBQVNYLENBQUFBLElBQUtBO0lBQ2Qsa0JBQWtCLEdBQ2xCWSxTQUFTWixDQUFBQSxJQUFLQTtJQUNkLGtCQUFrQixHQUNsQmEsU0FBU2IsQ0FBQUEsSUFBS0E7SUFDZCxrQkFBa0IsR0FDbEJjLFVBQVVkLENBQUFBLElBQUtBO0lBQ2Ysa0JBQWtCLEdBQ2xCZSxVQUFVZixDQUFBQSxJQUFLQTtBQUNqQjtBQUNBLGNBQWMsR0FDUCxNQUFNZ0Isa0JBQWtCO0lBQzdCLENBQUN4QixhQUFhLEVBQUVNO0lBQ2hCLENBQUNILGFBQWEsRUFBRUc7SUFDaEIsQ0FBQ0YsV0FBVyxFQUFFUztJQUNkLENBQUNSLGNBQWMsRUFBRVc7SUFDakIsQ0FBQ3ZCLDZDQUFZLENBQUMsRUFBQ2lDLElBQUk7UUFDakIsT0FBTyxJQUFJLEtBQUtBO0lBQ2xCO0lBQ0EsQ0FBQ2hDLDRDQUFXLENBQUM7UUFDWCxPQUFPQSw0Q0FBVyxDQUFDLElBQUksRUFBRUEsNENBQVcsQ0FBQyxJQUFJO0lBQzNDO0lBQ0EsQ0FBQ08sT0FBTzRCLFFBQVEsQ0FBQztRQUNmLE9BQU8sSUFBSWpDLG9EQUFhQSxDQUFDLElBQUlDLGdEQUFTQSxDQUFDLElBQUk7SUFDN0M7SUFDQWlDO1FBQ0UsT0FBT25DLDJEQUFhQSxDQUFDLElBQUksRUFBRW9DO0lBQzdCO0FBQ0YsRUFBRTtBQUNGLGNBQWMsR0FDUCxNQUFNQyxzQkFBc0I7SUFDakMsQ0FBQ3RDLDRDQUFXLENBQUM7UUFDWCxPQUFPQSw0Q0FBVyxDQUFDLElBQUksRUFBRUEsK0NBQWMsQ0FBQyxJQUFJO0lBQzlDO0lBQ0EsQ0FBQ0QsNkNBQVksQ0FBQyxFQUFDaUMsSUFBSTtRQUNqQixNQUFNUSxXQUFXQyxPQUFPQyxJQUFJLENBQUMsSUFBSTtRQUNqQyxNQUFNQyxXQUFXRixPQUFPQyxJQUFJLENBQUNWO1FBQzdCLElBQUlRLFNBQVNJLE1BQU0sS0FBS0QsU0FBU0MsTUFBTSxFQUFFO1lBQ3ZDLE9BQU87UUFDVDtRQUNBLEtBQUssTUFBTUMsT0FBT0wsU0FBVTtZQUMxQixJQUFJLENBQUVLLENBQUFBLE9BQU9iLFFBQVFqQyw2Q0FBWSxDQUFDLElBQUksQ0FBQzhDLElBQUksRUFBRWIsSUFBSSxDQUFDYSxJQUFJLElBQUk7Z0JBQ3hELE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0FBQ0YsRUFBRTtBQUNGLGNBQWMsR0FDUCxNQUFNRSxrQkFBa0I7SUFDN0IsR0FBR2pCLGVBQWU7SUFDbEJrQixLQUFLNUMseURBQWlCO0FBQ3hCLEVBQUU7QUFDRixjQUFjLEdBQ1AsTUFBTThDLDRCQUE0QjtJQUN2QyxHQUFHSCxlQUFlO0lBQ2xCLEdBQUdULG1CQUFtQjtBQUN4QixFQUFFO0FBQ0YsY0FBYyxHQUNQLE1BQU1hLE9BQU8sV0FBVyxHQUFFO0lBQy9CLFNBQVNBLFFBQVE7SUFDakJBLEtBQUtDLFNBQVMsR0FBR0w7SUFDakIsT0FBT0k7QUFDVCxJQUFJO0FBQ0osY0FBYyxHQUNQLE1BQU1FLGlCQUFpQixXQUFXLEdBQUU7SUFDekMsU0FBU0YsUUFBUTtJQUNqQkEsS0FBS0MsU0FBUyxHQUFHRjtJQUNqQixPQUFPQztBQUNULElBQUksQ0FDSixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VmZmVjdGFibGUuanM/M2RiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcXVhbCBmcm9tIFwiLi4vRXF1YWwuanNcIjtcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSBcIi4uL0hhc2guanNcIjtcbmltcG9ydCB7IHBpcGVBcmd1bWVudHMgfSBmcm9tIFwiLi4vUGlwZWFibGUuanNcIjtcbmltcG9ydCB7IFNpbmdsZVNob3RHZW4sIFlpZWxkV3JhcCB9IGZyb20gXCIuLi9VdGlscy5qc1wiO1xuaW1wb3J0ICogYXMgT3BDb2RlcyBmcm9tIFwiLi9vcENvZGVzL2VmZmVjdC5qc1wiO1xuaW1wb3J0ICogYXMgdmVyc2lvbiBmcm9tIFwiLi92ZXJzaW9uLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgRWZmZWN0VHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvRWZmZWN0XCIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFN0cmVhbVR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L1N0cmVhbVwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBTaW5rVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvU2lua1wiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBDaGFubmVsVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvQ2hhbm5lbFwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBlZmZlY3RWYXJpYW5jZSA9IHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX1I6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0U6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX0E6IF8gPT4gXyxcbiAgX1Y6IC8qI19fUFVSRV9fKi92ZXJzaW9uLmdldEN1cnJlbnRWZXJzaW9uKClcbn07XG5jb25zdCBzaW5rVmFyaWFuY2UgPSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9BOiBfID0+IF8sXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9JbjogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfTDogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfRTogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfUjogXyA9PiBfXG59O1xuY29uc3QgY2hhbm5lbFZhcmlhbmNlID0ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfRW52OiBfID0+IF8sXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9JbkVycjogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfSW5FbGVtOiBfID0+IF8sXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIF9JbkRvbmU6IF8gPT4gXyxcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgX091dEVycjogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0RWxlbTogXyA9PiBfLFxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBfT3V0RG9uZTogXyA9PiBfXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IEVmZmVjdFByb3RvdHlwZSA9IHtcbiAgW0VmZmVjdFR5cGVJZF06IGVmZmVjdFZhcmlhbmNlLFxuICBbU3RyZWFtVHlwZUlkXTogZWZmZWN0VmFyaWFuY2UsXG4gIFtTaW5rVHlwZUlkXTogc2lua1ZhcmlhbmNlLFxuICBbQ2hhbm5lbFR5cGVJZF06IGNoYW5uZWxWYXJpYW5jZSxcbiAgW0VxdWFsLnN5bWJvbF0odGhhdCkge1xuICAgIHJldHVybiB0aGlzID09PSB0aGF0O1xuICB9LFxuICBbSGFzaC5zeW1ib2xdKCkge1xuICAgIHJldHVybiBIYXNoLmNhY2hlZCh0aGlzLCBIYXNoLnJhbmRvbSh0aGlzKSk7XG4gIH0sXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgU2luZ2xlU2hvdEdlbihuZXcgWWllbGRXcmFwKHRoaXMpKTtcbiAgfSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gcGlwZUFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFN0cnVjdHVyYWxQcm90b3R5cGUgPSB7XG4gIFtIYXNoLnN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIEhhc2guY2FjaGVkKHRoaXMsIEhhc2guc3RydWN0dXJlKHRoaXMpKTtcbiAgfSxcbiAgW0VxdWFsLnN5bWJvbF0odGhhdCkge1xuICAgIGNvbnN0IHNlbGZLZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgY29uc3QgdGhhdEtleXMgPSBPYmplY3Qua2V5cyh0aGF0KTtcbiAgICBpZiAoc2VsZktleXMubGVuZ3RoICE9PSB0aGF0S2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2VsZktleXMpIHtcbiAgICAgIGlmICghKGtleSBpbiB0aGF0ICYmIEVxdWFsLmVxdWFscyh0aGlzW2tleV0sIHRoYXRba2V5XSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgQ29tbWl0UHJvdG90eXBlID0ge1xuICAuLi5FZmZlY3RQcm90b3R5cGUsXG4gIF9vcDogT3BDb2Rlcy5PUF9DT01NSVRcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgU3RydWN0dXJhbENvbW1pdFByb3RvdHlwZSA9IHtcbiAgLi4uQ29tbWl0UHJvdG90eXBlLFxuICAuLi5TdHJ1Y3R1cmFsUHJvdG90eXBlXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IEJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlKCkge31cbiAgQmFzZS5wcm90b3R5cGUgPSBDb21taXRQcm90b3R5cGU7XG4gIHJldHVybiBCYXNlO1xufSgpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFN0cnVjdHVyYWxCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZSgpIHt9XG4gIEJhc2UucHJvdG90eXBlID0gU3RydWN0dXJhbENvbW1pdFByb3RvdHlwZTtcbiAgcmV0dXJuIEJhc2U7XG59KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZmZlY3RhYmxlLmpzLm1hcCJdLCJuYW1lcyI6WyJFcXVhbCIsIkhhc2giLCJwaXBlQXJndW1lbnRzIiwiU2luZ2xlU2hvdEdlbiIsIllpZWxkV3JhcCIsIk9wQ29kZXMiLCJ2ZXJzaW9uIiwiRWZmZWN0VHlwZUlkIiwiU3ltYm9sIiwiZm9yIiwiU3RyZWFtVHlwZUlkIiwiU2lua1R5cGVJZCIsIkNoYW5uZWxUeXBlSWQiLCJlZmZlY3RWYXJpYW5jZSIsIl9SIiwiXyIsIl9FIiwiX0EiLCJfViIsImdldEN1cnJlbnRWZXJzaW9uIiwic2lua1ZhcmlhbmNlIiwiX0luIiwiX0wiLCJjaGFubmVsVmFyaWFuY2UiLCJfRW52IiwiX0luRXJyIiwiX0luRWxlbSIsIl9JbkRvbmUiLCJfT3V0RXJyIiwiX091dEVsZW0iLCJfT3V0RG9uZSIsIkVmZmVjdFByb3RvdHlwZSIsInN5bWJvbCIsInRoYXQiLCJjYWNoZWQiLCJyYW5kb20iLCJpdGVyYXRvciIsInBpcGUiLCJhcmd1bWVudHMiLCJTdHJ1Y3R1cmFsUHJvdG90eXBlIiwic3RydWN0dXJlIiwic2VsZktleXMiLCJPYmplY3QiLCJrZXlzIiwidGhhdEtleXMiLCJsZW5ndGgiLCJrZXkiLCJlcXVhbHMiLCJDb21taXRQcm90b3R5cGUiLCJfb3AiLCJPUF9DT01NSVQiLCJTdHJ1Y3R1cmFsQ29tbWl0UHJvdG90eXBlIiwiQmFzZSIsInByb3RvdHlwZSIsIlN0cnVjdHVyYWxCYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/either.js":
/*!*********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/either.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypeId: () => (/* binding */ TypeId),\n/* harmony export */   fromOption: () => (/* binding */ fromOption),\n/* harmony export */   getLeft: () => (/* binding */ getLeft),\n/* harmony export */   getRight: () => (/* binding */ getRight),\n/* harmony export */   isEither: () => (/* binding */ isEither),\n/* harmony export */   isLeft: () => (/* binding */ isLeft),\n/* harmony export */   isRight: () => (/* binding */ isRight),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   right: () => (/* binding */ right)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/* harmony import */ var _option_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./option.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/option.js\");\n/**\n * @since 2.0.0\n */ \n\n\n\n\n\n\n/**\n * @internal\n */ const TypeId = /*#__PURE__*/ Symbol.for(\"effect/Either\");\nconst CommonProto = {\n    ..._effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype,\n    [TypeId]: {\n        _R: (_)=>_\n    },\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol] () {\n        return this.toJSON();\n    },\n    toString () {\n        return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n    }\n};\nconst RightProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {\n    _tag: \"Right\",\n    _op: \"Right\",\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol] (that) {\n        return isEither(that) && isRight(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.right, that.right);\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol] () {\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this._tag))(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this.right));\n    },\n    toJSON () {\n        return {\n            _id: \"Either\",\n            _tag: this._tag,\n            right: (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(this.right)\n        };\n    }\n});\nconst LeftProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {\n    _tag: \"Left\",\n    _op: \"Left\",\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol] (that) {\n        return isEither(that) && isLeft(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.left, that.left);\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol] () {\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this._tag))(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this.left));\n    },\n    toJSON () {\n        return {\n            _id: \"Either\",\n            _tag: this._tag,\n            left: (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(this.left)\n        };\n    }\n});\n/** @internal */ const isEither = (input)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(input, TypeId);\n/** @internal */ const isLeft = (ma)=>ma._tag === \"Left\";\n/** @internal */ const isRight = (ma)=>ma._tag === \"Right\";\n/** @internal */ const left = (left)=>{\n    const a = Object.create(LeftProto);\n    a.left = left;\n    return a;\n};\n/** @internal */ const right = (right)=>{\n    const a = Object.create(RightProto);\n    a.right = right;\n    return a;\n};\n/** @internal */ const getLeft = (self)=>isRight(self) ? _option_js__WEBPACK_IMPORTED_MODULE_5__.none : _option_js__WEBPACK_IMPORTED_MODULE_5__.some(self.left);\n/** @internal */ const getRight = (self)=>isLeft(self) ? _option_js__WEBPACK_IMPORTED_MODULE_5__.none : _option_js__WEBPACK_IMPORTED_MODULE_5__.some(self.right);\n/** @internal */ const fromOption = /*#__PURE__*/ (0,_Function_js__WEBPACK_IMPORTED_MODULE_6__.dual)(2, (self, onNone)=>_option_js__WEBPACK_IMPORTED_MODULE_5__.isNone(self) ? left(onNone()) : right(self.value)); //# sourceMappingURL=either.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VpdGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDb0M7QUFDQztBQUNIO0FBQ21DO0FBQ3hCO0FBQ0k7QUFDWjtBQUN0Qzs7Q0FFQyxHQUNNLE1BQU1TLFNBQVMsV0FBVyxHQUFFQyxPQUFPQyxHQUFHLENBQUMsaUJBQWlCO0FBQy9ELE1BQU1DLGNBQWM7SUFDbEIsR0FBR0wsMkRBQWU7SUFDbEIsQ0FBQ0UsT0FBTyxFQUFFO1FBQ1JJLElBQUlDLENBQUFBLElBQUtBO0lBQ1g7SUFDQSxDQUFDViw4REFBaUJBLENBQUM7UUFDakIsT0FBTyxJQUFJLENBQUNDLE1BQU07SUFDcEI7SUFDQVU7UUFDRSxPQUFPWix1REFBTUEsQ0FBQyxJQUFJLENBQUNFLE1BQU07SUFDM0I7QUFDRjtBQUNBLE1BQU1XLGFBQWEsV0FBVyxHQUFFQyxPQUFPQyxNQUFNLENBQUUsV0FBVyxHQUFFRCxPQUFPRSxNQUFNLENBQUNQLGNBQWM7SUFDdEZRLE1BQU07SUFDTkMsS0FBSztJQUNMLENBQUNyQiw2Q0FBWSxDQUFDLEVBQUN1QixJQUFJO1FBQ2pCLE9BQU9DLFNBQVNELFNBQVNFLFFBQVFGLFNBQVN2Qiw2Q0FBWSxDQUFDLElBQUksQ0FBQzJCLEtBQUssRUFBRUosS0FBS0ksS0FBSztJQUMvRTtJQUNBLENBQUN6Qiw0Q0FBVyxDQUFDO1FBQ1gsT0FBT0EsNkNBQVksQ0FBQ0EsMENBQVMsQ0FBQyxJQUFJLENBQUNrQixJQUFJLEdBQUdsQiwwQ0FBUyxDQUFDLElBQUksQ0FBQ3lCLEtBQUs7SUFDaEU7SUFDQXRCO1FBQ0UsT0FBTztZQUNMeUIsS0FBSztZQUNMVixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmTyxPQUFPdEIsdURBQU1BLENBQUMsSUFBSSxDQUFDc0IsS0FBSztRQUMxQjtJQUNGO0FBQ0Y7QUFDQSxNQUFNSSxZQUFZLFdBQVcsR0FBRWQsT0FBT0MsTUFBTSxDQUFFLFdBQVcsR0FBRUQsT0FBT0UsTUFBTSxDQUFDUCxjQUFjO0lBQ3JGUSxNQUFNO0lBQ05DLEtBQUs7SUFDTCxDQUFDckIsNkNBQVksQ0FBQyxFQUFDdUIsSUFBSTtRQUNqQixPQUFPQyxTQUFTRCxTQUFTUyxPQUFPVCxTQUFTdkIsNkNBQVksQ0FBQyxJQUFJLENBQUNpQyxJQUFJLEVBQUVWLEtBQUtVLElBQUk7SUFDNUU7SUFDQSxDQUFDL0IsNENBQVcsQ0FBQztRQUNYLE9BQU9BLDZDQUFZLENBQUNBLDBDQUFTLENBQUMsSUFBSSxDQUFDa0IsSUFBSSxHQUFHbEIsMENBQVMsQ0FBQyxJQUFJLENBQUMrQixJQUFJO0lBQy9EO0lBQ0E1QjtRQUNFLE9BQU87WUFDTHlCLEtBQUs7WUFDTFYsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZmEsTUFBTTVCLHVEQUFNQSxDQUFDLElBQUksQ0FBQzRCLElBQUk7UUFDeEI7SUFDRjtBQUNGO0FBQ0EsY0FBYyxHQUNQLE1BQU1ULFdBQVdVLENBQUFBLFFBQVM1QiwwREFBV0EsQ0FBQzRCLE9BQU96QixRQUFRO0FBQzVELGNBQWMsR0FDUCxNQUFNdUIsU0FBU0csQ0FBQUEsS0FBTUEsR0FBR2YsSUFBSSxLQUFLLE9BQU87QUFDL0MsY0FBYyxHQUNQLE1BQU1LLFVBQVVVLENBQUFBLEtBQU1BLEdBQUdmLElBQUksS0FBSyxRQUFRO0FBQ2pELGNBQWMsR0FDUCxNQUFNYSxPQUFPQSxDQUFBQTtJQUNsQixNQUFNRyxJQUFJbkIsT0FBT0UsTUFBTSxDQUFDWTtJQUN4QkssRUFBRUgsSUFBSSxHQUFHQTtJQUNULE9BQU9HO0FBQ1QsRUFBRTtBQUNGLGNBQWMsR0FDUCxNQUFNVCxRQUFRQSxDQUFBQTtJQUNuQixNQUFNUyxJQUFJbkIsT0FBT0UsTUFBTSxDQUFDSDtJQUN4Qm9CLEVBQUVULEtBQUssR0FBR0E7SUFDVixPQUFPUztBQUNULEVBQUU7QUFDRixjQUFjLEdBQ1AsTUFBTUMsVUFBVUMsQ0FBQUEsT0FBUWIsUUFBUWEsUUFBUTlCLDRDQUFXLEdBQUdBLDRDQUFXLENBQUM4QixLQUFLTCxJQUFJLEVBQUU7QUFDcEYsY0FBYyxHQUNQLE1BQU1RLFdBQVdILENBQUFBLE9BQVFOLE9BQU9NLFFBQVE5Qiw0Q0FBVyxHQUFHQSw0Q0FBVyxDQUFDOEIsS0FBS1gsS0FBSyxFQUFFO0FBQ3JGLGNBQWMsR0FDUCxNQUFNZSxhQUFhLFdBQVcsR0FBRXpDLGtEQUFJQSxDQUFDLEdBQUcsQ0FBQ3FDLE1BQU1LLFNBQVduQyw4Q0FBYSxDQUFDOEIsUUFBUUwsS0FBS1UsWUFBWWhCLE1BQU1XLEtBQUtPLEtBQUssR0FBRyxDQUMzSCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VpdGhlci5qcz83YjBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuLi9FcXVhbC5qc1wiO1xuaW1wb3J0IHsgZHVhbCB9IGZyb20gXCIuLi9GdW5jdGlvbi5qc1wiO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tIFwiLi4vSGFzaC5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0LCBOb2RlSW5zcGVjdFN5bWJvbCwgdG9KU09OIH0gZnJvbSBcIi4uL0luc3BlY3RhYmxlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSB9IGZyb20gXCIuLi9QcmVkaWNhdGUuanNcIjtcbmltcG9ydCB7IEVmZmVjdFByb3RvdHlwZSB9IGZyb20gXCIuL2VmZmVjdGFibGUuanNcIjtcbmltcG9ydCAqIGFzIG9wdGlvbiBmcm9tIFwiLi9vcHRpb24uanNcIjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBUeXBlSWQgPSAvKiNfX1BVUkVfXyovU3ltYm9sLmZvcihcImVmZmVjdC9FaXRoZXJcIik7XG5jb25zdCBDb21tb25Qcm90byA9IHtcbiAgLi4uRWZmZWN0UHJvdG90eXBlLFxuICBbVHlwZUlkXToge1xuICAgIF9SOiBfID0+IF9cbiAgfSxcbiAgW05vZGVJbnNwZWN0U3ltYm9sXSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKTtcbiAgfSxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLnRvSlNPTigpKTtcbiAgfVxufTtcbmNvbnN0IFJpZ2h0UHJvdG8gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbiggLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUoQ29tbW9uUHJvdG8pLCB7XG4gIF90YWc6IFwiUmlnaHRcIixcbiAgX29wOiBcIlJpZ2h0XCIsXG4gIFtFcXVhbC5zeW1ib2xdKHRoYXQpIHtcbiAgICByZXR1cm4gaXNFaXRoZXIodGhhdCkgJiYgaXNSaWdodCh0aGF0KSAmJiBFcXVhbC5lcXVhbHModGhpcy5yaWdodCwgdGhhdC5yaWdodCk7XG4gIH0sXG4gIFtIYXNoLnN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIEhhc2guY29tYmluZShIYXNoLmhhc2godGhpcy5fdGFnKSkoSGFzaC5oYXNoKHRoaXMucmlnaHQpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiRWl0aGVyXCIsXG4gICAgICBfdGFnOiB0aGlzLl90YWcsXG4gICAgICByaWdodDogdG9KU09OKHRoaXMucmlnaHQpXG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBMZWZ0UHJvdG8gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbiggLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUoQ29tbW9uUHJvdG8pLCB7XG4gIF90YWc6IFwiTGVmdFwiLFxuICBfb3A6IFwiTGVmdFwiLFxuICBbRXF1YWwuc3ltYm9sXSh0aGF0KSB7XG4gICAgcmV0dXJuIGlzRWl0aGVyKHRoYXQpICYmIGlzTGVmdCh0aGF0KSAmJiBFcXVhbC5lcXVhbHModGhpcy5sZWZ0LCB0aGF0LmxlZnQpO1xuICB9LFxuICBbSGFzaC5zeW1ib2xdKCkge1xuICAgIHJldHVybiBIYXNoLmNvbWJpbmUoSGFzaC5oYXNoKHRoaXMuX3RhZykpKEhhc2guaGFzaCh0aGlzLmxlZnQpKTtcbiAgfSxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfaWQ6IFwiRWl0aGVyXCIsXG4gICAgICBfdGFnOiB0aGlzLl90YWcsXG4gICAgICBsZWZ0OiB0b0pTT04odGhpcy5sZWZ0KVxuICAgIH07XG4gIH1cbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGlzRWl0aGVyID0gaW5wdXQgPT4gaGFzUHJvcGVydHkoaW5wdXQsIFR5cGVJZCk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNMZWZ0ID0gbWEgPT4gbWEuX3RhZyA9PT0gXCJMZWZ0XCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNSaWdodCA9IG1hID0+IG1hLl90YWcgPT09IFwiUmlnaHRcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBsZWZ0ID0gbGVmdCA9PiB7XG4gIGNvbnN0IGEgPSBPYmplY3QuY3JlYXRlKExlZnRQcm90byk7XG4gIGEubGVmdCA9IGxlZnQ7XG4gIHJldHVybiBhO1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCByaWdodCA9IHJpZ2h0ID0+IHtcbiAgY29uc3QgYSA9IE9iamVjdC5jcmVhdGUoUmlnaHRQcm90byk7XG4gIGEucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIGE7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGdldExlZnQgPSBzZWxmID0+IGlzUmlnaHQoc2VsZikgPyBvcHRpb24ubm9uZSA6IG9wdGlvbi5zb21lKHNlbGYubGVmdCk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZ2V0UmlnaHQgPSBzZWxmID0+IGlzTGVmdChzZWxmKSA/IG9wdGlvbi5ub25lIDogb3B0aW9uLnNvbWUoc2VsZi5yaWdodCk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZnJvbU9wdGlvbiA9IC8qI19fUFVSRV9fKi9kdWFsKDIsIChzZWxmLCBvbk5vbmUpID0+IG9wdGlvbi5pc05vbmUoc2VsZikgPyBsZWZ0KG9uTm9uZSgpKSA6IHJpZ2h0KHNlbGYudmFsdWUpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVpdGhlci5qcy5tYXAiXSwibmFtZXMiOlsiRXF1YWwiLCJkdWFsIiwiSGFzaCIsImZvcm1hdCIsIk5vZGVJbnNwZWN0U3ltYm9sIiwidG9KU09OIiwiaGFzUHJvcGVydHkiLCJFZmZlY3RQcm90b3R5cGUiLCJvcHRpb24iLCJUeXBlSWQiLCJTeW1ib2wiLCJmb3IiLCJDb21tb25Qcm90byIsIl9SIiwiXyIsInRvU3RyaW5nIiwiUmlnaHRQcm90byIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsIl90YWciLCJfb3AiLCJzeW1ib2wiLCJ0aGF0IiwiaXNFaXRoZXIiLCJpc1JpZ2h0IiwiZXF1YWxzIiwicmlnaHQiLCJjb21iaW5lIiwiaGFzaCIsIl9pZCIsIkxlZnRQcm90byIsImlzTGVmdCIsImxlZnQiLCJpbnB1dCIsIm1hIiwiYSIsImdldExlZnQiLCJzZWxmIiwibm9uZSIsInNvbWUiLCJnZXRSaWdodCIsImZyb21PcHRpb24iLCJvbk5vbmUiLCJpc05vbmUiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/either.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js":
/*!******************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/base64.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   stripCrlf: () => (/* binding */ stripCrlf)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n\n\n/** @internal */ const encode = (bytes)=>{\n    const length = bytes.length;\n    let result = \"\";\n    let i;\n    for(i = 2; i < length; i += 3){\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];\n        result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];\n        result += base64abc[bytes[i] & 0x3f];\n    }\n    if (i === length + 1) {\n        // 1 octet yet to write\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[(bytes[i - 2] & 0x03) << 4];\n        result += \"==\";\n    }\n    if (i === length) {\n        // 2 octets yet to write\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];\n        result += base64abc[(bytes[i - 1] & 0x0f) << 2];\n        result += \"=\";\n    }\n    return result;\n};\n/** @internal */ const decode = (str)=>{\n    const stripped = stripCrlf(str);\n    const length = stripped.length;\n    if (length % 4 !== 0) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(stripped, `Length must be a multiple of 4, but is ${length}`));\n    }\n    const index = stripped.indexOf(\"=\");\n    if (index !== -1 && (index < length - 2 || index === length - 2 && stripped[length - 1] !== \"=\")) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(stripped, \"Found a '=' character, but it is not at the end\"));\n    }\n    try {\n        const missingOctets = stripped.endsWith(\"==\") ? 2 : stripped.endsWith(\"=\") ? 1 : 0;\n        const result = new Uint8Array(3 * (length / 4) - missingOctets);\n        for(let i = 0, j = 0; i < length; i += 4, j += 3){\n            const buffer = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));\n            result[j] = buffer >> 16;\n            result[j + 1] = buffer >> 8 & 0xff;\n            result[j + 2] = buffer & 0xff;\n        }\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.right(result);\n    } catch (e) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(stripped, e instanceof Error ? e.message : \"Invalid input\"));\n    }\n};\n/** @internal */ const stripCrlf = (str)=>str.replace(/[\\n\\r]/g, \"\");\n/** @internal */ function getBase64Code(charCode) {\n    if (charCode >= base64codes.length) {\n        throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);\n    }\n    const code = base64codes[charCode];\n    if (code === 255) {\n        throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);\n    }\n    return code;\n}\n/** @internal */ const base64abc = [\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"/\"\n];\n/** @internal */ const base64codes = [\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    62,\n    255,\n    255,\n    255,\n    63,\n    52,\n    53,\n    54,\n    55,\n    56,\n    57,\n    58,\n    59,\n    60,\n    61,\n    255,\n    255,\n    255,\n    0,\n    255,\n    255,\n    255,\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    22,\n    23,\n    24,\n    25,\n    255,\n    255,\n    255,\n    255,\n    255,\n    255,\n    26,\n    27,\n    28,\n    29,\n    30,\n    31,\n    32,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    39,\n    40,\n    41,\n    42,\n    43,\n    44,\n    45,\n    46,\n    47,\n    48,\n    49,\n    50,\n    51\n]; //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQztBQUNJO0FBQzlDLGNBQWMsR0FDUCxNQUFNRSxTQUFTQyxDQUFBQTtJQUNwQixNQUFNQyxTQUFTRCxNQUFNQyxNQUFNO0lBQzNCLElBQUlDLFNBQVM7SUFDYixJQUFJQztJQUNKLElBQUtBLElBQUksR0FBR0EsSUFBSUYsUUFBUUUsS0FBSyxFQUFHO1FBQzlCRCxVQUFVRSxTQUFTLENBQUNKLEtBQUssQ0FBQ0csSUFBSSxFQUFFLElBQUksRUFBRTtRQUN0Q0QsVUFBVUUsU0FBUyxDQUFDLENBQUNKLEtBQUssQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxLQUFNLElBQUlILEtBQUssQ0FBQ0csSUFBSSxFQUFFLElBQUksRUFBRTtRQUNuRUQsVUFBVUUsU0FBUyxDQUFDLENBQUNKLEtBQUssQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxLQUFNLElBQUlILEtBQUssQ0FBQ0csRUFBRSxJQUFJLEVBQUU7UUFDL0RELFVBQVVFLFNBQVMsQ0FBQ0osS0FBSyxDQUFDRyxFQUFFLEdBQUcsS0FBSztJQUN0QztJQUNBLElBQUlBLE1BQU1GLFNBQVMsR0FBRztRQUNwQix1QkFBdUI7UUFDdkJDLFVBQVVFLFNBQVMsQ0FBQ0osS0FBSyxDQUFDRyxJQUFJLEVBQUUsSUFBSSxFQUFFO1FBQ3RDRCxVQUFVRSxTQUFTLENBQUMsQ0FBQ0osS0FBSyxDQUFDRyxJQUFJLEVBQUUsR0FBRyxJQUFHLEtBQU0sRUFBRTtRQUMvQ0QsVUFBVTtJQUNaO0lBQ0EsSUFBSUMsTUFBTUYsUUFBUTtRQUNoQix3QkFBd0I7UUFDeEJDLFVBQVVFLFNBQVMsQ0FBQ0osS0FBSyxDQUFDRyxJQUFJLEVBQUUsSUFBSSxFQUFFO1FBQ3RDRCxVQUFVRSxTQUFTLENBQUMsQ0FBQ0osS0FBSyxDQUFDRyxJQUFJLEVBQUUsR0FBRyxJQUFHLEtBQU0s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QUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBQ2xWLGNBQWMsR0FDZCxNQUFNcUIsY0FBYztJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSTtJQUFLO0lBQUs7SUFBSztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBRztJQUFLO0lBQUs7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtDQUFHLEVBQy9pQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NC5qcz9kZjc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVpdGhlciBmcm9tIFwiLi4vLi4vRWl0aGVyLmpzXCI7XG5pbXBvcnQgeyBEZWNvZGVFeGNlcHRpb24gfSBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBieXRlcyA9PiB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAyOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICByZXN1bHQgKz0gYmFzZTY0YWJjW2J5dGVzW2kgLSAyXSA+PiAyXTtcbiAgICByZXN1bHQgKz0gYmFzZTY0YWJjWyhieXRlc1tpIC0gMl0gJiAweDAzKSA8PCA0IHwgYnl0ZXNbaSAtIDFdID4+IDRdO1xuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbKGJ5dGVzW2kgLSAxXSAmIDB4MGYpIDw8IDIgfCBieXRlc1tpXSA+PiA2XTtcbiAgICByZXN1bHQgKz0gYmFzZTY0YWJjW2J5dGVzW2ldICYgMHgzZl07XG4gIH1cbiAgaWYgKGkgPT09IGxlbmd0aCArIDEpIHtcbiAgICAvLyAxIG9jdGV0IHlldCB0byB3cml0ZVxuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbYnl0ZXNbaSAtIDJdID4+IDJdO1xuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbKGJ5dGVzW2kgLSAyXSAmIDB4MDMpIDw8IDRdO1xuICAgIHJlc3VsdCArPSBcIj09XCI7XG4gIH1cbiAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgIC8vIDIgb2N0ZXRzIHlldCB0byB3cml0ZVxuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbYnl0ZXNbaSAtIDJdID4+IDJdO1xuICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbKGJ5dGVzW2kgLSAyXSAmIDB4MDMpIDw8IDQgfCBieXRlc1tpIC0gMV0gPj4gNF07XG4gICAgcmVzdWx0ICs9IGJhc2U2NGFiY1soYnl0ZXNbaSAtIDFdICYgMHgwZikgPDwgMl07XG4gICAgcmVzdWx0ICs9IFwiPVwiO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IHN0ciA9PiB7XG4gIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBDcmxmKHN0cik7XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmlwcGVkLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDQgIT09IDApIHtcbiAgICByZXR1cm4gRWl0aGVyLmxlZnQoRGVjb2RlRXhjZXB0aW9uKHN0cmlwcGVkLCBgTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0LCBidXQgaXMgJHtsZW5ndGh9YCkpO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gc3RyaXBwZWQuaW5kZXhPZihcIj1cIik7XG4gIGlmIChpbmRleCAhPT0gLTEgJiYgKGluZGV4IDwgbGVuZ3RoIC0gMiB8fCBpbmRleCA9PT0gbGVuZ3RoIC0gMiAmJiBzdHJpcHBlZFtsZW5ndGggLSAxXSAhPT0gXCI9XCIpKSB7XG4gICAgcmV0dXJuIEVpdGhlci5sZWZ0KERlY29kZUV4Y2VwdGlvbihzdHJpcHBlZCwgXCJGb3VuZCBhICc9JyBjaGFyYWN0ZXIsIGJ1dCBpdCBpcyBub3QgYXQgdGhlIGVuZFwiKSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBtaXNzaW5nT2N0ZXRzID0gc3RyaXBwZWQuZW5kc1dpdGgoXCI9PVwiKSA/IDIgOiBzdHJpcHBlZC5lbmRzV2l0aChcIj1cIikgPyAxIDogMDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzICogKGxlbmd0aCAvIDQpIC0gbWlzc2luZ09jdGV0cyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQsIGogKz0gMykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZ2V0QmFzZTY0Q29kZShzdHJpcHBlZC5jaGFyQ29kZUF0KGkpKSA8PCAxOCB8IGdldEJhc2U2NENvZGUoc3RyaXBwZWQuY2hhckNvZGVBdChpICsgMSkpIDw8IDEyIHwgZ2V0QmFzZTY0Q29kZShzdHJpcHBlZC5jaGFyQ29kZUF0KGkgKyAyKSkgPDwgNiB8IGdldEJhc2U2NENvZGUoc3RyaXBwZWQuY2hhckNvZGVBdChpICsgMykpO1xuICAgICAgcmVzdWx0W2pdID0gYnVmZmVyID4+IDE2O1xuICAgICAgcmVzdWx0W2ogKyAxXSA9IGJ1ZmZlciA+PiA4ICYgMHhmZjtcbiAgICAgIHJlc3VsdFtqICsgMl0gPSBidWZmZXIgJiAweGZmO1xuICAgIH1cbiAgICByZXR1cm4gRWl0aGVyLnJpZ2h0KHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gRWl0aGVyLmxlZnQoRGVjb2RlRXhjZXB0aW9uKHN0cmlwcGVkLCBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBcIkludmFsaWQgaW5wdXRcIikpO1xuICB9XG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHN0cmlwQ3JsZiA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW1xcblxccl0vZywgXCJcIik7XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBnZXRCYXNlNjRDb2RlKGNoYXJDb2RlKSB7XG4gIGlmIChjaGFyQ29kZSA+PSBiYXNlNjRjb2Rlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfWApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBiYXNlNjRjb2Rlc1tjaGFyQ29kZV07XG4gIGlmIChjb2RlID09PSAyNTUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfWApO1xuICB9XG4gIHJldHVybiBjb2RlO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgYmFzZTY0YWJjID0gW1wiQVwiLCBcIkJcIiwgXCJDXCIsIFwiRFwiLCBcIkVcIiwgXCJGXCIsIFwiR1wiLCBcIkhcIiwgXCJJXCIsIFwiSlwiLCBcIktcIiwgXCJMXCIsIFwiTVwiLCBcIk5cIiwgXCJPXCIsIFwiUFwiLCBcIlFcIiwgXCJSXCIsIFwiU1wiLCBcIlRcIiwgXCJVXCIsIFwiVlwiLCBcIldcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCIsIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLCBcInJcIiwgXCJzXCIsIFwidFwiLCBcInVcIiwgXCJ2XCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwielwiLCBcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIrXCIsIFwiL1wiXTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGJhc2U2NGNvZGVzID0gWzI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgNjIsIDI1NSwgMjU1LCAyNTUsIDYzLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSwgMjU1LCAyNTUsIDI1NSwgMCwgMjU1LCAyNTUsIDI1NSwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbIkVpdGhlciIsIkRlY29kZUV4Y2VwdGlvbiIsImVuY29kZSIsImJ5dGVzIiwibGVuZ3RoIiwicmVzdWx0IiwiaSIsImJhc2U2NGFiYyIsImRlY29kZSIsInN0ciIsInN0cmlwcGVkIiwic3RyaXBDcmxmIiwibGVmdCIsImluZGV4IiwiaW5kZXhPZiIsIm1pc3NpbmdPY3RldHMiLCJlbmRzV2l0aCIsIlVpbnQ4QXJyYXkiLCJqIiwiYnVmZmVyIiwiZ2V0QmFzZTY0Q29kZSIsImNoYXJDb2RlQXQiLCJyaWdodCIsImUiLCJFcnJvciIsIm1lc3NhZ2UiLCJyZXBsYWNlIiwiY2hhckNvZGUiLCJiYXNlNjRjb2RlcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64Url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/base64Url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n\n\n\n/** @internal */ const encode = (data)=>_base64_js__WEBPACK_IMPORTED_MODULE_0__.encode(data).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n/** @internal */ const decode = (str)=>{\n    const stripped = _base64_js__WEBPACK_IMPORTED_MODULE_0__.stripCrlf(str);\n    const length = stripped.length;\n    if (length % 4 === 1) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_1__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_2__.DecodeException)(stripped, `Length should be a multiple of 4, but is ${length}`));\n    }\n    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_1__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_2__.DecodeException)(stripped, \"Invalid input\"));\n    }\n    // Some variants allow or require omitting the padding '=' signs\n    let sanitized = length % 4 === 2 ? `${stripped}==` : length % 4 === 3 ? `${stripped}=` : stripped;\n    sanitized = sanitized.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return _base64_js__WEBPACK_IMPORTED_MODULE_0__.decode(sanitized);\n}; //# sourceMappingURL=base64Url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NFVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQztBQUNKO0FBQ1E7QUFDOUMsY0FBYyxHQUNQLE1BQU1HLFNBQVNDLENBQUFBLE9BQVFILDhDQUFhLENBQUNHLE1BQU1DLE9BQU8sQ0FBQyxNQUFNLElBQUlBLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQU8sQ0FBQyxPQUFPLEtBQUs7QUFDNUcsY0FBYyxHQUNQLE1BQU1DLFNBQVNDLENBQUFBO0lBQ3BCLE1BQU1DLFdBQVdQLGlEQUFnQixDQUFDTTtJQUNsQyxNQUFNRyxTQUFTRixTQUFTRSxNQUFNO0lBQzlCLElBQUlBLFNBQVMsTUFBTSxHQUFHO1FBQ3BCLE9BQU9WLDRDQUFXLENBQUNFLDJEQUFlQSxDQUFDTSxVQUFVLENBQUMseUNBQXlDLEVBQUVFLE9BQU8sQ0FBQztJQUNuRztJQUNBLElBQUksQ0FBQyx3QkFBd0JFLElBQUksQ0FBQ0osV0FBVztRQUMzQyxPQUFPUiw0Q0FBVyxDQUFDRSwyREFBZUEsQ0FBQ00sVUFBVTtJQUMvQztJQUNBLGdFQUFnRTtJQUNoRSxJQUFJSyxZQUFZSCxTQUFTLE1BQU0sSUFBSSxDQUFDLEVBQUVGLFNBQVMsRUFBRSxDQUFDLEdBQUdFLFNBQVMsTUFBTSxJQUFJLENBQUMsRUFBRUYsU0FBUyxDQUFDLENBQUMsR0FBR0E7SUFDekZLLFlBQVlBLFVBQVVSLE9BQU8sQ0FBQyxNQUFNLEtBQUtBLE9BQU8sQ0FBQyxNQUFNO0lBQ3ZELE9BQU9KLDhDQUFhLENBQUNZO0FBQ3ZCLEVBQUUsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2Jhc2U2NFVybC5qcz84N2EwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVpdGhlciBmcm9tIFwiLi4vLi4vRWl0aGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBEZWNvZGVFeGNlcHRpb24gfSBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBkYXRhID0+IEJhc2U2NC5lbmNvZGUoZGF0YSkucmVwbGFjZSgvPS9nLCBcIlwiKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gc3RyID0+IHtcbiAgY29uc3Qgc3RyaXBwZWQgPSBCYXNlNjQuc3RyaXBDcmxmKHN0cik7XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmlwcGVkLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDQgPT09IDEpIHtcbiAgICByZXR1cm4gRWl0aGVyLmxlZnQoRGVjb2RlRXhjZXB0aW9uKHN0cmlwcGVkLCBgTGVuZ3RoIHNob3VsZCBiZSBhIG11bHRpcGxlIG9mIDQsIGJ1dCBpcyAke2xlbmd0aH1gKSk7XG4gIH1cbiAgaWYgKCEvXlstX0EtWjAtOV0qPz17MCwyfSQvaS50ZXN0KHN0cmlwcGVkKSkge1xuICAgIHJldHVybiBFaXRoZXIubGVmdChEZWNvZGVFeGNlcHRpb24oc3RyaXBwZWQsIFwiSW52YWxpZCBpbnB1dFwiKSk7XG4gIH1cbiAgLy8gU29tZSB2YXJpYW50cyBhbGxvdyBvciByZXF1aXJlIG9taXR0aW5nIHRoZSBwYWRkaW5nICc9JyBzaWduc1xuICBsZXQgc2FuaXRpemVkID0gbGVuZ3RoICUgNCA9PT0gMiA/IGAke3N0cmlwcGVkfT09YCA6IGxlbmd0aCAlIDQgPT09IDMgPyBgJHtzdHJpcHBlZH09YCA6IHN0cmlwcGVkO1xuICBzYW5pdGl6ZWQgPSBzYW5pdGl6ZWQucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHJldHVybiBCYXNlNjQuZGVjb2RlKHNhbml0aXplZCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0VXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJFaXRoZXIiLCJCYXNlNjQiLCJEZWNvZGVFeGNlcHRpb24iLCJlbmNvZGUiLCJkYXRhIiwicmVwbGFjZSIsImRlY29kZSIsInN0ciIsInN0cmlwcGVkIiwic3RyaXBDcmxmIiwibGVuZ3RoIiwibGVmdCIsInRlc3QiLCJzYW5pdGl6ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/base64Url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js":
/*!******************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/common.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeException: () => (/* binding */ DecodeException),\n/* harmony export */   DecodeExceptionTypeId: () => (/* binding */ DecodeExceptionTypeId),\n/* harmony export */   EncodeException: () => (/* binding */ EncodeException),\n/* harmony export */   EncodeExceptionTypeId: () => (/* binding */ EncodeExceptionTypeId),\n/* harmony export */   decoder: () => (/* binding */ decoder),\n/* harmony export */   encoder: () => (/* binding */ encoder),\n/* harmony export */   isDecodeException: () => (/* binding */ isDecodeException),\n/* harmony export */   isEncodeException: () => (/* binding */ isEncodeException)\n/* harmony export */ });\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n\n/** @internal */ const DecodeExceptionTypeId = /*#__PURE__*/ Symbol.for(\"effect/Encoding/errors/Decode\");\n/** @internal */ const DecodeException = (input, message)=>{\n    const out = {\n        _tag: \"DecodeException\",\n        [DecodeExceptionTypeId]: DecodeExceptionTypeId,\n        input\n    };\n    if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isString)(message)) {\n        out.message = message;\n    }\n    return out;\n};\n/** @internal */ const isDecodeException = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(u, DecodeExceptionTypeId);\n/** @internal */ const EncodeExceptionTypeId = /*#__PURE__*/ Symbol.for(\"effect/Encoding/errors/Encode\");\n/** @internal */ const EncodeException = (input, message)=>{\n    const out = {\n        _tag: \"EncodeException\",\n        [EncodeExceptionTypeId]: EncodeExceptionTypeId,\n        input\n    };\n    if ((0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.isString)(message)) {\n        out.message = message;\n    }\n    return out;\n};\n/** @internal */ const isEncodeException = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(u, EncodeExceptionTypeId);\n/** @interal */ const encoder = /*#__PURE__*/ new TextEncoder();\n/** @interal */ const decoder = /*#__PURE__*/ new TextDecoder(); //# sourceMappingURL=common.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMkQ7QUFDM0QsY0FBYyxHQUNQLE1BQU1FLHdCQUF3QixXQUFXLEdBQUVDLE9BQU9DLEdBQUcsQ0FBQyxpQ0FBaUM7QUFDOUYsY0FBYyxHQUNQLE1BQU1DLGtCQUFrQixDQUFDQyxPQUFPQztJQUNyQyxNQUFNQyxNQUFNO1FBQ1ZDLE1BQU07UUFDTixDQUFDUCxzQkFBc0IsRUFBRUE7UUFDekJJO0lBQ0Y7SUFDQSxJQUFJTCx1REFBUUEsQ0FBQ00sVUFBVTtRQUNyQkMsSUFBSUQsT0FBTyxHQUFHQTtJQUNoQjtJQUNBLE9BQU9DO0FBQ1QsRUFBRTtBQUNGLGNBQWMsR0FDUCxNQUFNRSxvQkFBb0JDLENBQUFBLElBQUtYLDBEQUFXQSxDQUFDVyxHQUFHVCx1QkFBdUI7QUFDNUUsY0FBYyxHQUNQLE1BQU1VLHdCQUF3QixXQUFXLEdBQUVULE9BQU9DLEdBQUcsQ0FBQyxpQ0FBaUM7QUFDOUYsY0FBYyxHQUNQLE1BQU1TLGtCQUFrQixDQUFDUCxPQUFPQztJQUNyQyxNQUFNQyxNQUFNO1FBQ1ZDLE1BQU07UUFDTixDQUFDRyxzQkFBc0IsRUFBRUE7UUFDekJOO0lBQ0Y7SUFDQSxJQUFJTCx1REFBUUEsQ0FBQ00sVUFBVTtRQUNyQkMsSUFBSUQsT0FBTyxHQUFHQTtJQUNoQjtJQUNBLE9BQU9DO0FBQ1QsRUFBRTtBQUNGLGNBQWMsR0FDUCxNQUFNTSxvQkFBb0JILENBQUFBLElBQUtYLDBEQUFXQSxDQUFDVyxHQUFHQyx1QkFBdUI7QUFDNUUsYUFBYSxHQUNOLE1BQU1HLFVBQVUsV0FBVyxHQUFFLElBQUlDLGNBQWM7QUFDdEQsYUFBYSxHQUNOLE1BQU1DLFVBQVUsV0FBVyxHQUFFLElBQUlDLGNBQWMsQ0FDdEQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9lbmNvZGluZy9jb21tb24uanM/NmYzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNTdHJpbmcgfSBmcm9tIFwiLi4vLi4vUHJlZGljYXRlLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgRGVjb2RlRXhjZXB0aW9uVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvRW5jb2RpbmcvZXJyb3JzL0RlY29kZVwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBEZWNvZGVFeGNlcHRpb24gPSAoaW5wdXQsIG1lc3NhZ2UpID0+IHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIF90YWc6IFwiRGVjb2RlRXhjZXB0aW9uXCIsXG4gICAgW0RlY29kZUV4Y2VwdGlvblR5cGVJZF06IERlY29kZUV4Y2VwdGlvblR5cGVJZCxcbiAgICBpbnB1dFxuICB9O1xuICBpZiAoaXNTdHJpbmcobWVzc2FnZSkpIHtcbiAgICBvdXQubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNEZWNvZGVFeGNlcHRpb24gPSB1ID0+IGhhc1Byb3BlcnR5KHUsIERlY29kZUV4Y2VwdGlvblR5cGVJZCk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgRW5jb2RlRXhjZXB0aW9uVHlwZUlkID0gLyojX19QVVJFX18qL1N5bWJvbC5mb3IoXCJlZmZlY3QvRW5jb2RpbmcvZXJyb3JzL0VuY29kZVwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBFbmNvZGVFeGNlcHRpb24gPSAoaW5wdXQsIG1lc3NhZ2UpID0+IHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIF90YWc6IFwiRW5jb2RlRXhjZXB0aW9uXCIsXG4gICAgW0VuY29kZUV4Y2VwdGlvblR5cGVJZF06IEVuY29kZUV4Y2VwdGlvblR5cGVJZCxcbiAgICBpbnB1dFxuICB9O1xuICBpZiAoaXNTdHJpbmcobWVzc2FnZSkpIHtcbiAgICBvdXQubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNFbmNvZGVFeGNlcHRpb24gPSB1ID0+IGhhc1Byb3BlcnR5KHUsIEVuY29kZUV4Y2VwdGlvblR5cGVJZCk7XG4vKiogQGludGVyYWwgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qL25ldyBUZXh0RW5jb2RlcigpO1xuLyoqIEBpbnRlcmFsICovXG5leHBvcnQgY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi9uZXcgVGV4dERlY29kZXIoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOlsiaGFzUHJvcGVydHkiLCJpc1N0cmluZyIsIkRlY29kZUV4Y2VwdGlvblR5cGVJZCIsIlN5bWJvbCIsImZvciIsIkRlY29kZUV4Y2VwdGlvbiIsImlucHV0IiwibWVzc2FnZSIsIm91dCIsIl90YWciLCJpc0RlY29kZUV4Y2VwdGlvbiIsInUiLCJFbmNvZGVFeGNlcHRpb25UeXBlSWQiLCJFbmNvZGVFeGNlcHRpb24iLCJpc0VuY29kZUV4Y2VwdGlvbiIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/encoding/hex.js":
/*!***************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/encoding/hex.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Either_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Either.js */ \"(ssr)/./node_modules/effect/dist/esm/Either.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/encoding/common.js\");\n\n\n/** @internal */ const encode = (bytes)=>{\n    let result = \"\";\n    for(let i = 0; i < bytes.length; ++i){\n        result += bytesToHex[bytes[i]];\n    }\n    return result;\n};\n/** @internal */ const decode = (str)=>{\n    const bytes = new TextEncoder().encode(str);\n    if (bytes.length % 2 !== 0) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, `Length must be a multiple of 2, but is ${bytes.length}`));\n    }\n    try {\n        const length = bytes.length / 2;\n        const result = new Uint8Array(length);\n        for(let i = 0; i < length; i++){\n            const a = fromHexChar(bytes[i * 2]);\n            const b = fromHexChar(bytes[i * 2 + 1]);\n            result[i] = a << 4 | b;\n        }\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.right(result);\n    } catch (e) {\n        return _Either_js__WEBPACK_IMPORTED_MODULE_0__.left((0,_common_js__WEBPACK_IMPORTED_MODULE_1__.DecodeException)(str, e instanceof Error ? e.message : \"Invalid input\"));\n    }\n};\n/** @internal */ const bytesToHex = [\n    \"00\",\n    \"01\",\n    \"02\",\n    \"03\",\n    \"04\",\n    \"05\",\n    \"06\",\n    \"07\",\n    \"08\",\n    \"09\",\n    \"0a\",\n    \"0b\",\n    \"0c\",\n    \"0d\",\n    \"0e\",\n    \"0f\",\n    \"10\",\n    \"11\",\n    \"12\",\n    \"13\",\n    \"14\",\n    \"15\",\n    \"16\",\n    \"17\",\n    \"18\",\n    \"19\",\n    \"1a\",\n    \"1b\",\n    \"1c\",\n    \"1d\",\n    \"1e\",\n    \"1f\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"24\",\n    \"25\",\n    \"26\",\n    \"27\",\n    \"28\",\n    \"29\",\n    \"2a\",\n    \"2b\",\n    \"2c\",\n    \"2d\",\n    \"2e\",\n    \"2f\",\n    \"30\",\n    \"31\",\n    \"32\",\n    \"33\",\n    \"34\",\n    \"35\",\n    \"36\",\n    \"37\",\n    \"38\",\n    \"39\",\n    \"3a\",\n    \"3b\",\n    \"3c\",\n    \"3d\",\n    \"3e\",\n    \"3f\",\n    \"40\",\n    \"41\",\n    \"42\",\n    \"43\",\n    \"44\",\n    \"45\",\n    \"46\",\n    \"47\",\n    \"48\",\n    \"49\",\n    \"4a\",\n    \"4b\",\n    \"4c\",\n    \"4d\",\n    \"4e\",\n    \"4f\",\n    \"50\",\n    \"51\",\n    \"52\",\n    \"53\",\n    \"54\",\n    \"55\",\n    \"56\",\n    \"57\",\n    \"58\",\n    \"59\",\n    \"5a\",\n    \"5b\",\n    \"5c\",\n    \"5d\",\n    \"5e\",\n    \"5f\",\n    \"60\",\n    \"61\",\n    \"62\",\n    \"63\",\n    \"64\",\n    \"65\",\n    \"66\",\n    \"67\",\n    \"68\",\n    \"69\",\n    \"6a\",\n    \"6b\",\n    \"6c\",\n    \"6d\",\n    \"6e\",\n    \"6f\",\n    \"70\",\n    \"71\",\n    \"72\",\n    \"73\",\n    \"74\",\n    \"75\",\n    \"76\",\n    \"77\",\n    \"78\",\n    \"79\",\n    \"7a\",\n    \"7b\",\n    \"7c\",\n    \"7d\",\n    \"7e\",\n    \"7f\",\n    \"80\",\n    \"81\",\n    \"82\",\n    \"83\",\n    \"84\",\n    \"85\",\n    \"86\",\n    \"87\",\n    \"88\",\n    \"89\",\n    \"8a\",\n    \"8b\",\n    \"8c\",\n    \"8d\",\n    \"8e\",\n    \"8f\",\n    \"90\",\n    \"91\",\n    \"92\",\n    \"93\",\n    \"94\",\n    \"95\",\n    \"96\",\n    \"97\",\n    \"98\",\n    \"99\",\n    \"9a\",\n    \"9b\",\n    \"9c\",\n    \"9d\",\n    \"9e\",\n    \"9f\",\n    \"a0\",\n    \"a1\",\n    \"a2\",\n    \"a3\",\n    \"a4\",\n    \"a5\",\n    \"a6\",\n    \"a7\",\n    \"a8\",\n    \"a9\",\n    \"aa\",\n    \"ab\",\n    \"ac\",\n    \"ad\",\n    \"ae\",\n    \"af\",\n    \"b0\",\n    \"b1\",\n    \"b2\",\n    \"b3\",\n    \"b4\",\n    \"b5\",\n    \"b6\",\n    \"b7\",\n    \"b8\",\n    \"b9\",\n    \"ba\",\n    \"bb\",\n    \"bc\",\n    \"bd\",\n    \"be\",\n    \"bf\",\n    \"c0\",\n    \"c1\",\n    \"c2\",\n    \"c3\",\n    \"c4\",\n    \"c5\",\n    \"c6\",\n    \"c7\",\n    \"c8\",\n    \"c9\",\n    \"ca\",\n    \"cb\",\n    \"cc\",\n    \"cd\",\n    \"ce\",\n    \"cf\",\n    \"d0\",\n    \"d1\",\n    \"d2\",\n    \"d3\",\n    \"d4\",\n    \"d5\",\n    \"d6\",\n    \"d7\",\n    \"d8\",\n    \"d9\",\n    \"da\",\n    \"db\",\n    \"dc\",\n    \"dd\",\n    \"de\",\n    \"df\",\n    \"e0\",\n    \"e1\",\n    \"e2\",\n    \"e3\",\n    \"e4\",\n    \"e5\",\n    \"e6\",\n    \"e7\",\n    \"e8\",\n    \"e9\",\n    \"ea\",\n    \"eb\",\n    \"ec\",\n    \"ed\",\n    \"ee\",\n    \"ef\",\n    \"f0\",\n    \"f1\",\n    \"f2\",\n    \"f3\",\n    \"f4\",\n    \"f5\",\n    \"f6\",\n    \"f7\",\n    \"f8\",\n    \"f9\",\n    \"fa\",\n    \"fb\",\n    \"fc\",\n    \"fd\",\n    \"fe\",\n    \"ff\"\n];\n/** @internal */ const fromHexChar = (byte)=>{\n    // '0' <= byte && byte <= '9'\n    if (48 <= byte && byte <= 57) {\n        return byte - 48;\n    }\n    // 'a' <= byte && byte <= 'f'\n    if (97 <= byte && byte <= 102) {\n        return byte - 97 + 10;\n    }\n    // 'A' <= byte && byte <= 'F'\n    if (65 <= byte && byte <= 70) {\n        return byte - 65 + 10;\n    }\n    throw new TypeError(\"Invalid input\");\n}; //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2VuY29kaW5nL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ0k7QUFDOUMsY0FBYyxHQUNQLE1BQU1FLFNBQVNDLENBQUFBO0lBQ3BCLElBQUlDLFNBQVM7SUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsTUFBTUcsTUFBTSxFQUFFLEVBQUVELEVBQUc7UUFDckNELFVBQVVHLFVBQVUsQ0FBQ0osS0FBSyxDQUFDRSxFQUFFLENBQUM7SUFDaEM7SUFDQSxPQUFPRDtBQUNULEVBQUU7QUFDRixjQUFjLEdBQ1AsTUFBTUksU0FBU0MsQ0FBQUE7SUFDcEIsTUFBTU4sUUFBUSxJQUFJTyxjQUFjUixNQUFNLENBQUNPO0lBQ3ZDLElBQUlOLE1BQU1HLE1BQU0sR0FBRyxNQUFNLEdBQUc7UUFDMUIsT0FBT04sNENBQVcsQ0FBQ0MsMkRBQWVBLENBQUNRLEtBQUssQ0FBQyx1Q0FBdUMsRUFBRU4sTUFBTUcsTUFBTSxDQUFDLENBQUM7SUFDbEc7SUFDQSxJQUFJO1FBQ0YsTUFBTUEsU0FBU0gsTUFBTUcsTUFBTSxHQUFHO1FBQzlCLE1BQU1GLFNBQVMsSUFBSVEsV0FBV047UUFDOUIsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUlDLFFBQVFELElBQUs7WUFDL0IsTUFBTVEsSUFBSUMsWUFBWVgsS0FBSyxDQUFDRSxJQUFJLEVBQUU7WUFDbEMsTUFBTVUsSUFBSUQsWUFBWVgsS0FBSyxDQUFDRSxJQUFJLElBQUksRUFBRTtZQUN0Q0QsTUFBTSxDQUFDQyxFQUFFLEdBQUdRLEtBQUssSUFBSUU7UUFDdkI7UUFDQSxPQUFPZiw2Q0FBWSxDQUFDSTtJQUN0QixFQUFFLE9BQU9hLEdBQUc7UUFDVixPQUFPakIsNENBQVcsQ0FBQ0MsMkRBQWVBLENBQUNRLEtBQUtRLGFBQWFDLFFBQVFELEVBQUVFLE9BQU8sR0FBRztJQUMzRTtBQUNGLEVBQUU7QUFDRixjQUFjLEdBQ2QsTUFBTVosYUFBYTtJQUFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFDbmhELGNBQWMsR0FDZCxNQUFNTyxjQUFjTSxDQUFBQTtJQUNsQiw2QkFBNkI7SUFDN0IsSUFBSSxNQUFNQSxRQUFRQSxRQUFRLElBQUk7UUFDNUIsT0FBT0EsT0FBTztJQUNoQjtJQUNBLDZCQUE2QjtJQUM3QixJQUFJLE1BQU1BLFFBQVFBLFFBQVEsS0FBSztRQUM3QixPQUFPQSxPQUFPLEtBQUs7SUFDckI7SUFDQSw2QkFBNkI7SUFDN0IsSUFBSSxNQUFNQSxRQUFRQSxRQUFRLElBQUk7UUFDNUIsT0FBT0EsT0FBTyxLQUFLO0lBQ3JCO0lBQ0EsTUFBTSxJQUFJQyxVQUFVO0FBQ3RCLEdBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9lbmNvZGluZy9oZXguanM/MTBkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFaXRoZXIgZnJvbSBcIi4uLy4uL0VpdGhlci5qc1wiO1xuaW1wb3J0IHsgRGVjb2RlRXhjZXB0aW9uIH0gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gYnl0ZXMgPT4ge1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdCArPSBieXRlc1RvSGV4W2J5dGVzW2ldXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBzdHIgPT4ge1xuICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICBpZiAoYnl0ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHJldHVybiBFaXRoZXIubGVmdChEZWNvZGVFeGNlcHRpb24oc3RyLCBgTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAyLCBidXQgaXMgJHtieXRlcy5sZW5ndGh9YCkpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC8gMjtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBmcm9tSGV4Q2hhcihieXRlc1tpICogMl0pO1xuICAgICAgY29uc3QgYiA9IGZyb21IZXhDaGFyKGJ5dGVzW2kgKiAyICsgMV0pO1xuICAgICAgcmVzdWx0W2ldID0gYSA8PCA0IHwgYjtcbiAgICB9XG4gICAgcmV0dXJuIEVpdGhlci5yaWdodChyZXN1bHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIEVpdGhlci5sZWZ0KERlY29kZUV4Y2VwdGlvbihzdHIsIGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFwiSW52YWxpZCBpbnB1dFwiKSk7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5jb25zdCBieXRlc1RvSGV4ID0gW1wiMDBcIiwgXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIwYVwiLCBcIjBiXCIsIFwiMGNcIiwgXCIwZFwiLCBcIjBlXCIsIFwiMGZcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIiwgXCIxM1wiLCBcIjE0XCIsIFwiMTVcIiwgXCIxNlwiLCBcIjE3XCIsIFwiMThcIiwgXCIxOVwiLCBcIjFhXCIsIFwiMWJcIiwgXCIxY1wiLCBcIjFkXCIsIFwiMWVcIiwgXCIxZlwiLCBcIjIwXCIsIFwiMjFcIiwgXCIyMlwiLCBcIjIzXCIsIFwiMjRcIiwgXCIyNVwiLCBcIjI2XCIsIFwiMjdcIiwgXCIyOFwiLCBcIjI5XCIsIFwiMmFcIiwgXCIyYlwiLCBcIjJjXCIsIFwiMmRcIiwgXCIyZVwiLCBcIjJmXCIsIFwiMzBcIiwgXCIzMVwiLCBcIjMyXCIsIFwiMzNcIiwgXCIzNFwiLCBcIjM1XCIsIFwiMzZcIiwgXCIzN1wiLCBcIjM4XCIsIFwiMzlcIiwgXCIzYVwiLCBcIjNiXCIsIFwiM2NcIiwgXCIzZFwiLCBcIjNlXCIsIFwiM2ZcIiwgXCI0MFwiLCBcIjQxXCIsIFwiNDJcIiwgXCI0M1wiLCBcIjQ0XCIsIFwiNDVcIiwgXCI0NlwiLCBcIjQ3XCIsIFwiNDhcIiwgXCI0OVwiLCBcIjRhXCIsIFwiNGJcIiwgXCI0Y1wiLCBcIjRkXCIsIFwiNGVcIiwgXCI0ZlwiLCBcIjUwXCIsIFwiNTFcIiwgXCI1MlwiLCBcIjUzXCIsIFwiNTRcIiwgXCI1NVwiLCBcIjU2XCIsIFwiNTdcIiwgXCI1OFwiLCBcIjU5XCIsIFwiNWFcIiwgXCI1YlwiLCBcIjVjXCIsIFwiNWRcIiwgXCI1ZVwiLCBcIjVmXCIsIFwiNjBcIiwgXCI2MVwiLCBcIjYyXCIsIFwiNjNcIiwgXCI2NFwiLCBcIjY1XCIsIFwiNjZcIiwgXCI2N1wiLCBcIjY4XCIsIFwiNjlcIiwgXCI2YVwiLCBcIjZiXCIsIFwiNmNcIiwgXCI2ZFwiLCBcIjZlXCIsIFwiNmZcIiwgXCI3MFwiLCBcIjcxXCIsIFwiNzJcIiwgXCI3M1wiLCBcIjc0XCIsIFwiNzVcIiwgXCI3NlwiLCBcIjc3XCIsIFwiNzhcIiwgXCI3OVwiLCBcIjdhXCIsIFwiN2JcIiwgXCI3Y1wiLCBcIjdkXCIsIFwiN2VcIiwgXCI3ZlwiLCBcIjgwXCIsIFwiODFcIiwgXCI4MlwiLCBcIjgzXCIsIFwiODRcIiwgXCI4NVwiLCBcIjg2XCIsIFwiODdcIiwgXCI4OFwiLCBcIjg5XCIsIFwiOGFcIiwgXCI4YlwiLCBcIjhjXCIsIFwiOGRcIiwgXCI4ZVwiLCBcIjhmXCIsIFwiOTBcIiwgXCI5MVwiLCBcIjkyXCIsIFwiOTNcIiwgXCI5NFwiLCBcIjk1XCIsIFwiOTZcIiwgXCI5N1wiLCBcIjk4XCIsIFwiOTlcIiwgXCI5YVwiLCBcIjliXCIsIFwiOWNcIiwgXCI5ZFwiLCBcIjllXCIsIFwiOWZcIiwgXCJhMFwiLCBcImExXCIsIFwiYTJcIiwgXCJhM1wiLCBcImE0XCIsIFwiYTVcIiwgXCJhNlwiLCBcImE3XCIsIFwiYThcIiwgXCJhOVwiLCBcImFhXCIsIFwiYWJcIiwgXCJhY1wiLCBcImFkXCIsIFwiYWVcIiwgXCJhZlwiLCBcImIwXCIsIFwiYjFcIiwgXCJiMlwiLCBcImIzXCIsIFwiYjRcIiwgXCJiNVwiLCBcImI2XCIsIFwiYjdcIiwgXCJiOFwiLCBcImI5XCIsIFwiYmFcIiwgXCJiYlwiLCBcImJjXCIsIFwiYmRcIiwgXCJiZVwiLCBcImJmXCIsIFwiYzBcIiwgXCJjMVwiLCBcImMyXCIsIFwiYzNcIiwgXCJjNFwiLCBcImM1XCIsIFwiYzZcIiwgXCJjN1wiLCBcImM4XCIsIFwiYzlcIiwgXCJjYVwiLCBcImNiXCIsIFwiY2NcIiwgXCJjZFwiLCBcImNlXCIsIFwiY2ZcIiwgXCJkMFwiLCBcImQxXCIsIFwiZDJcIiwgXCJkM1wiLCBcImQ0XCIsIFwiZDVcIiwgXCJkNlwiLCBcImQ3XCIsIFwiZDhcIiwgXCJkOVwiLCBcImRhXCIsIFwiZGJcIiwgXCJkY1wiLCBcImRkXCIsIFwiZGVcIiwgXCJkZlwiLCBcImUwXCIsIFwiZTFcIiwgXCJlMlwiLCBcImUzXCIsIFwiZTRcIiwgXCJlNVwiLCBcImU2XCIsIFwiZTdcIiwgXCJlOFwiLCBcImU5XCIsIFwiZWFcIiwgXCJlYlwiLCBcImVjXCIsIFwiZWRcIiwgXCJlZVwiLCBcImVmXCIsIFwiZjBcIiwgXCJmMVwiLCBcImYyXCIsIFwiZjNcIiwgXCJmNFwiLCBcImY1XCIsIFwiZjZcIiwgXCJmN1wiLCBcImY4XCIsIFwiZjlcIiwgXCJmYVwiLCBcImZiXCIsIFwiZmNcIiwgXCJmZFwiLCBcImZlXCIsIFwiZmZcIl07XG4vKiogQGludGVybmFsICovXG5jb25zdCBmcm9tSGV4Q2hhciA9IGJ5dGUgPT4ge1xuICAvLyAnMCcgPD0gYnl0ZSAmJiBieXRlIDw9ICc5J1xuICBpZiAoNDggPD0gYnl0ZSAmJiBieXRlIDw9IDU3KSB7XG4gICAgcmV0dXJuIGJ5dGUgLSA0ODtcbiAgfVxuICAvLyAnYScgPD0gYnl0ZSAmJiBieXRlIDw9ICdmJ1xuICBpZiAoOTcgPD0gYnl0ZSAmJiBieXRlIDw9IDEwMikge1xuICAgIHJldHVybiBieXRlIC0gOTcgKyAxMDtcbiAgfVxuICAvLyAnQScgPD0gYnl0ZSAmJiBieXRlIDw9ICdGJ1xuICBpZiAoNjUgPD0gYnl0ZSAmJiBieXRlIDw9IDcwKSB7XG4gICAgcmV0dXJuIGJ5dGUgLSA2NSArIDEwO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGlucHV0XCIpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiXSwibmFtZXMiOlsiRWl0aGVyIiwiRGVjb2RlRXhjZXB0aW9uIiwiZW5jb2RlIiwiYnl0ZXMiLCJyZXN1bHQiLCJpIiwibGVuZ3RoIiwiYnl0ZXNUb0hleCIsImRlY29kZSIsInN0ciIsIlRleHRFbmNvZGVyIiwibGVmdCIsIlVpbnQ4QXJyYXkiLCJhIiwiZnJvbUhleENoYXIiLCJiIiwicmlnaHQiLCJlIiwiRXJyb3IiLCJtZXNzYWdlIiwiYnl0ZSIsIlR5cGVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/encoding/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBugErrorMessage: () => (/* binding */ getBugErrorMessage)\n/* harmony export */ });\n/**\n * @since 2.0.0\n */ /** @internal */ const getBugErrorMessage = (message)=>`BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`; //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDRCxjQUFjLEdBQ1AsTUFBTUEscUJBQXFCQyxDQUFBQSxVQUFXLENBQUMsS0FBSyxFQUFFQSxRQUFRLHVFQUF1RSxDQUFDLENBQUMsQ0FDdEksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHdpc3RlZC1jYW50aW5hLy4vbm9kZV9tb2R1bGVzL2VmZmVjdC9kaXN0L2VzbS9pbnRlcm5hbC9lcnJvcnMuanM/NzY5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgZ2V0QnVnRXJyb3JNZXNzYWdlID0gbWVzc2FnZSA9PiBgQlVHOiAke21lc3NhZ2V9IC0gcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vRWZmZWN0LVRTL2VmZmVjdC9pc3N1ZXNgO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCdWdFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/opCodes/effect.js":
/*!*****************************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/opCodes/effect.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OP_ASYNC: () => (/* binding */ OP_ASYNC),\n/* harmony export */   OP_COMMIT: () => (/* binding */ OP_COMMIT),\n/* harmony export */   OP_FAILURE: () => (/* binding */ OP_FAILURE),\n/* harmony export */   OP_ITERATOR: () => (/* binding */ OP_ITERATOR),\n/* harmony export */   OP_ON_FAILURE: () => (/* binding */ OP_ON_FAILURE),\n/* harmony export */   OP_ON_SUCCESS: () => (/* binding */ OP_ON_SUCCESS),\n/* harmony export */   OP_ON_SUCCESS_AND_FAILURE: () => (/* binding */ OP_ON_SUCCESS_AND_FAILURE),\n/* harmony export */   OP_REVERT_FLAGS: () => (/* binding */ OP_REVERT_FLAGS),\n/* harmony export */   OP_SUCCESS: () => (/* binding */ OP_SUCCESS),\n/* harmony export */   OP_SYNC: () => (/* binding */ OP_SYNC),\n/* harmony export */   OP_TAG: () => (/* binding */ OP_TAG),\n/* harmony export */   OP_UPDATE_RUNTIME_FLAGS: () => (/* binding */ OP_UPDATE_RUNTIME_FLAGS),\n/* harmony export */   OP_WHILE: () => (/* binding */ OP_WHILE),\n/* harmony export */   OP_WITH_RUNTIME: () => (/* binding */ OP_WITH_RUNTIME),\n/* harmony export */   OP_YIELD: () => (/* binding */ OP_YIELD)\n/* harmony export */ });\n/** @internal */ const OP_ASYNC = \"Async\";\n/** @internal */ const OP_COMMIT = \"Commit\";\n/** @internal */ const OP_FAILURE = \"Failure\";\n/** @internal */ const OP_ON_FAILURE = \"OnFailure\";\n/** @internal */ const OP_ON_SUCCESS = \"OnSuccess\";\n/** @internal */ const OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\";\n/** @internal */ const OP_SUCCESS = \"Success\";\n/** @internal */ const OP_SYNC = \"Sync\";\n/** @internal */ const OP_TAG = \"Tag\";\n/** @internal */ const OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\";\n/** @internal */ const OP_WHILE = \"While\";\n/** @internal */ const OP_ITERATOR = \"Iterator\";\n/** @internal */ const OP_WITH_RUNTIME = \"WithRuntime\";\n/** @internal */ const OP_YIELD = \"Yield\";\n/** @internal */ const OP_REVERT_FLAGS = \"RevertFlags\"; //# sourceMappingURL=effect.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL29wQ29kZXMvZWZmZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGNBQWMsR0FDUCxNQUFNQSxXQUFXLFFBQVE7QUFDaEMsY0FBYyxHQUNQLE1BQU1DLFlBQVksU0FBUztBQUNsQyxjQUFjLEdBQ1AsTUFBTUMsYUFBYSxVQUFVO0FBQ3BDLGNBQWMsR0FDUCxNQUFNQyxnQkFBZ0IsWUFBWTtBQUN6QyxjQUFjLEdBQ1AsTUFBTUMsZ0JBQWdCLFlBQVk7QUFDekMsY0FBYyxHQUNQLE1BQU1DLDRCQUE0QixzQkFBc0I7QUFDL0QsY0FBYyxHQUNQLE1BQU1DLGFBQWEsVUFBVTtBQUNwQyxjQUFjLEdBQ1AsTUFBTUMsVUFBVSxPQUFPO0FBQzlCLGNBQWMsR0FDUCxNQUFNQyxTQUFTLE1BQU07QUFDNUIsY0FBYyxHQUNQLE1BQU1DLDBCQUEwQixxQkFBcUI7QUFDNUQsY0FBYyxHQUNQLE1BQU1DLFdBQVcsUUFBUTtBQUNoQyxjQUFjLEdBQ1AsTUFBTUMsY0FBYyxXQUFXO0FBQ3RDLGNBQWMsR0FDUCxNQUFNQyxrQkFBa0IsY0FBYztBQUM3QyxjQUFjLEdBQ1AsTUFBTUMsV0FBVyxRQUFRO0FBQ2hDLGNBQWMsR0FDUCxNQUFNQyxrQkFBa0IsY0FBYyxDQUM3QyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL29wQ29kZXMvZWZmZWN0LmpzPzYzMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX0FTWU5DID0gXCJBc3luY1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX0NPTU1JVCA9IFwiQ29tbWl0XCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgT1BfRkFJTFVSRSA9IFwiRmFpbHVyZVwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX09OX0ZBSUxVUkUgPSBcIk9uRmFpbHVyZVwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX09OX1NVQ0NFU1MgPSBcIk9uU3VjY2Vzc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX09OX1NVQ0NFU1NfQU5EX0ZBSUxVUkUgPSBcIk9uU3VjY2Vzc0FuZEZhaWx1cmVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9TVUNDRVNTID0gXCJTdWNjZXNzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgT1BfU1lOQyA9IFwiU3luY1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX1RBRyA9IFwiVGFnXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgT1BfVVBEQVRFX1JVTlRJTUVfRkxBR1MgPSBcIlVwZGF0ZVJ1bnRpbWVGbGFnc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX1dISUxFID0gXCJXaGlsZVwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX0lURVJBVE9SID0gXCJJdGVyYXRvclwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IE9QX1dJVEhfUlVOVElNRSA9IFwiV2l0aFJ1bnRpbWVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9ZSUVMRCA9IFwiWWllbGRcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBPUF9SRVZFUlRfRkxBR1MgPSBcIlJldmVydEZsYWdzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZmZlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9QX0FTWU5DIiwiT1BfQ09NTUlUIiwiT1BfRkFJTFVSRSIsIk9QX09OX0ZBSUxVUkUiLCJPUF9PTl9TVUNDRVNTIiwiT1BfT05fU1VDQ0VTU19BTkRfRkFJTFVSRSIsIk9QX1NVQ0NFU1MiLCJPUF9TWU5DIiwiT1BfVEFHIiwiT1BfVVBEQVRFX1JVTlRJTUVfRkxBR1MiLCJPUF9XSElMRSIsIk9QX0lURVJBVE9SIiwiT1BfV0lUSF9SVU5USU1FIiwiT1BfWUlFTEQiLCJPUF9SRVZFUlRfRkxBR1MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/opCodes/effect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/option.js":
/*!*********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/option.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNone: () => (/* binding */ isNone),\n/* harmony export */   isOption: () => (/* binding */ isOption),\n/* harmony export */   isSome: () => (/* binding */ isSome),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   some: () => (/* binding */ some)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n/* harmony import */ var _effectable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./effectable.js */ \"(ssr)/./node_modules/effect/dist/esm/internal/effectable.js\");\n/**\n * @since 2.0.0\n */ \n\n\n\n\nconst TypeId = /*#__PURE__*/ Symbol.for(\"effect/Option\");\nconst CommonProto = {\n    ..._effectable_js__WEBPACK_IMPORTED_MODULE_0__.EffectPrototype,\n    [TypeId]: {\n        _A: (_)=>_\n    },\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.NodeInspectSymbol] () {\n        return this.toJSON();\n    },\n    toString () {\n        return (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.format)(this.toJSON());\n    }\n};\nconst SomeProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {\n    _tag: \"Some\",\n    _op: \"Some\",\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol] (that) {\n        return isOption(that) && isSome(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_2__.equals(this.value, that.value);\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol] () {\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.cached(this, _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this._tag))(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(this.value)));\n    },\n    toJSON () {\n        return {\n            _id: \"Option\",\n            _tag: this._tag,\n            value: (0,_Inspectable_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(this.value)\n        };\n    }\n});\nconst NoneHash = /*#__PURE__*/ _Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(\"None\");\nconst NoneProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {\n    _tag: \"None\",\n    _op: \"None\",\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_2__.symbol] (that) {\n        return isOption(that) && isNone(that);\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol] () {\n        return NoneHash;\n    },\n    toJSON () {\n        return {\n            _id: \"Option\",\n            _tag: this._tag\n        };\n    }\n});\n/** @internal */ const isOption = (input)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(input, TypeId);\n/** @internal */ const isNone = (fa)=>fa._tag === \"None\";\n/** @internal */ const isSome = (fa)=>fa._tag === \"Some\";\n/** @internal */ const none = /*#__PURE__*/ Object.create(NoneProto);\n/** @internal */ const some = (value)=>{\n    const a = Object.create(SomeProto);\n    a.value = value;\n    return a;\n}; //# sourceMappingURL=option.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL29wdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDb0M7QUFDRjtBQUNtQztBQUN4QjtBQUNJO0FBQ2xELE1BQU1PLFNBQVMsV0FBVyxHQUFFQyxPQUFPQyxHQUFHLENBQUM7QUFDdkMsTUFBTUMsY0FBYztJQUNsQixHQUFHSiwyREFBZTtJQUNsQixDQUFDQyxPQUFPLEVBQUU7UUFDUkksSUFBSUMsQ0FBQUEsSUFBS0E7SUFDWDtJQUNBLENBQUNULDhEQUFpQkEsQ0FBQztRQUNqQixPQUFPLElBQUksQ0FBQ0MsTUFBTTtJQUNwQjtJQUNBUztRQUNFLE9BQU9YLHVEQUFNQSxDQUFDLElBQUksQ0FBQ0UsTUFBTTtJQUMzQjtBQUNGO0FBQ0EsTUFBTVUsWUFBWSxXQUFXLEdBQUVDLE9BQU9DLE1BQU0sQ0FBRSxXQUFXLEdBQUVELE9BQU9FLE1BQU0sQ0FBQ1AsY0FBYztJQUNyRlEsTUFBTTtJQUNOQyxLQUFLO0lBQ0wsQ0FBQ25CLDZDQUFZLENBQUMsRUFBQ3FCLElBQUk7UUFDakIsT0FBT0MsU0FBU0QsU0FBU0UsT0FBT0YsU0FBU3JCLDZDQUFZLENBQUMsSUFBSSxDQUFDeUIsS0FBSyxFQUFFSixLQUFLSSxLQUFLO0lBQzlFO0lBQ0EsQ0FBQ3hCLDRDQUFXLENBQUM7UUFDWCxPQUFPQSw0Q0FBVyxDQUFDLElBQUksRUFBRUEsNkNBQVksQ0FBQ0EsMENBQVMsQ0FBQyxJQUFJLENBQUNpQixJQUFJLEdBQUdqQiwwQ0FBUyxDQUFDLElBQUksQ0FBQ3dCLEtBQUs7SUFDbEY7SUFDQXJCO1FBQ0UsT0FBTztZQUNMeUIsS0FBSztZQUNMWCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmTyxPQUFPckIsdURBQU1BLENBQUMsSUFBSSxDQUFDcUIsS0FBSztRQUMxQjtJQUNGO0FBQ0Y7QUFDQSxNQUFNSyxXQUFXLFdBQVcsR0FBRTdCLDBDQUFTLENBQUM7QUFDeEMsTUFBTThCLFlBQVksV0FBVyxHQUFFaEIsT0FBT0MsTUFBTSxDQUFFLFdBQVcsR0FBRUQsT0FBT0UsTUFBTSxDQUFDUCxjQUFjO0lBQ3JGUSxNQUFNO0lBQ05DLEtBQUs7SUFDTCxDQUFDbkIsNkNBQVksQ0FBQyxFQUFDcUIsSUFBSTtRQUNqQixPQUFPQyxTQUFTRCxTQUFTVyxPQUFPWDtJQUNsQztJQUNBLENBQUNwQiw0Q0FBVyxDQUFDO1FBQ1gsT0FBTzZCO0lBQ1Q7SUFDQTFCO1FBQ0UsT0FBTztZQUNMeUIsS0FBSztZQUNMWCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUNqQjtJQUNGO0FBQ0Y7QUFDQSxjQUFjLEdBQ1AsTUFBTUksV0FBV1csQ0FBQUEsUUFBUzVCLDBEQUFXQSxDQUFDNEIsT0FBTzFCLFFBQVE7QUFDNUQsY0FBYyxHQUNQLE1BQU15QixTQUFTRSxDQUFBQSxLQUFNQSxHQUFHaEIsSUFBSSxLQUFLLE9BQU87QUFDL0MsY0FBYyxHQUNQLE1BQU1LLFNBQVNXLENBQUFBLEtBQU1BLEdBQUdoQixJQUFJLEtBQUssT0FBTztBQUMvQyxjQUFjLEdBQ1AsTUFBTWlCLE9BQU8sV0FBVyxHQUFFcEIsT0FBT0UsTUFBTSxDQUFDYyxXQUFXO0FBQzFELGNBQWMsR0FDUCxNQUFNSyxPQUFPWCxDQUFBQTtJQUNsQixNQUFNWSxJQUFJdEIsT0FBT0UsTUFBTSxDQUFDSDtJQUN4QnVCLEVBQUVaLEtBQUssR0FBR0E7SUFDVixPQUFPWTtBQUNULEVBQUUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL29wdGlvbi5qcz8wNWIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmltcG9ydCAqIGFzIEVxdWFsIGZyb20gXCIuLi9FcXVhbC5qc1wiO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tIFwiLi4vSGFzaC5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0LCBOb2RlSW5zcGVjdFN5bWJvbCwgdG9KU09OIH0gZnJvbSBcIi4uL0luc3BlY3RhYmxlLmpzXCI7XG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSB9IGZyb20gXCIuLi9QcmVkaWNhdGUuanNcIjtcbmltcG9ydCB7IEVmZmVjdFByb3RvdHlwZSB9IGZyb20gXCIuL2VmZmVjdGFibGUuanNcIjtcbmNvbnN0IFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFwiZWZmZWN0L09wdGlvblwiKTtcbmNvbnN0IENvbW1vblByb3RvID0ge1xuICAuLi5FZmZlY3RQcm90b3R5cGUsXG4gIFtUeXBlSWRdOiB7XG4gICAgX0E6IF8gPT4gX1xuICB9LFxuICBbTm9kZUluc3BlY3RTeW1ib2xdKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNPTigpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMudG9KU09OKCkpO1xuICB9XG59O1xuY29uc3QgU29tZVByb3RvID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oIC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKENvbW1vblByb3RvKSwge1xuICBfdGFnOiBcIlNvbWVcIixcbiAgX29wOiBcIlNvbWVcIixcbiAgW0VxdWFsLnN5bWJvbF0odGhhdCkge1xuICAgIHJldHVybiBpc09wdGlvbih0aGF0KSAmJiBpc1NvbWUodGhhdCkgJiYgRXF1YWwuZXF1YWxzKHRoaXMudmFsdWUsIHRoYXQudmFsdWUpO1xuICB9LFxuICBbSGFzaC5zeW1ib2xdKCkge1xuICAgIHJldHVybiBIYXNoLmNhY2hlZCh0aGlzLCBIYXNoLmNvbWJpbmUoSGFzaC5oYXNoKHRoaXMuX3RhZykpKEhhc2guaGFzaCh0aGlzLnZhbHVlKSkpO1xuICB9LFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogXCJPcHRpb25cIixcbiAgICAgIF90YWc6IHRoaXMuX3RhZyxcbiAgICAgIHZhbHVlOiB0b0pTT04odGhpcy52YWx1ZSlcbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IE5vbmVIYXNoID0gLyojX19QVVJFX18qL0hhc2guaGFzaChcIk5vbmVcIik7XG5jb25zdCBOb25lUHJvdG8gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbiggLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUoQ29tbW9uUHJvdG8pLCB7XG4gIF90YWc6IFwiTm9uZVwiLFxuICBfb3A6IFwiTm9uZVwiLFxuICBbRXF1YWwuc3ltYm9sXSh0aGF0KSB7XG4gICAgcmV0dXJuIGlzT3B0aW9uKHRoYXQpICYmIGlzTm9uZSh0aGF0KTtcbiAgfSxcbiAgW0hhc2guc3ltYm9sXSgpIHtcbiAgICByZXR1cm4gTm9uZUhhc2g7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2lkOiBcIk9wdGlvblwiLFxuICAgICAgX3RhZzogdGhpcy5fdGFnXG4gICAgfTtcbiAgfVxufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNPcHRpb24gPSBpbnB1dCA9PiBoYXNQcm9wZXJ0eShpbnB1dCwgVHlwZUlkKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc05vbmUgPSBmYSA9PiBmYS5fdGFnID09PSBcIk5vbmVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpc1NvbWUgPSBmYSA9PiBmYS5fdGFnID09PSBcIlNvbWVcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBub25lID0gLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUoTm9uZVByb3RvKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBzb21lID0gdmFsdWUgPT4ge1xuICBjb25zdCBhID0gT2JqZWN0LmNyZWF0ZShTb21lUHJvdG8pO1xuICBhLnZhbHVlID0gdmFsdWU7XG4gIHJldHVybiBhO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiRXF1YWwiLCJIYXNoIiwiZm9ybWF0IiwiTm9kZUluc3BlY3RTeW1ib2wiLCJ0b0pTT04iLCJoYXNQcm9wZXJ0eSIsIkVmZmVjdFByb3RvdHlwZSIsIlR5cGVJZCIsIlN5bWJvbCIsImZvciIsIkNvbW1vblByb3RvIiwiX0EiLCJfIiwidG9TdHJpbmciLCJTb21lUHJvdG8iLCJPYmplY3QiLCJhc3NpZ24iLCJjcmVhdGUiLCJfdGFnIiwiX29wIiwic3ltYm9sIiwidGhhdCIsImlzT3B0aW9uIiwiaXNTb21lIiwiZXF1YWxzIiwidmFsdWUiLCJjYWNoZWQiLCJjb21iaW5lIiwiaGFzaCIsIl9pZCIsIk5vbmVIYXNoIiwiTm9uZVByb3RvIiwiaXNOb25lIiwiaW5wdXQiLCJmYSIsIm5vbmUiLCJzb21lIiwiYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/option.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/redacted.js":
/*!***********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/redacted.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedactedTypeId: () => (/* binding */ RedactedTypeId),\n/* harmony export */   isRedacted: () => (/* binding */ isRedacted),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   proto: () => (/* binding */ proto),\n/* harmony export */   redactedRegistry: () => (/* binding */ redactedRegistry),\n/* harmony export */   unsafeWipe: () => (/* binding */ unsafeWipe),\n/* harmony export */   value: () => (/* binding */ value)\n/* harmony export */ });\n/* harmony import */ var _Equal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Equal.js */ \"(ssr)/./node_modules/effect/dist/esm/Equal.js\");\n/* harmony import */ var _Function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Function.js */ \"(ssr)/./node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var _GlobalValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GlobalValue.js */ \"(ssr)/./node_modules/effect/dist/esm/GlobalValue.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Hash.js */ \"(ssr)/./node_modules/effect/dist/esm/Hash.js\");\n/* harmony import */ var _Inspectable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Inspectable.js */ \"(ssr)/./node_modules/effect/dist/esm/Inspectable.js\");\n/* harmony import */ var _Pipeable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Pipeable.js */ \"(ssr)/./node_modules/effect/dist/esm/Pipeable.js\");\n/* harmony import */ var _Predicate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Predicate.js */ \"(ssr)/./node_modules/effect/dist/esm/Predicate.js\");\n\n\n\n\n\n\n\n/** @internal */ const RedactedSymbolKey = \"effect/Redacted\";\n/** @internal */ const redactedRegistry = /*#__PURE__*/ (0,_GlobalValue_js__WEBPACK_IMPORTED_MODULE_0__.globalValue)(\"effect/Redacted/redactedRegistry\", ()=>new WeakMap());\n/** @internal */ const RedactedTypeId = /*#__PURE__*/ Symbol.for(RedactedSymbolKey);\n/** @internal */ const proto = {\n    [RedactedTypeId]: {\n        _A: (_)=>_\n    },\n    pipe () {\n        return (0,_Pipeable_js__WEBPACK_IMPORTED_MODULE_1__.pipeArguments)(this, arguments);\n    },\n    toString () {\n        return \"<redacted>\";\n    },\n    toJSON () {\n        return \"<redacted>\";\n    },\n    [_Inspectable_js__WEBPACK_IMPORTED_MODULE_2__.NodeInspectSymbol] () {\n        return \"<redacted>\";\n    },\n    [_Hash_js__WEBPACK_IMPORTED_MODULE_3__.symbol] () {\n        return (0,_Function_js__WEBPACK_IMPORTED_MODULE_4__.pipe)(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(RedactedSymbolKey), _Hash_js__WEBPACK_IMPORTED_MODULE_3__.combine(_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash(redactedRegistry.get(this))), _Hash_js__WEBPACK_IMPORTED_MODULE_3__.cached(this));\n    },\n    [_Equal_js__WEBPACK_IMPORTED_MODULE_5__.symbol] (that) {\n        return isRedacted(that) && _Equal_js__WEBPACK_IMPORTED_MODULE_5__.equals(redactedRegistry.get(this), redactedRegistry.get(that));\n    }\n};\n/** @internal */ const isRedacted = (u)=>(0,_Predicate_js__WEBPACK_IMPORTED_MODULE_6__.hasProperty)(u, RedactedTypeId);\n/** @internal */ const make = (value)=>{\n    const redacted = Object.create(proto);\n    redactedRegistry.set(redacted, value);\n    return redacted;\n};\n/** @internal */ const value = (self)=>{\n    if (redactedRegistry.has(self)) {\n        return redactedRegistry.get(self);\n    } else {\n        throw new Error(\"Unable to get redacted value\");\n    }\n};\n/** @internal */ const unsafeWipe = (self)=>redactedRegistry.delete(self); //# sourceMappingURL=redacted.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL3JlZGFjdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0M7QUFDVTtBQUNiO0FBQ21CO0FBQ1A7QUFDRDtBQUM5QyxjQUFjLEdBQ2QsTUFBTU8sb0JBQW9CO0FBQzFCLGNBQWMsR0FDUCxNQUFNQyxtQkFBbUIsV0FBVyxHQUFFTiw0REFBV0EsQ0FBQyxvQ0FBb0MsSUFBTSxJQUFJTyxXQUFXO0FBQ2xILGNBQWMsR0FDUCxNQUFNQyxpQkFBaUIsV0FBVyxHQUFFQyxPQUFPQyxHQUFHLENBQUNMLG1CQUFtQjtBQUN6RSxjQUFjLEdBQ1AsTUFBTU0sUUFBUTtJQUNuQixDQUFDSCxlQUFlLEVBQUU7UUFDaEJJLElBQUlDLENBQUFBLElBQUtBO0lBQ1g7SUFDQWQ7UUFDRSxPQUFPSSwyREFBYUEsQ0FBQyxJQUFJLEVBQUVXO0lBQzdCO0lBQ0FDO1FBQ0UsT0FBTztJQUNUO0lBQ0FDO1FBQ0UsT0FBTztJQUNUO0lBQ0EsQ0FBQ2QsOERBQWlCQSxDQUFDO1FBQ2pCLE9BQU87SUFDVDtJQUNBLENBQUNELDRDQUFXLENBQUM7UUFDWCxPQUFPRixrREFBSUEsQ0FBQ0UsMENBQVMsQ0FBQ0ksb0JBQW9CSiw2Q0FBWSxDQUFDQSwwQ0FBUyxDQUFDSyxpQkFBaUJjLEdBQUcsQ0FBQyxJQUFJLEtBQUtuQiw0Q0FBVyxDQUFDLElBQUk7SUFDakg7SUFDQSxDQUFDSCw2Q0FBWSxDQUFDLEVBQUN3QixJQUFJO1FBQ2pCLE9BQU9DLFdBQVdELFNBQVN4Qiw2Q0FBWSxDQUFDUSxpQkFBaUJjLEdBQUcsQ0FBQyxJQUFJLEdBQUdkLGlCQUFpQmMsR0FBRyxDQUFDRTtJQUMzRjtBQUNGLEVBQUU7QUFDRixjQUFjLEdBQ1AsTUFBTUMsYUFBYUUsQ0FBQUEsSUFBS3JCLDBEQUFXQSxDQUFDcUIsR0FBR2pCLGdCQUFnQjtBQUM5RCxjQUFjLEdBQ1AsTUFBTWtCLE9BQU9DLENBQUFBO0lBQ2xCLE1BQU1DLFdBQVdDLE9BQU9DLE1BQU0sQ0FBQ25CO0lBQy9CTCxpQkFBaUJ5QixHQUFHLENBQUNILFVBQVVEO0lBQy9CLE9BQU9DO0FBQ1QsRUFBRTtBQUNGLGNBQWMsR0FDUCxNQUFNRCxRQUFRSyxDQUFBQTtJQUNuQixJQUFJMUIsaUJBQWlCMkIsR0FBRyxDQUFDRCxPQUFPO1FBQzlCLE9BQU8xQixpQkFBaUJjLEdBQUcsQ0FBQ1k7SUFDOUIsT0FBTztRQUNMLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtBQUNGLEVBQUU7QUFDRixjQUFjLEdBQ1AsTUFBTUMsYUFBYUgsQ0FBQUEsT0FBUTFCLGlCQUFpQjhCLE1BQU0sQ0FBQ0osTUFBTSxDQUNoRSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL3JlZGFjdGVkLmpzP2JlYTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXF1YWwgZnJvbSBcIi4uL0VxdWFsLmpzXCI7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSBcIi4uL0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxWYWx1ZSB9IGZyb20gXCIuLi9HbG9iYWxWYWx1ZS5qc1wiO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tIFwiLi4vSGFzaC5qc1wiO1xuaW1wb3J0IHsgTm9kZUluc3BlY3RTeW1ib2wgfSBmcm9tIFwiLi4vSW5zcGVjdGFibGUuanNcIjtcbmltcG9ydCB7IHBpcGVBcmd1bWVudHMgfSBmcm9tIFwiLi4vUGlwZWFibGUuanNcIjtcbmltcG9ydCB7IGhhc1Byb3BlcnR5IH0gZnJvbSBcIi4uL1ByZWRpY2F0ZS5qc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmVkYWN0ZWRTeW1ib2xLZXkgPSBcImVmZmVjdC9SZWRhY3RlZFwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHJlZGFjdGVkUmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovZ2xvYmFsVmFsdWUoXCJlZmZlY3QvUmVkYWN0ZWQvcmVkYWN0ZWRSZWdpc3RyeVwiLCAoKSA9PiBuZXcgV2Vha01hcCgpKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBSZWRhY3RlZFR5cGVJZCA9IC8qI19fUFVSRV9fKi9TeW1ib2wuZm9yKFJlZGFjdGVkU3ltYm9sS2V5KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcm90byA9IHtcbiAgW1JlZGFjdGVkVHlwZUlkXToge1xuICAgIF9BOiBfID0+IF9cbiAgfSxcbiAgcGlwZSgpIHtcbiAgICByZXR1cm4gcGlwZUFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCI8cmVkYWN0ZWQ+XCI7XG4gIH0sXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gXCI8cmVkYWN0ZWQ+XCI7XG4gIH0sXG4gIFtOb2RlSW5zcGVjdFN5bWJvbF0oKSB7XG4gICAgcmV0dXJuIFwiPHJlZGFjdGVkPlwiO1xuICB9LFxuICBbSGFzaC5zeW1ib2xdKCkge1xuICAgIHJldHVybiBwaXBlKEhhc2guaGFzaChSZWRhY3RlZFN5bWJvbEtleSksIEhhc2guY29tYmluZShIYXNoLmhhc2gocmVkYWN0ZWRSZWdpc3RyeS5nZXQodGhpcykpKSwgSGFzaC5jYWNoZWQodGhpcykpO1xuICB9LFxuICBbRXF1YWwuc3ltYm9sXSh0aGF0KSB7XG4gICAgcmV0dXJuIGlzUmVkYWN0ZWQodGhhdCkgJiYgRXF1YWwuZXF1YWxzKHJlZGFjdGVkUmVnaXN0cnkuZ2V0KHRoaXMpLCByZWRhY3RlZFJlZ2lzdHJ5LmdldCh0aGF0KSk7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaXNSZWRhY3RlZCA9IHUgPT4gaGFzUHJvcGVydHkodSwgUmVkYWN0ZWRUeXBlSWQpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IG1ha2UgPSB2YWx1ZSA9PiB7XG4gIGNvbnN0IHJlZGFjdGVkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gIHJlZGFjdGVkUmVnaXN0cnkuc2V0KHJlZGFjdGVkLCB2YWx1ZSk7XG4gIHJldHVybiByZWRhY3RlZDtcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdmFsdWUgPSBzZWxmID0+IHtcbiAgaWYgKHJlZGFjdGVkUmVnaXN0cnkuaGFzKHNlbGYpKSB7XG4gICAgcmV0dXJuIHJlZGFjdGVkUmVnaXN0cnkuZ2V0KHNlbGYpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgcmVkYWN0ZWQgdmFsdWVcIik7XG4gIH1cbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdW5zYWZlV2lwZSA9IHNlbGYgPT4gcmVkYWN0ZWRSZWdpc3RyeS5kZWxldGUoc2VsZik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWRhY3RlZC5qcy5tYXAiXSwibmFtZXMiOlsiRXF1YWwiLCJwaXBlIiwiZ2xvYmFsVmFsdWUiLCJIYXNoIiwiTm9kZUluc3BlY3RTeW1ib2wiLCJwaXBlQXJndW1lbnRzIiwiaGFzUHJvcGVydHkiLCJSZWRhY3RlZFN5bWJvbEtleSIsInJlZGFjdGVkUmVnaXN0cnkiLCJXZWFrTWFwIiwiUmVkYWN0ZWRUeXBlSWQiLCJTeW1ib2wiLCJmb3IiLCJwcm90byIsIl9BIiwiXyIsImFyZ3VtZW50cyIsInRvU3RyaW5nIiwidG9KU09OIiwic3ltYm9sIiwiaGFzaCIsImNvbWJpbmUiLCJnZXQiLCJjYWNoZWQiLCJ0aGF0IiwiaXNSZWRhY3RlZCIsImVxdWFscyIsInUiLCJtYWtlIiwidmFsdWUiLCJyZWRhY3RlZCIsIk9iamVjdCIsImNyZWF0ZSIsInNldCIsInNlbGYiLCJoYXMiLCJFcnJvciIsInVuc2FmZVdpcGUiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/redacted.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/effect/dist/esm/internal/version.js":
/*!**********************************************************!*\
  !*** ./node_modules/effect/dist/esm/internal/version.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentVersion: () => (/* binding */ getCurrentVersion),\n/* harmony export */   setCurrentVersion: () => (/* binding */ setCurrentVersion)\n/* harmony export */ });\nlet moduleVersion = \"3.12.0\";\nconst getCurrentVersion = ()=>moduleVersion;\nconst setCurrentVersion = (version)=>{\n    moduleVersion = version;\n}; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxnQkFBZ0I7QUFDYixNQUFNQyxvQkFBb0IsSUFBTUQsY0FBYztBQUM5QyxNQUFNRSxvQkFBb0JDLENBQUFBO0lBQy9CSCxnQkFBZ0JHO0FBQ2xCLEVBQUUsQ0FDRixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90d2lzdGVkLWNhbnRpbmEvLi9ub2RlX21vZHVsZXMvZWZmZWN0L2Rpc3QvZXNtL2ludGVybmFsL3ZlcnNpb24uanM/MDlkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgbW9kdWxlVmVyc2lvbiA9IFwiMy4xMi4wXCI7XG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFZlcnNpb24gPSAoKSA9PiBtb2R1bGVWZXJzaW9uO1xuZXhwb3J0IGNvbnN0IHNldEN1cnJlbnRWZXJzaW9uID0gdmVyc2lvbiA9PiB7XG4gIG1vZHVsZVZlcnNpb24gPSB2ZXJzaW9uO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbIm1vZHVsZVZlcnNpb24iLCJnZXRDdXJyZW50VmVyc2lvbiIsInNldEN1cnJlbnRWZXJzaW9uIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/effect/dist/esm/internal/version.js\n");

/***/ })

};
;